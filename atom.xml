<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaryaLiu&#39;s blog</title>
  
  <subtitle>keep learning, keep moving</subtitle>
  <link href="http://liumh.com/atom.xml" rel="self"/>
  
  <link href="http://liumh.com/"/>
  <updated>2024-10-21T14:21:11.370Z</updated>
  <id>http://liumh.com/</id>
  
  <author>
    <name>CaryaLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之接口隔离原则</title>
    <link href="http://liumh.com/2021/09/26/design-principles-isp-md/"/>
    <id>http://liumh.com/2021/09/26/design-principles-isp-md/</id>
    <published>2021-09-26T00:05:28.000Z</published>
    <updated>2024-10-21T14:21:11.370Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<ahref="http://gk.link/a/10xaT">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="接口隔离原则isp">接口隔离原则（ISP）</h1><p>今天来看看<code>SOLID</code>中的<code>I</code>, 接口隔离原则。</p><h2 id="如何理解接口隔离原则">如何理解“接口隔离原则”？</h2><p>接口隔离原则（<code>Interface Segregation Principle</code>），缩写为<code>ISP</code>。其定义：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they donot use。</p><p>客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p></blockquote><p>"接口"这个名词，在软件开发中，我们既可以把它看做一组抽象的约定，也可以具体指系统与系统之间的<code>API</code>接口，还可以特指面向对象编程语言中的接口等。</p><p>理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解以下三种：</p><ul><li>一组<code>API</code>接口集合</li><li>单个<code>API</code>接口或函数</li><li><code>OOP</code>中的接口概念</li></ul><p>接下来看看，按照这三种理解方式，在不同的场景下，这条原则具体是如何解读和应用的。</p><span id="more"></span><h3id="把接口理解成一组api接口集合">把“接口”理解成一组<code>API</code>接口集合</h3><p>举个例子。客户端开发中，声明了一组<code>API</code>来规范列表类业务开发的逻辑，比如翻页、<code>UITableView</code>的<code>DataSource</code>协议中的计算逻辑。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfSections</span>() -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfRowsIn</span>(<span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="comment">// ...其他行为约定...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span>: <span class="title class_ inherited__">TableViewModel</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们如上定义协议，有一个问题就是，业务是一个列表类型的展示，但是没有翻页的业务场景，但是我遵循了该协议就必须声明翻页逻辑相关的字段。或许可以通过给<code>TableViewModel</code>中的翻页逻辑字段定义默认实现，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，按照接口隔离原则，调用者不应该依赖它不需要的接口，没有翻页逻辑的业务，就不应该遵循上述翻页的接口。</p><p>将翻页的接口单独放到另外一个接口<code>Pageable</code>中，然后将<code>TableViewModel &amp; Pageable</code>打包给具有翻页逻辑的列表使用，不具有翻页逻辑的列表只依赖<code>TableViewModel</code>即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 使用`TableView`实现的列表相关接口</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfSections</span>() -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfRowsIn</span>(<span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="comment">// ...其他行为约定...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 翻页相关接口</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Pageable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 具有翻页的列表</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">PageableTableViewModel</span> <span class="operator">=</span> <span class="type">TableViewModel</span> &amp; <span class="type">Pageable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span>: <span class="title class_ inherited__">PageableTableViewModel</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<code>Pageable</code>协议独立后，可以与项目中<code>UICollectionView</code>实现的列表打包结合使用。</p><p>在上面的例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个视图的接口，也可以是某个类库的接口等等。在设计视图或者类库接口的时候，<strong>如果部分接口只被部分调用者使用</strong>，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h3id="把接口理解为单个api接口或函数">把“接口”理解为单个<code>API</code>接口或函数</h3><p>我们再换一种理解方式，把接口理解为单个接口或函数（以下简称为“函数”）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。接下来，我们还是通过一个例子来解释一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123;</span><br><span class="line">  <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">  <span class="comment">//...省略计算逻辑...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>count()</code>函数的功能包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。</p><p>如果在项目中，对每个统计需求，<code>Statistics</code>定义的那几个统计信息都有涉及，那<code>count()</code>函数的设计就是合理的。相反，如果每个统计需求只涉及<code>Statistics</code>罗列的统计信息中一部分，比如，有的只需要用到<code>max</code>、<code>min</code>、<code>average</code>这三类统计信息，有的只需要用到<code>average</code>、<code>sum</code>。而 <code>count()</code>函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，<code>count()</code>函数的设计就有点不合理了，我们应该按照接口隔离原则，把<code>count()</code>函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure><p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。</p><ul><li>单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，它更侧重于接口的设计;</li><li>接口隔离原则的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</li></ul><h3 id="把接口理解为-oop-中的接口概念">把“接口”理解为 OOP中的接口概念</h3><p>我们还可以把“接口”理解为 OOP 中的接口概念，比如 iOS中的协议（<code>Protocol</code>），这里不考虑利用协议实现委托的场景。举一个简单的例子。</p><p>假如项目中要做习题的功能，分为两种模式：练习模式和挑战模式。练习模式的习题是客户端随机生成，挑战模式下的习题是从数据库中获取。现定义有如下接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LearnService</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchSectionItems</span>(<span class="params">isInit</span>: <span class="type">Bool</span>) -&gt; [<span class="type">Equation</span>]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentItem</span>() -&gt; <span class="type">Equation</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hasFinishSection</span>() -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">//...其他接口...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChallengeService</span>: <span class="title class_ inherited__">LearnService</span> &#123;</span><br><span class="line">    <span class="comment">// ...忽略实现...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LearnService的使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExerciseViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> service: <span class="type">LearnService</span>!</span><br><span class="line">    <span class="comment">// ...省略其他属性...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchDataAndRefresh</span>(<span class="params">isInit</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> items <span class="operator">=</span> service.fetchSectionItems(isInit: isInit)</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>items.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...其他逻辑代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现增加错题本，在练习模式下，错误习题记录到错题本，而在挑战模式下，无需记录。这种情况下，新增接口</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">record</span>(<span class="params">wrong</span>: <span class="type">Equation</span>?)</span><br></pre></td></tr></table></figure><p>是应该放置在<code>LearnService</code>中还是另新增协议<code>RecordService</code>单独维护呢，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">RecordService</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">record</span>(<span class="params">wrong</span>: <span class="type">Equation</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据接口隔离原则，应该使用新增<code>RecordService</code>协议单独维护，这样可以避免在挑战模式下依赖不需要的接口。虽然，在iOS中可以将接口定义成可选类型(<code>optional</code>)，来避免实现不需要的接口，但是这样的话，违背了单一职责原则和接口隔离原则。</p><p>对于第三方库<code>Reusable</code>中，开发者也是将<code>NibLoadable</code>协议和<code>Reusable</code>协议独立，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Reusable</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="comment">/// The reuse identifier to use when registering and later dequeuing a reusable cell</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">NibLoadable</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="comment">/// The nib file to use to load a new instance of the View designed in a XIB</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> nib: <span class="type">UINib</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">NibReusable</span> <span class="operator">=</span> <span class="type">Reusable</span> &amp; <span class="type">NibLoadable</span></span><br></pre></td></tr></table></figure><p>满足接口隔离原则，避免实现者依赖不需要的接口。</p><h2 id="重点回顾">重点回顾</h2><ol type="1"><li>如何理解“接口隔离原则”？</li></ol><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><ol start="2" type="1"><li>接口隔离原则与单一职责原则的区别</li></ol><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a
href=&quot;http://gk.link/a/10xaT&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;接口隔离原则isp&quot;&gt;接口隔离原则（ISP）&lt;/h1&gt;
&lt;p&gt;今天来看看&lt;code&gt;SOLID&lt;/code&gt;中的&lt;code&gt;I&lt;/code&gt;, 接口隔离原则。&lt;/p&gt;
&lt;h2 id=&quot;如何理解接口隔离原则&quot;&gt;如何理解“接口隔离原则”？&lt;/h2&gt;
&lt;p&gt;接口隔离原则（&lt;code&gt;Interface Segregation Principle&lt;/code&gt;），缩写为&lt;code&gt;ISP&lt;/code&gt;。其定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clients should not be forced to depend upon interfaces that they do
not use。&lt;/p&gt;
&lt;p&gt;客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&quot;接口&quot;这个名词，在软件开发中，我们既可以把它看做一组抽象的约定，也可以具体指系统与系统之间的&lt;code&gt;API&lt;/code&gt;接口，还可以特指面向对象编程语言中的接口等。&lt;/p&gt;
&lt;p&gt;理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一组&lt;code&gt;API&lt;/code&gt;接口集合&lt;/li&gt;
&lt;li&gt;单个&lt;code&gt;API&lt;/code&gt;接口或函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOP&lt;/code&gt;中的接口概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来看看，按照这三种理解方式，在不同的场景下，这条原则具体是如何解读和应用的。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之里氏替换原则</title>
    <link href="http://liumh.com/2021/09/11/design-principles-lsp-md/"/>
    <id>http://liumh.com/2021/09/11/design-principles-lsp-md/</id>
    <published>2021-09-11T00:02:58.000Z</published>
    <updated>2024-10-21T14:21:20.631Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<ahref="http://gk.link/a/10xaN">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="里氏替换原则lsp">里氏替换原则（LSP）</h1><p>今天来看看<code>SOLID</code> 中的<code>L</code>, 里氏替换原则。</p><h2 id="如何理解里式替换原则">如何理解“里式替换原则”？</h2><p>里式替换原则（<code>Liskov Substitution Principle</code>），缩写为<code>LSP</code>。最早是在 1986 年由 Barbara Liskov提出。里氏替换原则的定义：</p><blockquote><p>子类对象（object of subtype/derivedclass）能够替换程序（program）中父类对象（object of base/parentclass）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p></blockquote><span id="more"></span><p>举个例子来解释。如下代码，父类<code>UserManager</code>通过接口<code>getUserInfo()</code>来获取存储在本地的用户信息，子类<code>SecurityUserManager</code>增加了额外功能，将用户信息中的加密字段解密完成后，再返回给上层业务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">/// 获取本地用户信息，如果获取出现错误，则返回`nil`，获取的值为空，则返回`[:]`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="comment">// 获取本地用户信息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">#function</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> decryptionKey: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">decryptionKey</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.decryptionKey <span class="operator">=</span> decryptionKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getUserInfo</span>(<span class="keyword">_</span> <span class="params">manager</span>: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> manager.getUserInfo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewController</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> demo <span class="operator">=</span> <span class="type">XXViewModel</span>()</span><br><span class="line">    <span class="comment">// 里氏替换原则</span></span><br><span class="line">    demo.getUserInfo(<span class="type">SecurityUserManager</span>(decryptionKey: <span class="string">&quot;kkk&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类<code>SecurityUserManager</code>的设计完全符合里氏替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？</p><p>现在对上面<code>SecurityUserManager</code>中的接口<code>getUserInfo()</code>改造一下。改造前：获取本地用户信息，如果获取出现错误，则返回<code>nil</code>，获取的值为空，则返回<code>[:]</code>；改造后：获取本地用户信息，出现错误或者获取的值为空，都返回<code>[:]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> [:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在改造后的代码中，如果传递给<code>XXViewModel.getUserInfo(:)</code>函数的是<code>SecurityUserManager</code>对象，业务层获取到的数据含义发生改变，整个程序的逻辑行为有了改变。</p><p>虽然改造之后的代码仍然可以通过多态语法，动态地用子类<code>SecurityUserManager</code>来替换父类<code>UserManager</code>，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，<code>SecurityUserManager</code>的设计是不符合里式替换原则的。</p><p>总结：虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，<strong>是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</strong></p><h2 id="哪些代码明显违背了-lsp">哪些代码明显违背了 LSP？</h2><p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“DesignBy Contract”，中文翻译就是“按照协议来设计”。</p><p>子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：</p><ul><li><p>函数声明要实现的功能；</p></li><li><p>对输入、输出、异常的约定；</p></li><li><p>注释中所罗列的任何特殊说明。</p></li></ul><p>实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><p>违反里氏替换原则的例子。</p><ol type="1"><li><p>子类违背父类声明要实现的功能</p><p>父类中提供的 <code>sortOrdersByAmount()</code>订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个<code>sortOrdersByAmount()</code>订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p></li><li><p>子类违背父类对输入、输出、异常的约定</p><p>在父类中，某个函数约定：运行出错的时候返回<code>null</code>；获取数据为空的时候返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回<code>null</code>。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException异常，那子类的设计实现中只允许抛出 ArgumentNullException异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><p>父类中定义的 withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw() 函数之后，针对 VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p></li></ol><p>以上便是三种典型的违背里式替换原则的情况。除此之外，可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><h2 id="重点回顾">重点回顾</h2><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“designbycontract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解里式替换原则跟多态的区别。多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a
href=&quot;http://gk.link/a/10xaN&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;里氏替换原则lsp&quot;&gt;里氏替换原则（LSP）&lt;/h1&gt;
&lt;p&gt;今天来看看&lt;code&gt;SOLID&lt;/code&gt; 中的&lt;code&gt;L&lt;/code&gt;, 里氏替换原则。&lt;/p&gt;
&lt;h2 id=&quot;如何理解里式替换原则&quot;&gt;如何理解“里式替换原则”？&lt;/h2&gt;
&lt;p&gt;里式替换原则（&lt;code&gt;Liskov Substitution Principle&lt;/code&gt;），缩写为
&lt;code&gt;LSP&lt;/code&gt;。最早是在 1986 年由 Barbara Liskov
提出。里氏替换原则的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子类对象（object of subtype/derived
class）能够替换程序（program）中父类对象（object of base/parent
class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之开闭原则</title>
    <link href="http://liumh.com/2021/08/26/design-principles-ocp-md/"/>
    <id>http://liumh.com/2021/08/26/design-principles-ocp-md/</id>
    <published>2021-08-25T23:59:48.000Z</published>
    <updated>2024-10-21T14:21:37.857Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<ahref="http://gk.link/a/10wrA">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="开闭原则">开闭原则</h1><p>在 23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p><h2id="如何理解对扩展开放修改关闭">如何理解“对扩展开放、修改关闭”？</h2><p>开闭原则（Open Closed Principle）,简写为OCP。其定义：</p><blockquote><p>software entities (modules, classes, functions, etc.) should be openfor extension , but closed for modification。</p><p>软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p></blockquote><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><span id="more"></span><p>为了便于理解该原则，这里举一个例子。下面是一个Web容器中的一段代码，意在根据操作类型判断处理是否导航到新的内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> wkWebView: <span class="type">WKWebView</span> <span class="operator">=</span> createWkWebView()</span><br><span class="line">    <span class="keyword">var</span> url <span class="operator">=</span> <span class="string">&quot;https://taobao.com&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        setupWkWebView()</span><br><span class="line">        wkWebView.load(<span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: url)<span class="operator">!</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupWkWebView</span>() &#123;</span><br><span class="line">        view.addSubview(wkWebView)</span><br><span class="line">        wkWebView.snp.makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.edges.equalToSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">        wkWebView.navigationDelegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">createWkWebView</span>() -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">        configuration.allowsInlineMediaPlayback <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        configuration.dataDetectorTypes <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">let</span> wkWebView <span class="operator">=</span> <span class="type">WKWebView</span>(frame: <span class="type">CGRect</span>.zero, configuration: configuration)</span><br><span class="line">        <span class="keyword">return</span> wkWebView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊scheme的事件</span></span><br><span class="line">        <span class="keyword">let</span> hasHandledNavigation <span class="operator">=</span> handleNavigation(navigationAction)</span><br><span class="line">        <span class="keyword">if</span> hasHandledNavigation &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们现在有一种新的业务场景，比如需要对接快电，我们需要判断<code>navigationAction</code>中的<code>url</code>是否包含快电的域名，然后做出对应的处理。主要的改动有：</p><ol type="1"><li>增加判断是否包含快电的域名，并做出处理快电业务的逻辑</li><li>根据判断结果，进行对应的回调处理</li></ol><p>修改的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊scheme的事件</span></span><br><span class="line">        <span class="keyword">let</span> hasHandledNavigation <span class="operator">=</span> handleNavigation(navigationAction)</span><br><span class="line">        <span class="keyword">if</span> hasHandledNavigation &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改动点1：针对处理快电的逻辑进行回调</span></span><br><span class="line">        <span class="comment">// 处理第三方对接</span></span><br><span class="line">        <span class="keyword">if</span> handleFleetingPower(navigationAction) &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改动点2：处理快电的业务逻辑</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">handleFleetingPower</span>(<span class="keyword">_</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url<span class="operator">?</span>.absoluteString,</span><br><span class="line">           url.contains(<span class="string">&quot;fleetingpower.com&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理快电业务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p><p>我们先重构一下之前的代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul><li>引入<code>HybridWebNavigationPolicy</code>协议，用于抽象在上述代理方法中进行处理的各种判断策略</li><li>引入<code>WebNavigationPolicyManager</code>管理类，用户处理各种策略的优先级以及策略集合的组装</li></ul><p>具体代码实现如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 处理特殊scheme的事件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CommonNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url <span class="keyword">as</span> <span class="type">NSURL</span>?</span><br><span class="line">        <span class="keyword">let</span> scheme <span class="operator">=</span> url<span class="operator">?</span>.scheme</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> url, <span class="keyword">let</span> scheme <span class="operator">=</span> scheme &#123;</span><br><span class="line">            <span class="keyword">if</span> scheme <span class="operator">==</span> <span class="string">&quot;tel&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> resourceSpecifier <span class="operator">=</span> url.resourceSpecifier</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    <span class="comment">// 拨打电话</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> scheme <span class="operator">==</span> <span class="string">&quot;itms-apps&quot;</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到AppStore</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebNavigationPolicyManager</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">navigationPolicics</span>() -&gt; [<span class="type">HybridWebNavigationPolicy</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> common <span class="operator">=</span> <span class="type">CommonNavigationPolicy</span>()</span><br><span class="line">        <span class="keyword">return</span> [common]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">/// 依赖注入的方式</span></span><br><span class="line">    <span class="keyword">var</span> policies <span class="operator">=</span> <span class="type">WebNavigationPolicyManager</span>.navigationPolicics()</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> policy <span class="keyword">in</span> policies &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>policy.decidePolicy(for: navigationAction, webController: owner) &#123;</span><br><span class="line">                decisionHandler(.cancel)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，对接快电的业务，我们又该如何改动代码呢？主要的改动有下面四处。</p><ul><li>改动点1，新增<code>FleetingPowerNavigationPolicy</code>，遵循<code>HybridWebNavigationPolicy</code>协议，用于处理快电业务</li><li>改动点2，在<code>WebNavigationPolicyManager</code>中<code>static func navigationPolicics() -&gt; [HybridWebNavigationPolicy]</code>函数返回数组中增加<code>FleetingPowerNavigationPolicy</code>的实例</li></ul><p>具体代码实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 处理特殊scheme的事件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CommonNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 改动点1：处理快电业务</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FleetingPowerNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url<span class="operator">?</span>.absoluteString,</span><br><span class="line">           url.contains(<span class="string">&quot;fleetingpower.com&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebNavigationPolicyManager</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">navigationPolicics</span>() -&gt; [<span class="type">HybridWebNavigationPolicy</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> common <span class="operator">=</span> <span class="type">CommonNavigationPolicy</span>()</span><br><span class="line">        <span class="comment">// 改动点2：新增`FleetingPowerNavigationPolicy`的实例</span></span><br><span class="line">        <span class="keyword">let</span> fleetingPower <span class="operator">=</span> <span class="type">FleetingPowerNavigationPolicy</span>()</span><br><span class="line">        <span class="keyword">return</span> [common, fleetingPower]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 代码未改动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的基于操作的导航判断，只需要基于扩展的方式创建新的<code>Policy</code>类即可，不需要改动原来的<code>webView(_:decidePolicyFor:decisionHandler:)</code>函数的逻辑。</p><h2id="修改代码就意味着违背开闭原则吗">修改代码就意味着违背开闭原则吗？</h2><p>从开闭原则的定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p><p>看了上面重构之后的代码，你可能还会有疑问：在添加新的判断处理逻辑的时候，尽管改动点1（添加新的<code>Policy</code>类）是基于扩展而非修改的方式来完成，但是改动点2貌似不是基于扩展而是基于修改的方式来完成的，那改动点1不就违背开闭原则了吗？</p><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p><p>在重构之后的<code>webView(_:decidePolicyFor:decisionHandler:)</code>代码实现中，我们的核心逻辑集中在该方法中以及各个<code>Policy</code>中，当我们在添加新的判断处理逻辑的时候，该方法完全不需要修改，而只需要扩展一个新的<code>Policy</code>类。如果我们把该方法及各个<code>Policy</code>类合起来看做一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。</p><p>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h2id="如何做到对扩展开放修改关闭">如何做到“对扩展开放、修改关闭”？</h2><p>开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p><p><strong>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，<strong>提供抽象化的不可变接口</strong>，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。</p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</p><h2id="如何在项目中灵活应用开闭原则">如何在项目中灵活应用开闭原则？</h2><p>写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？</p><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p><p>即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><p>开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a
href=&quot;http://gk.link/a/10wrA&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;开闭原则&quot;&gt;开闭原则&lt;/h1&gt;
&lt;p&gt;在 23
种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。&lt;/p&gt;
&lt;h2
id=&quot;如何理解对扩展开放修改关闭&quot;&gt;如何理解“对扩展开放、修改关闭”？&lt;/h2&gt;
&lt;p&gt;开闭原则（Open Closed Principle）,简写为OCP。其定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;software entities (modules, classes, functions, etc.) should be open
for extension , but closed for modification。&lt;/p&gt;
&lt;p&gt;软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单一职责原则</title>
    <link href="http://liumh.com/2021/08/06/design-principles-srp-md/"/>
    <id>http://liumh.com/2021/08/06/design-principles-srp-md/</id>
    <published>2021-08-05T23:51:27.000Z</published>
    <updated>2024-10-21T14:21:47.984Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<ahref="http://gk.link/a/10vlE">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="单一职责原则srp">单一职责原则（SRP）</h1><p><code>SOLID</code>原则是由 5个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应<code>SOLID</code> 中的 S、O、L、I、D 这 5 个英文字母。今天学习的是<code>SOLID</code> 原则中的第一个原则：单一职责原则。</p><span id="more"></span><h2 id="如何理解单一职责原则srp">如何理解单一职责原则（SRP）？</h2><p>单一职责原则（<code>Single Responsibility Principle</code>)，缩写为<code>SRP</code>。其定义：</p><blockquote><p>A class or module should have a single responsibility。</p><p>一个类或者模块只负责完成一个职责（或者功能）。</p></blockquote><p>这个原则描述的两个对象，一个是类（class），一个是模块（module）。关于这两个概念，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p><p>一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><p>单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h2id="如何判断类的职责是否足够单一">如何判断类的职责是否足够单一？</h2><p>对于如何判断类的职责是否单一，不能脱离具体的应用场景。不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判断，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或者在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p><p>比如对于下面的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> long userId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> username;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> email;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> telephone;</span><br><span class="line">  <span class="keyword">private</span> long createTime;</span><br><span class="line">  <span class="keyword">private</span> long lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那UserInfo现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul><li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li><li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li><li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public 方法，供更多的类使用，从而提高代码的复用性；</li><li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li><li>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo例子中，如果一半的方法都是在操作 address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li></ul><p>对于上述第一条，如何判定类中的代码行数、函数或属性过多，可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过200 行，函数个数及属性个数都最好不要超过 10 个。实际上，从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。</p><h2id="类的职责是否设计得越单一越好">类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。</p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a
href=&quot;http://gk.link/a/10vlE&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;单一职责原则srp&quot;&gt;单一职责原则（SRP）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SOLID&lt;/code&gt;原则是由 5
个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应
&lt;code&gt;SOLID&lt;/code&gt; 中的 S、O、L、I、D 这 5 个英文字母。今天学习的是
&lt;code&gt;SOLID&lt;/code&gt; 原则中的第一个原则：单一职责原则。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>阿里组件化框架BeeHive解析</title>
    <link href="http://liumh.com/2018/10/11/beehive-analysis/"/>
    <id>http://liumh.com/2018/10/11/beehive-analysis/</id>
    <published>2018-10-11T03:14:46.000Z</published>
    <updated>2024-10-21T14:51:44.370Z</updated>
    
    <content type="html"><![CDATA[<p>本文是基于BeeHive版本1.6.0进行分析。</p><p>BeeHive核心思想涉及两个部分：</p><ol type="1"><li>各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。</li><li>App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。</li></ol><p>Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。</p><span id="more"></span><p>本文会按照以下顺序进行介绍：</p><ul><li><a href="#beehive-overview">BeeHive概览</a></li><li><a href="#beehive-lifecycle-event">BeeHive模块生命周期事件</a><ul><li><a href="#beehive-system-event">系统事件</a></li><li><a href="#beehive-event-extension">通用事件</a></li><li><a href="#beehive-custom-event">业务自定义事件</a></li></ul></li><li><a href="#beehive-register-module">BeeHive模块注册</a><ul><li><a href="#annotation-register-module">Annotation方式注册</a></li><li><a href="#plist-register-module">读取本地Plist方式注册</a></li><li><a href="#load-register-module">Load方法注册</a></li></ul></li><li><a href="#beehive-register-service">BeeHive模块间调用</a><ul><li><a href="#annotation-register-service">Annotation方式注册</a></li><li><a href="#plist-register-service">读取本地Plist方式注册</a></li><li><a href="#api-register-service">API注册</a></li></ul></li><li><a href="#beehive-context">上下文环境Context</a></li></ul><h1 id="beehive概览">BeeHive概览</h1><p>BeeHive的架构图如下所示：</p><!--![BeeHive架构图](/img/beehive-analysis/beehive-arch.png)--><div class="figure " style="width:684;"><img class="fig-img" src="/img/beehive-analysis/beehive-arch.png" style="width:684;height:379;"alt="BeeHive架构图"><span class="caption">BeeHive架构图</span></div><p>图中的BHContext，包含BeeHive的配置文件，提供全局统一上下文信息。</p><p>图中的BHCore包含：</p><ul><li>BeeHive，提供组件库对外接口</li><li>BHModuleManager和BHModuleProtocol，注册和创建Module逻辑</li><li>BHServiceManager和BHServiceProtocol，注册和创建Service逻辑</li><li>BHRouter</li></ul><p>Module、Service注册和调用逻辑只和核心模块相关，Module之间没有直接的关联关系。</p><p>对于Module和Service的注册，BeeHive提供了三种不同的形式：静态plist，动态注册，annotation。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p><!--![Module注册](/img/beehive-analysis/beehive-register-module.png)--><div class="figure " style="width:682;"><img class="fig-img" src="/img/beehive-analysis/beehive-register-module.png" style="width:682;height:564;"alt="Module注册"><span class="caption">Module注册</span></div><p>图中包含了主要的BeeHive启动过程以及Module注册的时序逻辑。Module的事件分发源于BHAppDelegate中的<em>triggerEvent</em>。</p><p>加载Module：</p><ol type="1"><li>BeeHive.plist中配置的module和service是在 AppDelegate中调用<code>[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</code>时加载。</li><li>Module的实现中 <code>+load</code>内部调用<code>[BeeHive registerDynamicModule:[self class]];</code>动态加载。</li><li>Module的实现中使用注解： <code>@BeeHiveMod(XXModule)</code></li></ol><p>BHAppDelegate中除了回调系统的事件，还将App生命周期进行扩展，增加<em>ModuleSetup</em>，<em>ModuleInit</em>，<em>ModuleSplash</em>，此外开发人员还可以自行扩展。</p><!--![BeeHive事件扩展](/img/beehive-analysis/beehive-event-extension.png)--><div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-event-extension.png" alt="BeeHive事件扩展"><span class="caption">BeeHive事件扩展</span></div><p>扩展周期过程中，同时加入Module分析量化功能，每个模块Init的耗时均可计算出来，为性能优化做到数据上的支持。一个App的业务增多过程中，通过分析定位Module的Init耗时可以确定需要优化的Module。</p><p>Module遵循<em>BHModuleProtocol</em>后，能够捕获App状态的回调，并拥有App生命周期内的全局上下文，通过context可获取配置参数，模块资源以及服务资源。</p><p>以BeeHive作为底层框架的App，除了解耦带来的便利，开发人员在开发新App过程中涉及相同功能的Module，无需重复造轮子，直接移植Module，开发一个App如同拼装积木，能组合需要的功能业务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BHModuleManager.m:</span><br><span class="line"></span><br><span class="line">//BHModuleInfos: [&#123;moduleClass:String, ModuleLevel:NSNumber, modulePriority:String&#125;]</span><br><span class="line">//BHModules: [id&lt;BHModuleProtocol&gt;]</span><br><span class="line"></span><br><span class="line">@interface BHModuleManager()</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableArray *BHModuleDynamicClasses;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableArray&lt;NSDictionary *&gt; *BHModuleInfos;</span><br><span class="line">@property(nonatomic, strong) NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *BHModules;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *&gt; *BHModulesByEvent;</span><br><span class="line">@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSString *&gt; *BHSelectorByEvent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><em>BHModuleInfos</em>和<em>BHModulesByEvent</em>中<code>id&lt;BHModuleProtocol&gt;</code>均按照<em>moduleInstances</em>的<em>moduleLevel</em>和<em>modulePriority</em>进行了排序。</p><!--![注册静态plist service](/img/beehive-analysis/beehive-register-local-service.png)--><div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-register-local-service.png" alt="注册静态plist service"><span class="caption">注册静态plist service</span></div><p>上图中包含注册静态plist中service的相关逻辑，App启动时通过BeeHive的<code>setContext:</code>来触发plist中service的注册。service的注册并没有创建对应的service实例，只是在BHServiceManager中建立<em>Service协议</em>和<em>实现该协议的类</em>之间的映射关系。</p><!--![动态注册service](/img/beehive-analysis/beehive-dynamic-register-service.png)--><div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-dynamic-register-service.png" alt="动态注册service"><span class="caption">动态注册service</span></div><p>上图中是动态注册service的逻辑，这是在App启动事件分发时触发。Module根据需求动态注册某个服务，通常，注册service的代码在module的<code>modInit:</code>或者<code>modSetup:</code>中。</p><!--![创建service实例](/img/beehive-analysis/beehive-create-service.png)--><div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-create-service.png" alt="创建service实例"><span class="caption">创建service实例</span></div><p>业务组件可以通过<code>createService:</code>直接调用服务。Service的调用和实现，核心是BHServiceManager。可以单独创建ServicesInterfacePod，统一放置要用的Services，这样的业务依赖就从网状式变成中心式，业务方只需依赖Services一个。</p><p>Service可以按需加载，BeeHive逻辑是将基础服务注册在plist中，业务型服务允许Service不先注册，直到业务需要时才被动态注册。</p><p>Service支持两种不同模式：</p><ul><li>单例：对于全局统一且无状态服务，建议使用这种创建形式，这样有利于Service的统一管理以及减少不必要内存消耗。</li><li>多实例：每次调用服务都重新创建新的服务，对于涉及状态以及状态变化的服务最适合使用多实例方式。</li></ul><p>在多线程环境下遇到了Service读写问题，已通过Lock来已避免Arraycrash问题。 不过Service还存在如下问题：</p><ul><li>Service依赖关系,导致底层依赖的Service没有被创建时就被调用。</li><li>规划Service、Module创建顺序，使得App达到秒开，优化性能体验。</li></ul><p>前者依赖问题计划通过调度机制来解决，后者还需要将AppDelegate更多业务剥离以及实践才可。</p><p>BeeHive使用<code>createService:</code>和<code>createService:withServiceName:</code>来创建实现了协议的对象，并且缓存该对象。</p><h1 id="beehive模块生命周期事件">BeeHive模块生命周期事件</h1><p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p><p>事件分为三种类型：</p><ul><li>系统事件</li><li>通用事件</li><li>业务自定义事件</li></ul><p>在BHModuleManager的头文件中，Event的类型定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    BHMSetupEvent = 0,</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent = 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="系统事件">系统事件</h2><!--![BeeHive系统事件](/img/beehive-analysis/beehive-system-event.png)--><div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-system-event.png" alt="BeeHive系统事件"><span class="caption">BeeHive系统事件</span></div><p>系统事件通常是Application生命周期事件，例如<em>WillResignActiveEvent</em>,<em>DidEnterBackgroundEvent</em>, <em>WillEnterForegroundEvent</em>,<em>DidBecomeActiveEvent</em>, <em>WillTerminateEvent</em>。</p><p>一般做法是使用BHAppDelegate来接管系统事件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//TestAppDelegate.h</span><br><span class="line">#import &quot;BeeHive.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br><span class="line"></span><br><span class="line">//TestAppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br><span class="line">    </span><br><span class="line">    [BeeHive shareInstance].enableException = YES;</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BHAppDelegate的实现文件中，实现了一系列的系统调用事件。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMSetupEvent];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMInitEvent];</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMSplashEvent];</span><br><span class="line">    &#125;);</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span><br><span class="line">    if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 10.0f) &#123;</span><br><span class="line">        [UNUserNotificationCenter currentNotificationCenter].delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] saveTimeProfileDataIntoFile:@&quot;BeeHiveTimeProfiler&quot;];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400 </span><br><span class="line"></span><br><span class="line">-(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.touchShortcutItem setShortcutItem: shortcutItem];</span><br><span class="line">    [[BeeHive shareInstance].context.touchShortcutItem setScompletionHandler: completionHandler];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMQuickActionEvent];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillResignActiveEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidEnterBackgroundEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillEnterForegroundEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidBecomeActiveEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillTerminateEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOpenURL:url];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setSourceApplication:sourceApplication];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setAnnotation:annotation];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOpenURL:url];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOptions:options];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveMemoryWarningEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationsError:error];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToRegisterForRemoteNotificationsEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setDeviceToken: deviceToken];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidRegisterForRemoteNotificationsEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationResultHander: completionHandler];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setLocalNotification: notification];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveLocalNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80000</span><br><span class="line">- (void)application:(UIApplication *)application didUpdateUserActivity:(NSUserActivity *)userActivity</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMDidUpdateUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didFailToContinueUserActivityWithType:(NSString *)userActivityType error:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityError: error];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setRestorationHandler: restorationHandler];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application willContinueUserActivityWithType:(NSString *)userActivityType</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMWillContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)application:(UIApplication *)application handleWatchKitExtensionRequest:(nullable NSDictionary *)userInfo reply:(void(^)(NSDictionary * __nullable replyInfo))reply &#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [BeeHive shareInstance].context.watchItem.userInfo = userInfo;</span><br><span class="line">        [BeeHive shareInstance].context.watchItem.replyHandler = reply;</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMHandleWatchKitExtensionRequestEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler &#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotification: notification];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationPresentationOptionsHandler: completionHandler];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setCenter:center];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillPresentNotificationEvent];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler &#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationResponse: response];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationCompletionHandler:completionHandler];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setCenter:center];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveNotificationResponseEvent];</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样所有的系统事件都可以通过BHModuleManager的<code>triggerEvent:</code>来处理。</p><p>在上述事件中，<em>BHMInitEvent</em>和<em>BHMTearDownEvent</em>事件需要做特殊处理。</p><p>先看看<em>BHMInitEvent</em>的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesInitEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                        withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = BHMInitEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMInitEvent)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        __weak typeof(&amp;*self) wself = self;</span><br><span class="line">        void ( ^ bk )(void);</span><br><span class="line">        bk = ^()&#123;</span><br><span class="line">            __strong typeof(&amp;*self) sself = wself;</span><br><span class="line">            if (sself) &#123;</span><br><span class="line">                if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123;</span><br><span class="line">                    [moduleInstance modInit:context];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- modInit:&quot;, [moduleInstance class]]];</span><br><span class="line">        </span><br><span class="line">        if ([moduleInstance respondsToSelector:@selector(async)]) &#123;</span><br><span class="line">            BOOL async = [moduleInstance async];</span><br><span class="line">            </span><br><span class="line">            if (async) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    bk();</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>BHMInitEvent</em>事件是触发各个module启动时的初始化逻辑。这里从<code>self.BHModulesByEvent</code>中取出<em>BHMInitEvent</em>事件对应的module数组，遍历其中的每个module实例，向其发送<code>modInit:</code>消息。这里会考虑是否异步执行module的初始化。如果moduleInstance重写了<code>async</code>方法，那么就会根据该方法的返回值来决定是否异步执行module的初始化。</p><p><code>modInit:</code>方法由各个module实例各自实现，可以在其中注册一个外部模块可以访问的<code>Service</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)modInit:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    //注册模块的接口服务</span><br><span class="line">    [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看<em>BHMTearDownEvent</em>事件。这个事件中可以处理module的清理工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesTearDownEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                            withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = BHMTearDownEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMTearDownEvent)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Reverse Order to unload</span><br><span class="line">    for (int i = (int)moduleInstances.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance = [moduleInstances objectAtIndex:i];</span><br><span class="line">        if (moduleInstance &amp;&amp; [moduleInstance respondsToSelector:@selector(modTearDown:)]) &#123;</span><br><span class="line">            [moduleInstance modTearDown:context];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于module具有优先级，且<code>self.BHModulesByEvent</code>结构中，每种事件类型对应的modules数组中的module元素都已经按照优先级从高到低排列，因此逆序对modules数组中的module元素调用<code>modTearDown:</code>方法。</p><h2 id="通用事件">通用事件</h2><p>在系统事件的基础之上，扩展了应用的通用事件，例如<em>modSetup</em>、<em>modInit</em>等，可以用于编码实现各插件模块的设置与初始化。</p><p>扩展的通用事件如下：</p><!--![BeeHive通用事件](/img/beehive-analysis/beehive-event-extension.png)--><div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-event-extension.png" alt="BeeHive通用事件"><span class="caption">BeeHive通用事件</span></div><p>所有的事件都可以通过调用BHModuleManager的<code>triggerEvent:</code>来处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，事件类型分发是在方法<code>handleModuleEvent:forTarget:withCustomParam:</code>中进行。如之前所述，需要对<em>BHMInitEvent</em>和<em>BHMTearDownEvent</em>做特殊处理。同时，触发各个module(从<code>self.BHModulesByEvent</code>中获取)中的响应事件方法通过<code>performSelector:withObject:</code>来调用。</p><p>注意这里的module都是遵循<em>BHModuleProtocol</em>协议的。</p><p>通用事件中，可以在<em>modSetup</em>中设置环境变量,通过<em>context.env</em>可以判断我们的应用环境状态来决定我们如何配置我们的应用。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)modSetup:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    switch (context.env) &#123;</span><br><span class="line">        case BHEnvironmentDev:</span><br><span class="line">        //....初始化开发环境</span><br><span class="line">        break;</span><br><span class="line">        case BHEnvironmentProd:</span><br><span class="line">        //....初始化生产环境</span><br><span class="line">        default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务自定义事件">业务自定义事件</h2><p>如果觉得系统事件、通用事件不足以满足需要，我们还将事件封装简化成BHAppdelgate，你可以通过继承BHAppdelegate来扩展自己的事件。通过以下方式来注册自定义事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerCustomEvent:(NSInteger)eventType</span><br><span class="line">   withModuleInstance:(id)moduleInstance</span><br><span class="line">       andSelectorStr:(NSString *)selectorStr &#123;</span><br><span class="line">    if (eventType &lt; 1000) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self registerEvent:eventType withModuleInstance:moduleInstance andSelectorStr:selectorStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发带参数的事件响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="beehive模块注册">BeeHive模块注册</h1><p>使用注解的方式注册Module和Service时，Module和Service的注册发生在加载镜像文件时期。</p><p>plist方式注册Module和Service，是在AppDelegate中设置BeeHive的Context时加载注册。</p><p>Module动态注册是在+load方法中，也是在加载镜像时注册。Service的动态注册可以Module的<code>modInit:</code>或者<code>modSetup:</code>中，或者使用时注册。</p><p>模块注册有三种方式：Annotation方式注册、读取本地plist方式注册、Load方法注册。所谓注册，就是将Module类告知BHModuleManager来管理。由此可见，在BeeHive中是通过BHModuleManager来管理各个模块的，BHModuleManager中只会管理已经被注册过的模块。</p><h2 id="annotation方式注册">Annotation方式注册</h2><p>通过BeeHiveMod宏进行Annotation标记。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BeeHiveMod(ShopModule)</span><br></pre></td></tr></table></figure><p>BeeHiveMod宏定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = &quot;&quot;#name&quot;&quot;;</span><br></pre></td></tr></table></figure><p>BeeHiveDATA也是一个宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))</span><br></pre></td></tr></table></figure><p>在预编译结束后，BeeHiveMode宏最终会完全展开成下面的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>这里需要注意双引号的总对数。</p><p>关于__attribute的用法，可参考我的另一篇<ahref="http://liumh.com/2018/08/18/ios-attribute-section/"><strong>attribute</strong></a></p><p>__attribute第一个参数<em>used</em>,它的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。</p><p>有时候我们需要指定一个特殊的段，来存放我们想要的数据。这里我们就把数据存在__DATA数据段里面的"BeehiveMods"section中。Attributes的修饰关键字<code>section ("section-name”)</code>可以达到此要求。</p><p>上述代码中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>去掉__attribute的属性，相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>只不过是将<em>kShopModule_mod</em>变量存储在了__DATA段的<em>BeehiveMods</em>section中。</p><p>这样，所有的Module类名的字符串都会放置在__DATA段<em>BeehiveMods</em>section中，那么如何取出这些字符串呢？</p><p>这里先介绍一下<code>__attribute__((constructor))</code>：</p><p><em>constructor</em>：顾名思义，构造器加上这个属性的函数会在可执行文件（或shared library）load时被调用，可以理解为在 main() 函数调用前执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;main&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;</span><br></pre></td></tr></table></figure><p><code>_dyld_register_func_for_add_image</code>:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following functions allow you to install callbacks which will be called   </span><br><span class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line"> * and before the image is un-memory-mapped.</span><br><span class="line"> */</span><br><span class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) </span><br><span class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))</span><br></pre></td></tr></table></figure><p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调<code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的mach_header以及一个虚拟内存地址intptr_t。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls = NSClassFromString(modName);</span><br><span class="line">            </span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mach_header是定义在<code>usr/include/mach-o/loader.h</code>中的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">     uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">     cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">     cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">     uint32_t    filetype;    /* type of file */</span><br><span class="line">     uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">     uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">     uint32_t    flags;        /* flags */</span><br><span class="line">     uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过调用<em>BHReadConfiguration</em>函数，我们就可以拿到之前注册到<em>BeehiveMods</em>特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p><p>然后将Module交由到BHModuleManager管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addModuleFromObject:(id)object</span><br><span class="line">     shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    Class class;</span><br><span class="line">    NSString *moduleName = nil;</span><br><span class="line">    </span><br><span class="line">    if (object) &#123;</span><br><span class="line">        class = object;</span><br><span class="line">        moduleName = NSStringFromClass(class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 检测是否已存在Module类 */</span><br><span class="line">    __block BOOL flag = YES;</span><br><span class="line">    [self.BHModules enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([obj isKindOfClass:class]) &#123;</span><br><span class="line">            flag = NO;</span><br><span class="line">            *stop = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    if (!flag) &#123;  /**&lt; 如果已存在，则返回，不做处理 */</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([class conformsToProtocol:@protocol(BHModuleProtocol)]) &#123;</span><br><span class="line">        NSMutableDictionary *moduleInfo = [NSMutableDictionary dictionary];</span><br><span class="line">        </span><br><span class="line">        /** basicModuleLevel 这个方法如果不实现，Level是Normal: 1 */</span><br><span class="line">        BOOL responseBasicLevel = [class instancesRespondToSelector:@selector(basicModuleLevel)];</span><br><span class="line">        int levelInt = 1;</span><br><span class="line">        </span><br><span class="line">        if (responseBasicLevel) &#123;</span><br><span class="line">            /** basicModuleLevel 这个方法如果实现，Level是Basic: 0 */</span><br><span class="line">            levelInt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey];</span><br><span class="line">        if (moduleName) &#123;</span><br><span class="line">            [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey];</span><br><span class="line">        &#125;</span><br><span class="line">        [self.BHModuleInfos addObject:moduleInfo];</span><br><span class="line">        </span><br><span class="line">        /** 初始化module实例 */</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance = [[class alloc] init];</span><br><span class="line">        [self.BHModules addObject:moduleInstance];</span><br><span class="line">        [moduleInfo setObject:@(YES) forKey:kModuleInfoHasInstantiatedKey];</span><br><span class="line"></span><br><span class="line">        /** 将module按照优先级排序 */</span><br><span class="line">        [self.BHModules sortUsingComparator:^NSComparisonResult(id&lt;BHModuleProtocol&gt; moduleInstance1, id&lt;BHModuleProtocol&gt; moduleInstance2) &#123;</span><br><span class="line">            NSNumber *module1Level = @(BHModuleNormal);</span><br><span class="line">            NSNumber *module2Level = @(BHModuleNormal);</span><br><span class="line">            if ([moduleInstance1 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module1Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if ([moduleInstance2 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module2Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">                return module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSInteger module1Priority = 0;</span><br><span class="line">                NSInteger module2Priority = 0;</span><br><span class="line">                if ([moduleInstance1 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module1Priority = [moduleInstance1 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                if ([moduleInstance2 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module2Priority = [moduleInstance2 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                return module1Priority &lt; module2Priority;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        /** 给module注册事件 */</span><br><span class="line">        [self registerEventsByModuleInstance:moduleInstance];</span><br><span class="line">        </span><br><span class="line">        if (shouldTriggerInitEvent) &#123;</span><br><span class="line">            [self handleModuleEvent:BHMSetupEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            [self handleModulesInitEventForTarget:moduleInstance withCustomParam:nil];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [self handleModuleEvent:BHMSplashEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有需要注册的Module必须遵循<em>BHModuleProtocol</em>协议，否则不会被存储。</p><h2 id="读取本地plist方式注册">读取本地Plist方式注册</h2><p>首先需要设置本地Plist文件的读取路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br></pre></td></tr></table></figure><p>BeeHive的所有配置都可以通过BHContext进行传递。</p><p>Plist文件的字段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">     &lt;key&gt;URLGlobalScheme&lt;/key&gt;</span><br><span class="line">     &lt;string&gt;com.alibaba.beehive&lt;/string&gt;</span><br><span class="line">     &lt;key&gt;moduleClasses&lt;/key&gt;</span><br><span class="line">     &lt;array&gt;</span><br><span class="line">         &lt;dict&gt;</span><br><span class="line">             &lt;key&gt;moduleClass&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;HomeModule&lt;/string&gt;</span><br><span class="line">             &lt;key&gt;moduleLevel&lt;/key&gt;</span><br><span class="line">             &lt;integer&gt;1&lt;/integer&gt;</span><br><span class="line">             &lt;key&gt;modulePriority&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;600&lt;/string&gt;</span><br><span class="line">         &lt;/dict&gt;</span><br><span class="line">         &lt;dict&gt;</span><br><span class="line">             &lt;key&gt;moduleClass&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;TMTradeAdapter&lt;/string&gt;</span><br><span class="line">             &lt;key&gt;moduleLevel&lt;/key&gt;</span><br><span class="line">             &lt;integer&gt;1&lt;/integer&gt;</span><br><span class="line">             &lt;key&gt;modulePriority&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;599&lt;/string&gt;</span><br><span class="line">         &lt;/dict&gt;</span><br><span class="line">     &lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p>在AppDelegate中<code>[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</code>设置BHContext时就会注册plist中的module。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy;</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Plist中的module加入到<em>BHModuleInfos</em>中。</p><h2 id="load方法注册">Load方法注册</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// BeeHive</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BHModuleManager</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Load方法最终是调用BHModuleManager中的<code>registerDynamicModule:</code>方法来处理，该方法已在上一节中说明。</p><p>+load的方式可以使用<em>BH_EXPORT_MODULE</em>宏来替代完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure><p>在<em>BH_EXPORT_MODULE</em>宏中传入了参数<em>isAsync</em>，代表是否异步加载Module模块。如果是YES，则表示需要异步加载，NO则表示同步加载。</p><p>回过头来看看AppDelegate中setContext方法中的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate</span><br><span class="line">[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line"></span><br><span class="line">// BeeHive</span><br><span class="line">-(void)setContext:(BHContext *)context &#123;</span><br><span class="line">    _context = context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)loadStaticModules &#123;</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下registedAllModules方法 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)registedAllModules &#123;</span><br><span class="line">    /** 按照优先级从大到小顺序排列 */</span><br><span class="line">    [self.BHModuleInfos sortUsingComparator:^NSComparisonResult(NSDictionary *module1, NSDictionary *module2) &#123;</span><br><span class="line">        NSNumber *module1Level = (NSNumber *)[module1 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        NSNumber *module2Level =  (NSNumber *)[module2 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        if (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">            return module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSNumber *module1Priority = (NSNumber *)[module1 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            NSNumber *module2Priority = (NSNumber *)[module2 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            return module1Priority.integerValue &lt; module2Priority.integerValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *tmpArray = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    //module init：初始化所有的module</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary *module, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *classStr = [module objectForKey:kModuleInfoNameKey];</span><br><span class="line">        </span><br><span class="line">        Class moduleClass = NSClassFromString(classStr);</span><br><span class="line">        BOOL hasInstantiated = ((NSNumber *)[module objectForKey:kModuleInfoHasInstantiatedKey]).boolValue;</span><br><span class="line">        if (NSStringFromClass(moduleClass) &amp;&amp; !hasInstantiated) &#123;</span><br><span class="line">            id&lt;BHModuleProtocol&gt; moduleInstance = [[moduleClass alloc] init];</span><br><span class="line">            [tmpArray addObject:moduleInstance];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">//    [self.BHModules removeAllObjects];</span><br><span class="line">    [self.BHModules addObjectsFromArray:tmpArray];</span><br><span class="line">    //给module对象注册系统事件</span><br><span class="line">    [self registerAllSystemEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经历registedAllModules方法之后，所有注册的module都生成了对应的实例对象。</p><p>注意：</p><ol type="1"><li>所有的Module的对象都要是遵守<em>BHModuleProtocol</em>协议的。</li><li>Module不能在任何其他地方alloc创建出来，即使创建一个新的Module实例出来，它也并不在BHModuleManager的管理下，无法接收BHModuleManager分发的系统事件。</li></ol><h1 id="beehive模块间调用">BeeHive模块间调用</h1><p>通过处理Event编写各个业务模块可以实现插件化编程，各业务模块之间没有任何依赖，core与module之间通过event交互，实现了插件隔离。但有时候我们需要模块间的相互调用某些功能来协同完成功能。目前模块间的调用使用基于接口的实现Service访问方式（Javaspring框架实现）。基于接口Service访问的优点是可以编译时检查发现接口的变更，从而及时修正接口问题。缺点是需要依赖接口定义的头文件，通过模块增加得越多，维护接口定义的也有一定工作量。</p><p>模块间调用的协议都是通过BHServiceManager来维护的。</p><p>BeeHive提供了三种方式来注册协议，这里和module的注册方式相同：Annotation方式注册、读取本地plist方式注册、API注册。</p><h2 id="annotation方式注册-1">Annotation方式注册</h2><p>使用<code>@BeeHiveService</code>进行Annotation标记。BeeHiveService的宏定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))</span><br></pre></td></tr></table></figure><p>在示例中，<code>@BeeHiveService(HomeServiceProtocol,BHViewController)</code>在预编译结束后会完全展开成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot;&quot;))) = &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;”;</span><br></pre></td></tr></table></figure><p>这里类比注册module时的Annotation解析，也是把数据存在特殊的段内，具体的原理可以参考注册module的分析。</p><p>同理，通过调用函数<code>BHReadConfiguration</code>读取之前注册到特殊段<em>BeehiveServices</em>中的数据，这里是如下所示的json字符串，<em>{协议字符串:实现该协议的class类名字符串}</em>，如下所示:</p><p><code>&#123;"HomeServiceProtocol":"BHViewController”&#125;</code></p><p>读取到数据后，进行service的注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    //register module</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    //register services</span><br><span class="line">    NSArray&lt;NSString *&gt; *services = BHReadConfiguration(BeehiveServiceSectName,mhp);</span><br><span class="line">    for (NSString *map in services) &#123;</span><br><span class="line">        NSData *jsonData =  [map dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        id json = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [json allKeys].count) &#123;</span><br><span class="line">                </span><br><span class="line">                NSString *protocol = [json allKeys][0];</span><br><span class="line">                NSString *clsName  = [json allValues][0];</span><br><span class="line">                </span><br><span class="line">                if (protocol &amp;&amp; clsName) &#123;</span><br><span class="line">                    [[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)registerService:(Protocol *)service implClass:(Class)implClass</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(service != nil);</span><br><span class="line">    NSParameterAssert(implClass != nil);</span><br><span class="line">    </span><br><span class="line">    if (![implClass conformsToProtocol:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //协议是否已经注册</span><br><span class="line">    if ([self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *key = NSStringFromProtocol(service);</span><br><span class="line">    NSString *value = NSStringFromClass(implClass);</span><br><span class="line">    </span><br><span class="line">    if (key.length &gt; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        [self.lock lock];</span><br><span class="line">        [self.allServicesDict addEntriesFromDictionary:@&#123;key:value&#125;];</span><br><span class="line">        [self.lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注册协议前会有两个检查<code>registerService:implClass:</code>:</p><ul><li>检查implClass是否遵循了service</li><li>检查service协议是否已经注册</li></ul><p>如果两个条件有一个没有检查通过，则会抛出异常。</p><p>如果条件通过，则会在<em>allServicesDict</em>中加入键值对，<em>{NSStringFromProtocol(service):NSStringFromClass(implClass)}</em></p><h2 id="读取本地plist方式注册-1">读取本地Plist方式注册</h2><p>读取本地的plist文件之前，需要先设置plist文件路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AppDelegate.m</span><br><span class="line">[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService”;</span><br></pre></td></tr></table></figure><p>BeeHive的配置都可以通过BHContext进行传递。</p><p>plist中的数据格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;service&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UserTrackServiceProtocol&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;impl&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;BHUserTrackViewController&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p>注册plist中service的时机同注册plist管理的module类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br><span class="line">    </span><br><span class="line">    [BeeHive shareInstance].enableException = YES;</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];</span><br><span class="line">    </span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BeeHive.m</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context = context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException = self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册service的具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName = [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    </span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey = [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass = [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册完成之后，<em>allServicesDict</em>中的值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;@&quot;HomeServiceProtocol&quot; : @&quot;BHViewController&quot;, @&quot;UserTrackServiceProtocol&quot; : @&quot;BHUserTrackViewController&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@"plist”];</code>这段代码，如果主工程Podfile中未使用了<code>use_frameworks!</code>，则可以正常获取到plist，如果使用了<code>use_frameworks!</code>，则得使用其他方式获取，具体的方案请google。</p><h2 id="api注册">API注册</h2><p>API注册service使用的api是BeeHive的接口<code>- (void)registerService:(Protocol *)proto service:(Class)serviceClass</code>,该接口内部实现也是调用<code>BHServiceManager</code>的<code>registerService:implClass:</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// BeeHive.m</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class)serviceClass &#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：<code>[[BeeHive shareInstance] registerService:@protocol(TradeServiceProtocol) service:[BHTradeViewController class]];</code>,该代码可以放置在module的<code>modInit:</code>方法内部或者<code>modSetup:</code>方法内部，具体可以查看使用文档或者demo。</p><p>注意：<em>BHMSetupEvent</em>和<em>BHMInitEvent</em>事件都会在项目的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>函数内部触发。</p><p>BHServiceManager中的<em>allServicesDict</em>包含了所有方式注册的service。</p><p>与module注册相比，service的注册没有对实现协议的对象进行初始化。只是将协议和实现协议的对象之间的这种关联关系存储和维护，而在module的注册过程中，对所有注册的module进行实例的初始化。</p><p>因此，在BHServiceManager的公共接口中，有一组<code>createService:</code>接口用于访问实现协议的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName = NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance = nil;</span><br><span class="line">    </span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr = serviceName;</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class implClass = [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                implInstance = [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                implInstance = [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的实现中可以看出：</p><ul><li>service对象存在单例和多实例的区别。</li><li>如果<em>BHServiceProtocol</em>协议对象实现了<code>singleton</code>返回YES，且<em>shouldCache</em>入参值是YES，则通过<code>createService:</code>获取的对象为单例对象，如果<code>singleton</code>方法返回的是NO，则每次调用<code>createService:</code>都会创建一个新的对象。</li><li>这里的单例存在线程安全问题。如果开发者将<em>BHServiceProtocol</em>协议对象实现了<code>singleton</code>返回YES，且<code>shareInstance</code>方法的实现是返回单例对象，则不管<em>shouldCache</em>的入参值是YES还是NO，<code>createService:</code>都会是同一个实例。但是，如果开发者将<code>shareInstance</code>方法的实现只是返回对象(非单例)，即使<code>singleton</code>返回YES，<em>shouldCache</em>入参值是YES，也可能存在多个实例的情况。</li></ul><h1 id="上下文环境context">上下文环境Context</h1><p>BeeHive中使用BHContext初始化设置应用的项目信息，并在各模块间共享整个应用程序的信息。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [BHContext shareInstance].env ＝ BHEnvironmentDev; //定义应用的运行开发环境</span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/CustomModulePlist&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName =  @&quot;BeeHive.bundle/CustomServicePlist&quot;;//可选，默认为BeeHive.bundle/BHService.plist</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line"></span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BHContext.h</span><br><span class="line"></span><br><span class="line">@interface BHContext : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">//global env</span><br><span class="line">@property(nonatomic, assign) BHEnvironmentType env;</span><br><span class="line"></span><br><span class="line">//global config</span><br><span class="line">@property(nonatomic, strong) BHConfig *config;</span><br><span class="line"></span><br><span class="line">//application appkey</span><br><span class="line">@property(nonatomic, strong) NSString *appkey;</span><br><span class="line">//customEvent&gt;=1000</span><br><span class="line">@property(nonatomic, assign) NSInteger customEvent;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) UIApplication *application;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSDictionary *launchOptions;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *moduleConfigName;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *serviceConfigName;</span><br><span class="line"></span><br><span class="line">//3D-Touch model</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400</span><br><span class="line">@property (nonatomic, strong) BHShortcutItem *touchShortcutItem;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//OpenURL model</span><br><span class="line">@property (nonatomic, strong) BHOpenURLItem *openURLItem;</span><br><span class="line"></span><br><span class="line">//Notifications Remote or Local</span><br><span class="line">@property (nonatomic, strong) BHNotificationsItem *notificationsItem;</span><br><span class="line"></span><br><span class="line">//user Activity Model</span><br><span class="line">@property (nonatomic, strong) BHUserActivityItem *userActivityItem;</span><br><span class="line"></span><br><span class="line">//watch Model</span><br><span class="line">@property (nonatomic, strong) BHWatchItem *watchItem;</span><br><span class="line"></span><br><span class="line">//custom param</span><br><span class="line">@property (nonatomic, copy) NSDictionary *customParam;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>应用的运行开发环境</li><li>应用启动信息：application，launchOptions</li><li>module和service的plist配置信息</li><li>缓存的service</li><li>3D-Touch, OpenURL moduel, Remote Or Local Notifications, UserActivity Model等</li></ul><p>最后，附一张BeeHive主要类的的类图关系。</p><!--![BeeHive类图](/img/beehive-analysis/beehive-class.png)--><div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-class.png" alt="BeeHive类图"><span class="caption">BeeHive类图</span></div><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是基于BeeHive版本1.6.0进行分析。&lt;/p&gt;
&lt;p&gt;BeeHive核心思想涉及两个部分：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。&lt;/li&gt;
&lt;li&gt;App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计模式" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS策略设计模式实践</title>
    <link href="http://liumh.com/2018/09/18/design-pattern-strategy/"/>
    <id>http://liumh.com/2018/09/18/design-pattern-strategy/</id>
    <published>2018-09-18T14:51:41.000Z</published>
    <updated>2024-10-21T14:20:53.208Z</updated>
    
    <content type="html"><![CDATA[<p>情景：把一堆算法塞到同一段代码中，然后使用<code>if-else</code>或者<code>switch-case</code>条件语句来决定要使用哪个算法？这些算法可能是一堆相似的类函数或方法，用以解决相关的问题。例如验证数据输入的情形，数据本身可以是任何数据类型(如CGFloat，NSString，NSInteger等)，每种数据类型需要不同的算法。如果把每一种算法封装成一个对象，那么就能消除根据数据类型决定使用什么算法的一堆<code>if-else</code>或<code>switch-case</code>语句。面向对象软件设计中，我们可以把相关算法分离为不同的类，成为策略，对应的设计模式称为策略模式。</p><span id="more"></span><h1 id="何为策略模式">何为策略模式</h1><p>策略模式的使用可以粗暴的分为3个角色。</p><ol type="1"><li>策略类，或者定义为策略接口、策略协议，它为所有支持的或相关的算法声明了一个共同接口。</li><li>策略对象：它会实现策略协议，策略对象通常存在多个，分别封装实现具体的算法。</li><li>场景(context)类对象：配置有一个具体策略对象的示例，场景对象使用策略接口调用由具体策略类定义的算法。</li></ol><p>它们的静态关系如下图所示：</p><!--![](http://readus-org.qiniudn.com/img/design/overview-strategy-pattern.png)--><div class="figure center" style="width:622;"><img class="fig-img" src="/img/design-pattern-strategy/overview-strategy-pattern.png" style="width:622;height:303;"alt="策略模式类图静态关系"><span class="caption">策略模式类图静态关系</span></div><p>一组算法，或者说算法的一个层次结构，以ConcreteStrategy(A、B和C)类的形式，共享相同的AlgorithmInterface接口，这样Context就能使用相同的接口访问算法的各种变体。</p><p>Context的实例可以在运行时用不同的ConcreteStrategy对象进行配置，这可以理解成更换context对象的『内容』，因为变更是发生在对象的内部。</p><h1 id="何时使用策略模式">何时使用策略模式</h1><p>在以下情形，考虑使用策略模式。</p><ul><li>一个类在其操作中使用多个条件语句来定义许多行为，我们可以把相关的条件分支移动到它们自己的策略类中。</li><li>需要算法的各种变体。</li><li>需要避免把复杂的、与算法相关的数据结构暴露给客户端。</li></ul><h1 id="在uitextfield中应用策略模式">在UITextField中应用策略模式</h1><p>类图设计如下图所示：</p><!--![](http://readus-org.qiniudn.com/img/design/inputvalidator-strategy-pattern.png)--><div class="figure center" style="width:611;"><img class="fig-img" src="/img/design-pattern-strategy/inputvalidator-strategy-pattern.png" style="width:611;height:176;"alt="策略模式在输入验证中的应用"><span class="caption">策略模式在输入验证中的应用</span></div><h2 id="策略接口">策略接口</h2><p>这里策略类抽象了两个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@protocol ACITextFieldInputValidator &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateInput:(UITextField *)textField</span><br><span class="line">    charactersInRange:(NSRange)range</span><br><span class="line">    replacementString:(NSString *)string</span><br><span class="line">                error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingInput:(UITextField *)textField error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateInput:(UITextField *)textField</span><br><span class="line">    charactersInRange:(NSRange)range</span><br><span class="line">    replacementString:(NSString *)string</span><br><span class="line">                error:(NSError **)error;</span><br></pre></td></tr></table></figure><p>在UITextFieldDelegate的<code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</code>方法中进行验证。</p><p><code>- (BOOL)validateEndEditingInput:(UITextField *)textField error:(NSError **)error;</code>在UITextFieldDelegate的<code>- (void)textFieldDidEndEditing:(UITextField *)textField</code>方法中进行验证。</p><p>这里特殊说明一下：</p><p>接口中使用UITextField作为入参而不是使用NSString作为入参，是因为如果只用NSString值，那么策略对象中的动作就是单向的。就是说，验证器只能检查，然后返回结果，而不能修改原始值。而使用UITextField型的输入参数，就可以两全其美。验证器可以选择修改文本框的原始值(比如删除无效的值),或者只检查而不修改。</p><p>另一个问题是，如果输入值错误，为什么不引发一个NSException异常呢？这是因为在CocoaTouch框架中，引发自己的异常然后再用<code>try-catch</code>语句块来捕捉，这非常耗资源，所以不推荐，返回NSError对象的开销相对较小。</p><h2 id="场景">场景</h2><p>这里使用策略的场景是UITextField，在UITextField的子类InputValidateTextField中，声明一个遵循策略协议的对象属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface ACIInputValidateTextField : UITextField</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) id&lt;ACITextFieldInputValidator&gt; inputValidator;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateCharactersInRange:(NSRange)range</span><br><span class="line">                replacementString:(NSString *)string</span><br><span class="line">                            error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingWithError:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>同时，场景对象中会声明方法来处理调用策略对象的接口方法。具体示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@implementation ACIInputValidateTextField</span><br><span class="line"></span><br><span class="line">- (BOOL)validateCharactersInRange:(NSRange)range</span><br><span class="line">                replacementString:(NSString *)string</span><br><span class="line">                            error:(NSError **)error &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL shouldChange = [self.inputValidator validateInput:self charactersInRange:range replacementString:string error:error];</span><br><span class="line">    return shouldChange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingWithError:(NSError **)error &#123;</span><br><span class="line">    BOOL isValid = [self.inputValidator validateEndEditingInput:self error:error];</span><br><span class="line">    return isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="策略对象">策略对象</h2><p>策略对象，这里是遵循了策略协议的<code>TextFieldInputValidator</code>的对象。每个对象会实现TextFieldInputValidator的方法，其中封装了具体的策略实现。</p><p>具体代码示例详见<ahref="https://github.com/carya/InputValidator">githubInputValidator</a></p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;情景：把一堆算法塞到同一段代码中，然后使用&lt;code&gt;if-else&lt;/code&gt;或者&lt;code&gt;switch-case&lt;/code&gt;条件语句来决定要使用哪个算法？这些算法可能是一堆相似的类函数或方法，用以解决相关的问题。例如验证数据输入的情形，数据本身可以是任何数据类型(如CGFloat，NSString，NSInteger等)，每种数据类型需要不同的算法。如果把每一种算法封装成一个对象，那么就能消除根据数据类型决定使用什么算法的一堆&lt;code&gt;if-else&lt;/code&gt;或&lt;code&gt;switch-case&lt;/code&gt;语句。
面向对象软件设计中，我们可以把相关算法分离为不同的类，成为策略，对应的设计模式称为策略模式。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计模式" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__</title>
    <link href="http://liumh.com/2018/08/18/ios-attribute-section/"/>
    <id>http://liumh.com/2018/08/18/ios-attribute-section/</id>
    <published>2018-08-18T14:43:39.000Z</published>
    <updated>2024-10-21T14:26:36.887Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code>是在C, C++,Objective-C语言中使用的编译指令，一般以<code>__attribute__(xxx)</code>的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如StaticAnalyzer、Name Mangling、Code Generation等过程。</p><span id="more"></span><!-- toc --><h1 id="attribute语法">Attribute语法</h1><p>关于Attribute的语法描述见官方文档<ahref="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">AttributeSyntax</a></p><blockquote><p>An attribute specifier is of the form<code>__attribute__ ((attribute-list))</code>. An attribute list is apossibly empty comma-separated sequence of attributes, where eachattribute is one of the following:</p><ul><li><p>Empty. Empty attributes are ignored.</p></li><li><p>An attribute name (which may be an identifier such as<em>unused</em>, or a reserved word such as <em>const</em>).</p></li><li><p>An attribute name followed by a parenthesized list of parametersfor the attribute. These parameters take one of the following forms:</p><ul><li>An identifier. For example, <em>mode</em> attributes use thisform.</li><li>An identifier followed by a comma and a non-empty comma-separatedlist of expressions. For example, <em>format</em> attributes use thisform.</li><li>A possibly empty comma-separated list of expressions. For example,<em>format_arg</em> attributes use this form with the list being asingle integer constant expression, and <em>alias</em> attributes usethis form with the list being a single string constant.</li></ul></li></ul></blockquote><h1 id="used">used</h1><p><em>used</em>的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。具体的描述可以看<ahref="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes">gun的官方文档</a>。</p><blockquote><p><em>used</em></p><p>This attribute, attached to a variable with static storage, meansthat the variable must be emitted even if it appears that the variableis not referenced.</p><p>When applied to a static data member of a C++ class template, theattribute also means that the member is instantiated if the class itselfis instantiated.</p></blockquote><h1 id="section">section</h1><p>通常情况下，编译器会将对象放置于DATA段的<em>data</em>或者<em>bss</em>节中。但是，有时我们需要将数据放置于特殊的节中，此时<em>section</em>可以达到目的。例如，BeeHive中就把module注册数据存在__DATA数据段里面的"BeehiveMods"section中。</p><p><em>section</em>通常用于修饰全局变量。以下是gnu官网对<em>section</em>属性的说明。</p><blockquote><p><em>section ("section-name")</em></p><p>Normally, the compiler places the objects it generates in sectionslike <em>data</em> and <em>bss</em>. Sometimes, however, you needadditional sections, or you need certain particular variables to appearin special sections, for example to map to special hardware. The<em>section</em> attribute specifies that a variable (or function) livesin a particular section. For example, this small program uses severalspecific section names:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;</span><br><span class="line">struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;</span><br><span class="line">char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;</span><br><span class="line">int init_data __attribute__ ((section (&quot;INITDATA&quot;)));</span><br><span class="line">main() &#123;</span><br><span class="line">  /* Initialize stack pointer */</span><br><span class="line">  init_sp (stack + sizeof (stack));</span><br><span class="line">  /* Initialize initialized data */</span><br><span class="line">  memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</span><br><span class="line">  /* Turn on the serial ports */</span><br><span class="line">  init_duart (&amp;a);</span><br><span class="line">  init_duart (&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Use the <em>section</em> attribute with <em>global</em> variables andnot <em>local</em> variables, as shown in the example.</p><p>You may use the <em>section</em> attribute with initialized oruninitialized global variables but the linker requires each object bedefined once, with the exception that uninitialized variablestentatively go in the <em>common</em> (or <em>bss</em>) section and canbe multiply “defined”. Using the <em>section</em> attribute changes whatsection the variable goes into and may cause the linker to issue anerror if an uninitialized variable has multiple definitions. You canforce a variable to be initialized with the <em>-fno-common</em> flag orthe <em>nocommon</em> attribute.</p><p>Some file formats do not support arbitrary sections so the<em>section</em> attribute is not available on all platforms. If youneed to map the entire contents of a module to a particular section,consider using the facilities of the linker instead.</p></blockquote><p><code>__attribute__</code>的更多使用示例可参考<ahref="https://github.com/facebook/Tweaks">FBTweak</a></p><blockquote><p>编译器提供了我们一种<code>__attribute__((section("xxx段，xxx节")</code>的方式让我们将一个指定的数据储存到我们需要的节当中。</p></blockquote><p>在<ahref="https://github.com/alibaba/BeeHive">BeeHive框架</a>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>通过使用<code>__attribute__((section("name")))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段。</p><p>编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)格式主要是</p><ul><li>Windows下的PE(Portable Executable)</li><li>Linux的ELF(Executable Linkable Format)</li><li>macOS/iOS系统上的Mach-O（Mach Object File Format）</li></ul><p>程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，<em>data</em>和<em>.bss</em>节属于数据段。</p><!--![Mach-O内存布局](/img/ios-attribute-section/Mach-O.png)--><div class="figure center" style="width:431;"><img class="fig-img" src="/img/ios-attribute-section/Mach-O.png" style="width:431;height:496;"alt="Mach-O内存布局"><span class="caption">Mach-O内存布局</span></div><p>Mach-O的组成结构如上图所示包括了Header、Loadcommands、Data（包含Segement的具体数据），我们平时了解到的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。</p><blockquote><p>一个现代<ahref="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>的主要工作流程如下：</p><p>源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→汇编程序（assembler）→ 目标代码（object code）→ 链接器（Linker）→可执行文件（executables），最后打包好的文件就可以给计算机去判读运行了。</p></blockquote><p>编译后各个section存储的内容如下：</p><table><colgroup><col style="width: 26%" /><col style="width: 73%" /></colgroup><thead><tr><th>Segment and Section Name</th><th>Contents</th></tr></thead><tbody><tr><td>__TEXT,__text</td><td>Executable machine code. The compiler places only executable code inthis section; no tables or data of any sort are stored here.</td></tr><tr><td>__TEXT,__cstring</td><td>Constant C strings. A C string is a sequence of non-null bytes thatends with a null byte (‘\0’). The static linker coalesces constant Cstring values, removing duplicates, when building the finalproduct.</td></tr><tr><td>__TEXT,__picsymbol_stub</td><td>Position -independent indirect symbol stubs. See “IndirectAddressing” for more information.</td></tr><tr><td>__TEXT,__symbol_stub</td><td>Indirect symbol stubs. See “Indirect Addressing” for moreinformation.</td></tr><tr><td>__TEXT,__const</td><td>Initialized constant variables. The compiler places all datadeclared const in this section.</td></tr><tr><td>__TEXT,__literal4</td><td>4-byte literal values. The compiler places single-precision floatingpoint constants in this section. The static linker coalesces thesevalues, removing duplicates, when building the final product. With someCPU architectures, it is more efficient for the compiler to useimmediate load instructions rather than adding to this section.</td></tr><tr><td>__TEXT,__literal8</td><td>8-byte literal values. The compiler places double-precision floatingpoint constants in this section. The static linker coalesces thesevalues, removing duplicates, when building the final product. With someCPU architectures, it is more efficient for the compiler to useimmediate load instructions rather than adding to this section.</td></tr><tr><td>__DATA,__data</td><td>Initialized mutable variables, such as writable C strings and dataarrays.</td></tr><tr><td>__DATA,__la_symbol_ptr</td><td>Lazy symbol pointers, which are indirect references to functionsimported from a different file. See “Indirect Addressing” for moreinformation.</td></tr><tr><td>__DATA,__nl_symbol_ptr</td><td>Non-lazy symbol pointers, which are indirect references to dataitems imported from a different file. See “Indirect Addressing” for moreinformation.</td></tr><tr><td>__DATA,__dyld</td><td>Information used by the static linker.</td></tr><tr><td>__DATA,__const</td><td>Unintialized constant variables.</td></tr><tr><td>__DATA,__mod_init_func</td><td>Module initialization functions. The C++ compiler places staticconstructors here.</td></tr><tr><td>__DATA,__mod_term_func</td><td>Module termination functions.</td></tr><tr><td>__DATA,__bss</td><td>Data for uninitialized static variables (for example, static inti;).</td></tr><tr><td>__DATA,__common</td><td>Uninitialized imported symbol definitions (for example, int i;)located in the global scope (outside of a function declaration).</td></tr></tbody></table><p>从上面的表格可以看出：</p><ul><li>__TEXT,__text：可执行的机器码(代码段)</li><li>__TEXT,__const：已初始化的常量，编译器会将所有声明为const的数据放置在该section；</li><li>__DATA,__data：已初始化的可变全局变量；</li><li>__DATA,__bss：未初始化的全局静态变量和局部静态变量，例如<code>static int i;</code></li><li>__DATA,__common：未初始化的全局变量；</li></ul><p>全局变量是放在全局内存中的，用static修饰的局部变量也是会放在放全局内存的，它的作用域是局部的，但生命期是全局的。</p><p>全局强调的是它的生命期，而不是它的作用域，所以有时可能把两者的概念互换。一般来说，在一起定义的两个全局变量，在内存的中位置是相邻的。这是一个简单的常识，但有时挺有用，如果一个全局变量被破坏了，不防先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p><h1 id="constructor">constructor</h1><p>上一节只是讲到如何将数据存入特殊的section中，那么如何把存入的数据读取出来呢？</p><p>这里先介绍一下<code>__attribute__((constructor))</code>。</p><p><em>constructor</em>：顾名思义，构造器加上这个属性的函数会在可执行文件（或shared library）load时被调用，可以理解为在 main() 函数调用前执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;main&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;</span><br></pre></td></tr></table></figure><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载image（可以理解成 Mach-O 文件）时会先通知 objc runtime去加载其中所有的类，每加载一个类时，它的 +load随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor方法。所以 constructor 是一个干坏事的绝佳时机：</p><ol type="1"><li>所有Class都已经加载完成</li><li>main 函数还未执行</li><li>无需像 +load 还得挂载在一个Class中</li></ol><h1 id="读取section中的值">读取section中的值</h1><p>现在来了解如何将存储在特殊section中的数据读出。</p><p>在BeeHive源码中有下面一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls = NSClassFromString(modName);</span><br><span class="line">            </span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>void initProphet()</code>使用了<code>__attribute__((constructor))</code>修饰，其执行时机已在上一节提到。该函数的实现体里使用了<code>_dyld_register_func_for_add_image</code>函数，现在看看该函数的作用。</p><p><code>_dyld_register_func_for_add_image</code>:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following functions allow you to install callbacks which will be called   </span><br><span class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line"> * and before the image is un-memory-mapped.</span><br><span class="line"> */</span><br><span class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) </span><br><span class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))</span><br></pre></td></tr></table></figure><p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调<code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的mach_header以及一个虚拟内存地址intptr_t。</p><p>mach_header是定义在<code>usr/include/mach-o/loader.h</code>中的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">     uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">     cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">     cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">     uint32_t    filetype;    /* type of file */</span><br><span class="line">     uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">     uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">     uint32_t    flags;        /* flags */</span><br><span class="line">     uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过调用<em>BHReadConfiguration</em>函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p><p>参考：</p><ul><li><ahref="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">ClangAttributes 黑魔法小记</a></li><li><ahref="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">AttributeSyntax</a></li><li><ahref="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html#//apple_ref/doc/uid/20001860-BAJGJEJC">Overviewof the Mach-O Executable Format</a></li><li><a href="https://lowlevelbits.org/parsing-mach-o-files/">PARSINGMACH-O FILES</a></li></ul><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt;是在C, C++,
Objective-C语言中使用的编译指令，一般以&lt;code&gt;__attribute__(xxx)&lt;/code&gt;的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static
Analyzer、Name Mangling、Code Generation等过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UICollectionViewLayoutAttributes初探</title>
    <link href="http://liumh.com/2017/12/29/ios-uicollectionviewlayoutattributes/"/>
    <id>http://liumh.com/2017/12/29/ios-uicollectionviewlayoutattributes/</id>
    <published>2017-12-29T14:51:09.000Z</published>
    <updated>2024-10-21T14:46:16.499Z</updated>
    
    <content type="html"><![CDATA[<p>UICollectionViewLayoutAttributes是UICollectionView的重要组成部分，本文从其基本定义、如何使用以及使用场景几方面来简单介绍。文末以自定义UICollectionView各个Section的背景色的示例来展示UICollectionViewLayoutAttributes的应用。</p><span id="more"></span><h1id="uicollectionviewlayoutattributes概览">UICollectionViewLayoutAttributes概览</h1><p>UICollectionViewLayoutAttributes的官方解释：</p><blockquote><p>A layout object that manages the layout-related attributes for agiven item in a collection view.Layout objects create instances of thisclass when asked to do so by the collection view. In turn, thecollection view uses the layout information to position cells andsupplementary views inside its bounds.</p></blockquote><p>UICollectionViewLayoutAttributes是管理collectionview中指定元素的布局属性的对象。collectionview使用该对象中的布局属性来控制cells和supplementaryviews的显示位置。</p><p>下面是UICollectionViewLayoutAttributes类的定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewLayoutAttributes : NSObject &lt;NSCopying, UIDynamicItem&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic) CGRect frame;</span><br><span class="line">@property (nonatomic) CGPoint center;</span><br><span class="line">@property (nonatomic) CGSize size;</span><br><span class="line">@property (nonatomic) CATransform3D transform3D;</span><br><span class="line">@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);</span><br><span class="line">@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);</span><br><span class="line">@property (nonatomic) CGFloat alpha;</span><br><span class="line">@property (nonatomic) NSInteger zIndex; // default is 0</span><br><span class="line">@property (nonatomic, getter=isHidden) BOOL hidden; // As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES</span><br><span class="line">@property (nonatomic, strong) NSIndexPath *indexPath;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;</span><br><span class="line">@property (nonatomic, readonly, nullable) NSString *representedElementKind; // nil when representedElementCategory is UICollectionElementCategoryCell</span><br><span class="line"></span><br><span class="line">+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中UICollectionElementCategory的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, UICollectionElementCategory) &#123;</span><br><span class="line">    UICollectionElementCategoryCell,</span><br><span class="line">    UICollectionElementCategorySupplementaryView,</span><br><span class="line">    UICollectionElementCategoryDecorationView</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Because layout attribute objects may be copied by the collectionview, it conforms to the <code>NSCopying</code> protocol. It is veryimportant that we also conform to this protocol and implement<code>copyWithZone:</code>. Otherwise, our property will always be zero(as guaranteed by the compiler).</p></blockquote><p>由于layout attributes对象可能会被collection view复制，因此layoutattributes对象应该遵循<code>NSCoping</code>协议，并实现<code>copyWithZone:</code>方法，否则我们获取的自定义属性会一直是空值。</p><blockquote><p>If you subclass and implement any custom layout attributes, you mustalso override the inherited <code>isEqual:</code> method to compare thevalues of your properties. In iOS 7 and later, the collection view doesnot apply layout attributes if those attributes have not changed. Itdetermines whether the attributes have changed by comparing the old andnew attribute objects using the <code>isEqual:</code> method. Becausethe default implementation of this method checks only the existingproperties of this class, you must implement your own version of themethod to compare any additional properties. If your custom propertiesare all equal, call super and return the resulting value at the end ofyour implementation.</p></blockquote><p>如果继承了UICollectionViewLayoutAttributes并且添加了任何自定义的layoutattributes，也必须实现<code>isEqual:</code>方法来比较自定义属性。在iOS7(包括iOS7)以后，如果UICollectionViewLayoutAttributes的属性值没有改变，collection view不会应用layout attributes，这些layoutattributes的是否改变由<code>isEqual:</code>的返回值来决定。在重写<code>isEqual:</code>时，除了需要处理自定义属性外，还需要注意父类方法的调用。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** subclass must conforms to the NSCopying protocol */</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    </span><br><span class="line">    CLSectionColorLayoutAttributes *layoutAttributes = [super copyWithZone:zone];</span><br><span class="line">    layoutAttributes.sectionColor = self.sectionColor;</span><br><span class="line">    return layoutAttributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** In iOS 7 and later, the collection view does not apply layout attributes if</span><br><span class="line"> those attributes have not changed. It determines whether the attributes have changed</span><br><span class="line"> by comparing the old and new attribute objects using the isEqual: method. */</span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([object class] == [self class]) &#123;</span><br><span class="line">        return [super isEqual:object] &amp;&amp; (self.sectionColor == [object sectionColor]);</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="subclassing-notes">Subclassing Notes</h1><p>首先，在UICollectionViewLayoutAttributes的子类中重写<code>copyWithZone:</code>方法和<code>isEqual:</code>方法。其原因已在上一节讲到。</p><p>接下来需要告诉collectionview使用自定义的类而不是系统的UICollectionViewLayoutAttributes类，需要在自定义的CLCollectionViewFlowLayout中重写类方法<code>+(Class)layoutAttributesClass</code>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layoutAttributesClass &#123;</span><br><span class="line">    return [CLSectionColorLayoutAttributes class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了与系统的配置属性使用保持一致，我们可以在CLCollectionViewFlowLayout头文件中暴露自定义属性，以便对该属性的统一设置。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">@property (nonatomic, strong) UIColor *sectionColor;</span><br><span class="line"></span><br><span class="line">.m</span><br><span class="line">- (void)setSectionColor:(UIColor *)sectionColor &#123;</span><br><span class="line">    _sectionColor = sectionColor;</span><br><span class="line">    [self invalidateLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了达到与系统的<code>UICollectionViewDelegateFlowLayout</code>使用达到一致，可以支持自定义属性针对不同indexPath的设置，我们声明protocol以供业务层调用，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol CLCollectionViewDelegateFlowLayout &lt;UICollectionViewDelegateFlowLayout&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (UIColor *)collectionView:(UICollectionView *)collectionView</span><br><span class="line">                     layout:(UICollectionViewLayout *)collectionViewLayout</span><br><span class="line">     colorForSectionAtIndex:(NSInteger)section;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里需要注意，我们自定义的协议遵循了UICollectionViewDelegateFlowLayout协议,且无需在CLCollectionViewFlowLayout类中声明一个遵循该协议的delegate对象，该协议的使用与UICollectionViewDelegateFlowLayout一致。layout的实现文件中优先使用该协议返回的值，否则使用属性中传入的值。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIColor *)sectionColorAtSection:(NSInteger)section &#123;</span><br><span class="line">    UIColor *sectionColor = self.sectionColor;</span><br><span class="line">    //if implemented collectionView:layout:colorForSectionAtIndex: use the return value</span><br><span class="line">    if ([self.collectionView.delegate respondsToSelector:@selector(collectionView:layout:colorForSectionAtIndex:)]) &#123;</span><br><span class="line">        id&lt;CLCollectionViewDelegateFlowLayout&gt; temp = (id&lt;CLCollectionViewDelegateFlowLayout&gt;)self.collectionView.delegate;</span><br><span class="line">        sectionColor = [temp collectionView:self.collectionView layout:self colorForSectionAtIndex:section];</span><br><span class="line">    &#125;</span><br><span class="line">    return sectionColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sectionColorAtSection:</code>方法会在<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>中调用。</p><p>至此，自定义属性传递给了layout，但是是怎样应用到具体的Cell或者SupplementaryView上的呢？继承自UICollectionReusableView或者UICollectionViewCell的控制，包含如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Classes that want to support custom layout attributes specific to a given UICollectionViewLayout subclass can apply them here.</span><br><span class="line">// This allows the view to work in conjunction with a layout class that returns a custom subclass of UICollectionViewLayoutAttributes from -layoutAttributesForItem: or the corresponding layoutAttributesForHeader/Footer methods.</span><br><span class="line">// -applyLayoutAttributes: is then called after the view is added to the collection view and just before the view is returned from the reuse queue.</span><br><span class="line">// Note that -applyLayoutAttributes: is only called when attributes change, as defined by -isEqual:.</span><br><span class="line">- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes;</span><br></pre></td></tr></table></figure><p>例如如下的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes &#123;</span><br><span class="line">    [super applyLayoutAttributes:layoutAttributes];</span><br><span class="line">    if ([layoutAttributes isKindOfClass:[CLSectionColorLayoutAttributes class]]) &#123;</span><br><span class="line">        CLSectionColorLayoutAttributes *attributes = (CLSectionColorLayoutAttributes *)layoutAttributes;</span><br><span class="line">        self.backgroundColor = attributes.sectionColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This method belongs to UICollectionReusableView because layoutattributes are applicable to cells, supplementary views, and decorationviews. First, you must call super’s implementation. Next, it checks toensure that the layout attributes are an instance of our custom subclassbefore casting the pointer.</p></blockquote><p>注意：该方法声明在UICollectionReusableView类中，适用于cells、supplementaryview、decorationviews。首先你必须调用父类的实现，然后检查layoutAttributes是否自定义类的实例，来决定是否进行指针的强制转换。</p><h1id="自定义uicollectionview各个section的背景色">自定义UICollectionView各个Section的背景色</h1><p>前面讲解了UICollectionViewLayoutAttributes的基本使用，使用的示例代码是为了能够达到自定义UICollectionView的各个Section的背景色。你可能对这个需求有疑惑，在UICollectionView中，每个Section中可以定义sectionInset、minimumLineSpacing、minimumInteritemSpacing属性值，而这些属性值定义的空白区域的背景色是与UICollectionView的背景色保持一致，当我们的需求中需要定义与UICollectionView的背景色不一致时，或者各个Section定义的背景色也各有区别时，</p><p>为了达到此目的，方案是在各个section中添加decorationview，然后设置decoration view的颜色就是各个section的背景色，具体的代码见<ahref="https://github.com/carya/SectionBackgroundColor">github</a>中下载,如有错误之处，欢迎指正。</p><p>需要重点提出的是，如果你想在删除cell或者section的时候动态添加或者删除decorationview，你可能需要花点功夫来使cell的添加或者删除动画与decorationview的添加与删除动画保持同步。</p><blockquote><p>footerReferenceSize and headerReferenceSize During layout, only thesize that corresponds to the appropriate scrolling direction is used.For example, for the vertical scrolling direction, the layout objectuses the height value returned by your method. (In that instance, thewidth of the header would be set to the width of the collection view.)If the size in the appropriate scrolling dimension is 0, no header isadded.</p></blockquote><h1 id="使用场景">使用场景</h1><p>UICollectionViewLayoutAttributes使用场景，个人总结如下：1.与DataSource无关，但想控制UIReusableView或者UICollectionViewCell的显示属性，例如在ViewController中配置UIImageView的显示模式。2.UICollectionviewCell的某一属性需要跟随UICollectionViewLayout的改变而改变，例如CoverFlow类型的展示。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;UICollectionViewLayoutAttributes是UICollectionView的重要组成部分，本文从其基本定义、如何使用以及使用场景几方面来简单介绍。文末以自定义UICollectionView各个Section的背景色的示例来展示UICollectionViewLayoutAttributes的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="UICollectionViewLayoutAttributes" scheme="http://liumh.com/tags/UICollectionViewLayoutAttributes/"/>
    
    <category term="UICollectionView" scheme="http://liumh.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的系统转场</title>
    <link href="http://liumh.com/2016/11/09/ios-system-presentation/"/>
    <id>http://liumh.com/2016/11/09/ios-system-presentation/</id>
    <published>2016-11-09T01:03:06.000Z</published>
    <updated>2024-10-21T14:44:43.056Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录的是对下图所示的<em>Kind</em>, <em>Presentation</em>,<em>Transition</em>的理解：</p><div class="figure left" style="width:260;"><img class="fig-img" src="/img/system-presentation/system-presentation.png" style="width:260;height:250;"alt="iOS系统转场"><span class="caption">iOS系统转场</span></div><div style="clear:both;"></div><span id="more"></span><p>目录如下：</p><ol type="1"><li>Size Classes</li><li>Kind转场类型<ul><li>Show</li><li>Show Detail</li><li>Present Modally<ul><li>Presentation Styles</li><li>Transition Styles</li></ul></li><li>Presenting a View Controller in a Popover</li></ul></li></ol><h1 id="size-classes">Size Classes</h1><p>开始之前，先来了解一下<em>Size Classes</em>,从<em>iOS8.0</em>开始引入了<em>SizeClasses</em>的概念来对屏幕进行分类：把各个设备屏幕以及它们的屏幕旋转状态都抽象成屏幕Size的变化，下表是不同尺寸设备屏幕对<em>SizeClasses</em>的约定。</p><table><colgroup><col style="width: 35%" /><col style="width: 32%" /><col style="width: 32%" /></colgroup><thead><tr><th style="text-align: left;">Device</th><th style="text-align: left;">Portrait</th><th style="text-align: left;">Landscape</th></tr></thead><tbody><tr><td style="text-align: left;">iPad (all)</br>iPad Mini</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Regular</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Regular</td></tr><tr><td style="text-align: left;">iPhone 6 Plus</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Compact</td><td style="text-align: left;">Vertical size class:Compact</br>Horizontal size class: Regular</td></tr><tr><td style="text-align: left;">iPhone 6</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Compact</td><td style="text-align: left;">Vertical size class:Compact</br>Horizontal size class: Compact</td></tr><tr><td style="text-align: left;">iPhone 5s</br>iPhone 5c</br>iPhone 5</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Compact</td><td style="text-align: left;">Vertical size class:Compact</br>Horizontal size class: Compact</td></tr><tr><td style="text-align: left;">iPhone 4s</td><td style="text-align: left;">Vertical size class:Regular</br>Horizontal size class: Compact</td><td style="text-align: left;">Vertical size class:Compact</br>Horizontal size class: Compact</td></tr></tbody></table><p>宽（正常，任意， 紧凑），高（正常，任意， 紧凑），3 x 3 共 9 种Size，每种 Size都可以设置特定的一套布局，如果不特殊指定，默认是在（宽任意，高任意）模式下设置，且其他8 种布局继承它。对于Size Classes，可以看看博客: <ahref="http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/">iOS8 SizeClasses初探</a></p><h1 id="kind-转场类型">Kind-转场类型</h1><p>先说明一下两个名词，假如<em>view controller A</em>模态展示了<em>viewcontroller B</em>，则</p><ol type="1"><li><em>presenting view controller</em>, 是上述场景中的<em>A viewcontroller</em>, 它会负责展示另外一个<em>view controller</em>；</li><li><em>presented view controller</em>, 是上述场景中的<em>B viewcontroller</em>，它是由其它控制器展示出来的<em>viewcontroller</em>。</li></ol><p>转场<em>Kind</em>的设置选项，系统默认的类型有四种，<em>Show</em>,<em>Show Detail</em>, <em>Present Modally</em>, <em>Present AsPopover</em>。</p><div class="figure left" style="width:256;"><img class="fig-img" src="/img/system-presentation/system-presentation-kind.png" style="width:256;height:308;"alt="转场类型"><span class="caption">转场类型</span></div><div style="clear:both;"></div><h2 id="show">Show</h2><blockquote><p>Presents a view controller in a primary context.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func show(_ vc: UIViewController, sender: Any?)</span><br></pre></td></tr></table></figure></blockquote><p>使用该方法可以将<em>display view controller</em>从<em>presenting thatview controller onscreen</em>的过程中解耦，<em>ViewController</em>不需要知道它是嵌入到<em>UINavigationController</em>中或者是<em>UISplitViewController</em>中，都可以调用此方法来展示到屏幕上。<em>UISplitViewController</em>和<em>UINavigationController</em>重写了该方法，使其能够根据自身设计来处理展现过程。例如，<em>UINavigationController</em>重写了该方法，并使用该方法来<em>pushviewcontroller</em>到<em>navigation stack</em>中。</p><p>该方法的默认实现会调用<em>targetViewControllerForAction:sender:</em>在<em>viewcontroller</em>层级中找到重写该方法的对象，然后调用该对象的此方法，使其能够以适当的方式来展现<em>viewcontroller</em>。如果<em>targetViewControllerForAction:sender:</em>方法返回<em>nil</em>，此方法会使用<em>window</em>的<em>rootview controller</em>来模态显示<em>vc</em>。</p><p>你可以在自定义<em>viewcontroller</em>中重写该方法来展示<em>vc</em>，你的实现应该在<em>regular</em>和<em>compact</em>环境中做好适配。</p><p><ahref="https://developer.apple.com/reference/uikit/uiviewcontroller/1621377-showviewcontroller">官方文档</a></p><h2 id="show-detail">Show Detail</h2><blockquote><p>Presents a view controller in a secondary (or detail) context.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func showDetailViewController(_ vc: UIViewController, sender: Any?)</span><br></pre></td></tr></table></figure></blockquote><p>该方法特点同<em>Show</em>类似:使用该方法可以将<em>display viewcontroller</em>从<em>presenting that view controller onscreen</em>的过程中解耦，<em>ViewController</em>不需要知道它是嵌入到<em>UINavigationController</em>中或者是<em>UISplitViewController</em>中，都可以调用此方法来展示到屏幕上。在<em>regular</em>环境，<em>UISplitViewController</em>重写了该方法，将<em>vc</em>以<em>detailview controller</em>的方式加载;在<em>compact</em>环境，<em>split viewcontroller</em>的该方法实现是调用<code>show(_:sender:)</code>方法。</p><p>同<code>show(_:sender:)</code>相同:该方法的默认实现会调用<em>targetViewControllerForAction:sender:</em>在<em>viewcontroller</em>层级中找到重写该方法的对象，然后调用该对象的此方法，使其能够以适当的方式来展现<em>viewcontroller</em>。如果<em>targetViewControllerForAction:sender:</em>方法返回<em>nil</em>，此方法会使用<em>window</em>的<em>rootview controller</em>来模态显示<em>vc</em>。</p><p>你可以在自定义<em>viewcontroller</em>中重载此方法来展示<em>vc</em>，使用此方法来将<em>vc</em>展现在<em>secondarycontext</em>中，例如，一个容器<em>viewcontroller</em>可能会使用此方法来替换第二子控制器，你的实现应该为<em>regular</em>和<em>compact</em>环境做好适配.</p><p><ahref="https://developer.apple.com/reference/uikit/uiviewcontroller/1621432-showdetailviewcontroller">官方文档</a></p><h2 id="present-modally">Present Modally</h2><blockquote><p>Presents a view controller modally.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent </span><br><span class="line">                     animated:(BOOL)flag </span><br><span class="line">                   completion:(void (^)(void))completion;</span><br></pre></td></tr></table></figure></blockquote><p>在<em>horizontally regular</em>的环境，<em>viewcontroller</em>会以<em>modalPresentationStyle</em>属性设定的样式进行展现。在<em>horizontallycompact</em>环境，<em>viewcontroller</em>默认会以全屏的方式进行展现。对于<em>viewControllerToPresent</em>关联的<em>presentationcontroller</em>, 如果你实现了其<em>adaptivedelegate</em>方法，则可以动态修改<em>presentation style</em>。</p><p>调用该方法的对象不一定是处理该<em>presentation</em>的对象。每一个<em>presentationstyle</em>会有不同的规则来处理其行为。例如，<em>full-screenpresentation</em>必须由自身覆盖了整个屏幕的<em>viewcontroller</em>来处理。如果调用该方法的当前<em>viewcontrolelr</em>不能满足该要求，则它会沿着<em>viewcontroller</em>的层级向上传递给最近的父控制器，由其父控制器来负责处理或者继续转发该请求。</p><p>在展现<em>view controller</em>之前，该方法会基于<em>presentationstyle</em>来设置<em>presented viewcontroller</em>的<em>view</em>大小。对于大多数的<em>presentationstyles</em>，最终视图会以<em>presented viewcontroller</em>的<em>modalTransitionStyle</em>属性设定的转场样式动画来显示到屏幕上。对于自定义的<em>presentations</em>,视图会以<em>presented view controller</em>的<em>transitioningdelegate</em>中要求的动画来展示。对于<em>current contextpresentations</em>,视图<strong>可能</strong>会是以当前<em>viewcontroller</em>的<em>transitionstyle</em>来显示到屏幕上，这种情况稍后会再次提到。</p><p>注意: <em>completion</em>闭包是在<em>presented viewcontroller</em>的<em>viewDidAppear:</em>的方法调用完成后才会调用。</p><p><ahref="https://developer.apple.com/reference/uikit/uiviewcontroller/1621380-presentviewcontroller">官方文档</a></p><p>接下来聊聊<em>present modally</em>类型下的<em>presentationstyle</em>.</p><h3 id="presentation-styles">Presentation Styles</h3><p><em>view controller</em>的<em>presentationstyle</em>控制其在屏幕上的显示。<em>UIKit</em>定义了多种标准的<em>presentationstyles</em>,每一种都有特定的UI展示和用途。当然，你也可以自定义<em>presentationstyles</em>。当设计你的<em>app</em>时，根据当前的使用场景选择最合适的<em>presentaionstyle</em>, 然后设置<em>presented viewcontroller</em>的<em>modalPresentationStyle</em>属性值为对应的常量值。</p><blockquote><p>modalPresentationStyle:<br />The presentation style determines how a modally presented viewcontroller is displayed onscreen. In a horizontally compact environment,modal view controllers are always presented<strong>full-screen</strong>. In a horizontally regular environment,there are several different presentation options. For a list of possiblepresentation styles, and their compatibility with the availabletransition styles, see the UIModalPresentationStyle constantdescriptions.</p></blockquote><p><em>UIModalPresentationStyle</em>的枚举值定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public enum UIModalPresentationStyle : Int &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    case fullScreen</span><br><span class="line"></span><br><span class="line">    @available(iOS 3.2, *)</span><br><span class="line">    case pageSheet</span><br><span class="line"></span><br><span class="line">    @available(iOS 3.2, *)</span><br><span class="line">    case formSheet</span><br><span class="line"></span><br><span class="line">    @available(iOS 3.2, *)</span><br><span class="line">    case currentContext</span><br><span class="line"></span><br><span class="line">    @available(iOS 7.0, *)</span><br><span class="line">    case custom</span><br><span class="line"></span><br><span class="line">    @available(iOS 8.0, *)</span><br><span class="line">    case overFullScreen</span><br><span class="line"></span><br><span class="line">    @available(iOS 8.0, *)</span><br><span class="line">    case overCurrentContext</span><br><span class="line"></span><br><span class="line">    @available(iOS 8.0, *)</span><br><span class="line">    case popover</span><br><span class="line"></span><br><span class="line">    @available(iOS 7.0, *)</span><br><span class="line">    case none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<em>popover</em>需要进行特殊处理，在<em>Xcode</em>中，<em>Presentation</em>处仅有如下图所示的设置:</p><div class="figure left" style="width:256;"><img class="fig-img" src="/img/system-presentation/presentation-style.png" style="width:256;height:320;"alt="Presentation设置值"><span class="caption">Presentation设置值</span></div><div style="clear:both;"></div><p>对以上枚举值进行大体分类: <em>full-screen presentation styles</em>,<em>popover style</em>, <em>current context styles</em>, <em>custompresentation styles</em>。其中:</p><ul><li><em>full-screen presentationstyles</em>对应枚举值<em>fullScreen</em>, <em>pageSheet</em>,<em>formSheet</em>, <em>overFullScreen</em>;<br /></li><li><em>popover style</em>对应枚举值<em>popover</em>;<br /></li><li><em>current context styles</em>对应枚举值<em>currentContext</em>,<em>overCurrentContext</em>。</li></ul><p>先看看<em>full-screen presentation styles</em>。</p><h4 id="full-screen-presentation-styles">Full-Screen PresentationStyles</h4><blockquote><p>Full screen presentation styles cover the entire screen, preventinginteractions with the underlying content. In a horizontally regularenvironment, only one of the full-screen styles covers the underlyingcontent completely. The rest incorporate dimming views or transparencyto allow portions of the underlying view controller to show through. Ina horizontally compact environment, full-screen presentationsautomatically adapt to the UIModalPresentationFullScreen style and coverall of the underlying content.</p></blockquote><p><em>full screen presentationstyles</em>会覆盖设备的整个屏幕，阻止用户与底部内容进行交互。在<em>horizontallyregular</em>环境，<em>full screen presentationstyles</em>中只有一种类型(<em>UIModalPresentationFullScreen</em>)会完全覆盖住底部的内容，其余的类型会结合透明或者黑色半透明的视图来使底部的部分内容显示出来。在<em>horizontallycompact</em>环境，所有的<em>full screen presentationstyles</em>会自动适配为<em>UIModalPresentationFullScreen</em>类型并覆盖底部的所有内容。</p><p>下图是在<em>horizontally regular</em>环境下<em>fullScreen</em>,<em>pageSheet</em>,<em>formSheet</em>样式下的显示效果。图中，左上角的绿色<em>viewcontroller</em>会<em>presents</em>右上角的蓝色<em>viewcontroller</em>，对于某些<em>presentation styles</em>,<em>UIKit</em>会在两个<em>view controller</em>之间插入<em>dimmingview</em>。</p><div class="figure left" style="width:;"><img class="fig-img" src="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_PresentationStyles%20_fig_8-1_2x.png" alt="The full screen presentation styles"><span class="caption">The full screen presentation styles</span></div><div style="clear:both;"></div><h5 id="fullscreen">fullScreen</h5><blockquote><p>case fullScreen = 0</p><p>A presentation style in which the presented view covers the screen.<strong>The views belonging to the presenting view controller areremoved after the presentation completes.</strong></p></blockquote><p>此种类型的<em>presentation style presentedview</em>会完全覆盖屏幕。且属于<em>presenting viewcontroller</em>的视图会在<em>presentationcompletes</em>后移除视图层级。</p><blockquote><p>注意：当你使用<em>UIModalPresentationFullScreen</em>样式来<em>presentinga viewcontroller</em>的时候，<em>UIKit</em>会在转场动画完成后移除底部控制器(所覆盖的控制器)的视图，如果你想阻止视图的移除，则可以使用<em>UIModalPresentationOverFullScreen</em>样式来替代。当<em>presentedviewcontroller</em>设计有透明区域以显示底层内容时，你可能会用到这种样式。</p></blockquote><h5 id="pagesheet">pageSheet</h5><blockquote><p>case pageSheet = 1</p><p>In a horizontally regular environment, a presentation style thatpartially covers the underlying content. The presented view's width isset to the width of the screen in a portrait orientation and the theheight is set to the height of the screen. Any uncovered areas aredimmed to prevent the user from interacting with them. (In portraitorientations, this option is essentially the same as fullScreen.)</p><p>In a horizontally compact environment, this option behaves the sameas fullScreen.</p></blockquote><p>在<em>horizontally regular</em>环境，此种<em>presentationstyle</em>会部分遮挡底部的内容。<em>presentedview</em>的宽度会被设置成与<em>portraitorientation</em>模式下屏幕的宽度相等，且<em>presentedview</em>的高度被设置成与设备当前模式(<em>portrait 或者landscape</em>)下屏幕的高度相同。任何未覆盖到的区域会加黑色透明视图以阻止用户的交互。在<em>portraitorientations</em>场景，该设置大体上与<em>fullScreen</em>相同(该样式下，<em>statusbar</em>上会覆盖黑色透明视图)。在<em>horizontallycompact</em>环境下，该样式与<em>fullScreen</em>样式完全相同。</p><h5 id="formsheet">formSheet</h5><blockquote><p>case formSheet = 2</p><p>In a horizontally regular environment, a presentation style thatdisplays the content centered in the screen. The width and height of thecontent area are smaller than the screen size and a dimming view isplaced underneath the content. If the device is in a landscapeorientation and the keyboard is visible, the position of the view isadjusted upward so that the view remains visible. All uncovered areasare dimmed to prevent the user from interacting with them.</p><p>In a horizontally compact environment, this option behaves the sameas fullScreen.</p></blockquote><p>在<em>horizontallyregular</em>环境下，<em>formSheet</em>这种样式会将内容布局在屏幕的中间。显示内容的宽高都会比屏幕尺寸小，并且会在显示内容下插入黑色透明视图(<em>dimmingview</em>)。如果设备处于<em>landscapeorientation</em>并且弹出了键盘，显示内容会向上移动适配以使显示内容仍然可见。所有未被显示内容覆盖到的区域都会被<em>dimmed</em>以阻止用户与其交互。</p><p>在<em>horizontallycompact</em>环境，该选项的效果与<em>fullScreen</em>的效果完全一致。</p><hr /><blockquote><p>When using one of the full-screen presentation styles, the viewcontroller that initiates the presentation must itself cover the entirescreen. If the presenting view controller does not cover the screen,UIKit walks up the view controller hierarchy until it finds one thatdoes. If it can’t find an intermediate view controller that fills thescreen, UIKit uses the root view controller of the window.</p></blockquote><p>当你使用这些<em>full-screen presentationstyles</em>时，启动这次<em>presentation</em>的<em>viewcontroller</em>必须其自身是覆盖了整个屏幕。如果<em>presenting viewcontroller</em>没有覆盖整个屏幕，则<em>UIKit</em>会沿着<em>viewcontroller</em>的层级一直寻找直到找到满足该条件的<em>viewcontroller</em>，如果没有找到，<em>UIKit</em>则会使用<em>window</em>的<em>rootview controller</em>。</p><h4 id="the-popover-style">The Popover Style</h4><p>内容见<a href="#presenting-popover">Presenting a View Controller in aPopover</a></p><h4 id="the-current-context-styles">The Current Context Styles</h4><p>使用<em>UIModalPresentationCurrentContext</em>样式会使<em>presentedview controller</em>覆盖你在<em>UI</em>中指定的<em>viewcontroller</em>。你通过设置<em>viewcontroller</em>的<em>definesPresentationContext</em>属性值为<em>YES</em>来使其成为被覆盖的对象。下图演示的是<em>currencontext presentation</em>仅仅覆盖了<em>split viewcontroller</em>的一个子控制器。</p><div class="figure left" style="width:;"><img class="fig-img" src="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_CurrentContextStyles_2x.png" alt="The current context presentation style"><span class="caption">The current context presentation style</span></div><div style="clear:both;"></div><p>注意：使用该样式时，对于未被<em>presentedview</em>覆盖的区域，用户仍然可以与<em>UI</em>元素(例如<em>UIButton</em>)进行交互。</p><blockquote><p>A presentation style where the content is displayed over a viewcontroller’s content whose <em>definesPresentationContext</em> propertyis true. UIKit may walk up the view controller hierarchy to find a viewcontroller that wants to define the presentation context. The viewsbelonging to the presenting view controller are removed after thepresentation completes.</p><p>When presenting a view controller in a popover, this presentationstyle is supported only if the transition style is coverVertical.Attempting to use a different transition style triggers an exception.However, you may use other transition styles (except the partial curltransition) if the parent view controller is not in a popover.</p></blockquote><p>该样式会将内容显示在属性值<em>definesPresentationContext</em>为<em>true</em>的<em>viewcontroller</em>之上。<em>UIKit</em>会沿着<em>viewcontroller</em>的层级向上寻找定义了<em>presentationcontext</em>的<em>view controller</em>。属于<em>presenting viewcontroller</em>的视图会在<em>presentation completes</em>后移除。</p><p>当在一个<em>popover</em>中来<em>presenting viewcontroller</em>时，只有当<em>transitionstyle</em>是<em>coverVertical</em>时才支持此种样式，使用其它类型的<em>transitionstyle</em>会导致<em>crash</em>(经过测试，只有当<em>transitionstyles</em>为<em>partialcurl</em>时才会<em>crash</em>，不过小心为妙)。当<em>parent viewcontroller</em>不在<em>popover</em>中时，你可以使用除<em>partialcurl</em>外的其它<em>transition styles</em>。</p><p>当转场结束时，属于<em>presented viewcontroller</em>的视图会被移除，你可以使用<em>UIModalPresentationOverCurrentContext</em>样式来替代以避免被移除，你可能会在当<em>presentedview controller</em>有透明区域使底部内容显示出来时使用此样式。</p><p>定义成为<em>presentation context</em>的<em>view controller</em>,也可以在其内定义<em>presentation</em>时使用的转场动画。通常情况下，<em>UIKit</em>会使用<em>presentedviewcontroller</em>的<em>modalTransitionStyle</em>属性定义的动画将<em>presentedview controller</em>显示到屏幕上。如果<em>presentation context viewcontroller</em>的属性<em>providesPresentationContextTransitionStyle</em>值为<em>YES</em>,则<em>UIKit</em>会使用该<em>viewcontroller</em>的<em>modalTransitionStyle</em>属性值来执行动画。</p><p>当转换到<em>horizontally compact</em>环境时，<em>currentcontext</em>样式会适配为<em>UIModalPresentationFullScreen</em>样式。如果要想改变这种适配行为，可以使用<em>adaptivepresentation delegate</em>来指定另一种<em>presentationstyle</em>或者更换<em>view controller</em>。</p><h4 id="custom-presentation-styles">Custom Presentation Styles</h4><p><em>UIModalPresentationCustom</em>允许你使用自定义的样式来展示<em>viewcontroller</em>。创建自定义的样式需要你子类化<em>UIPresentationController</em>并且使用其方法来将自定义视图动画显示到屏幕，定义其大小和设置<em>presenteview controller</em>的大小。</p><p>更多信息参考: <ahref="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1">CreatingCustom Presentations</a></p><h3 id="transition-styles">Transition Styles</h3><blockquote><p>Transition styles determine the type of animations used to display apresented view controller. For the built-in transition styles, youassign one of the standard transition styles to the modalTransitionStyleproperty of the view controller you want to present. When you presentthe view controller, UIKit creates the animations that correspond tothat style. For example, Figure 8-4 illustrates how the standardslide-up transition (UIModalTransitionStyleCoverVertical) animates theview controller onscreen. View controller B starts offscreen andanimates up and over the top of view controller A. When view controllerB is dismissed, the animation reverses so that B slides down to revealA.</p></blockquote><p><em>transition styles</em>决定了显示<em>presented viewcontroller</em>时所用的动画类型。对于系统内置的<em>transitionstyles</em>，你可以通过对<em>presented viewcontroller</em>的<em>modalTransitionStyle</em>属性赋值来指定样式。当你显示<em>viewcontroller</em>时，<em>UIKit</em>属性值对应的动画。例如，下图演示了系统<em>UIModalTransitionStyleCoverVertical</em>样式对应的显示动画。<em>viewcontroller B</em>从不可见-&gt;往上滑进屏幕-&gt;覆盖<em>view controllerA</em>。当<em>view controllerB</em>退场时，它会向下滑出屏幕以显示<em>view controller A</em>。</p><div class="figure left" style="width:;"><img class="fig-img" src="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_SlideTransition_fig_8-1_2x.png" alt="A transition animation for a view controller"><span class="caption">A transition animation for a view controller</span></div><div style="clear:both;"></div><blockquote><p>You can create custom transitions using an animator object andtransitioning delegate. The animator object creates the transitionanimations for placing the view controller onscreen. The transitioningdelegate supplies that animator object to UIKit at the appropriate time.For information about how to implement custom transitions, seeCustomizing the Transition Animations</p></blockquote><p>目前iOS支持的系统转场类型如下图所示:</p><div class="figure left" style="width:256;"><img class="fig-img" src="/img/system-presentation/transition-style.png" style="width:256;height:288;"alt="iOS默认转场动画类型"><span class="caption">iOS默认转场动画类型</span></div><div style="clear:both;"></div><p>经过测试，<em>PartialCurl</em>转场只有在<em>Presentation</em>为<em>FullScreen</em>时才会有效，其余<em>presentationstyles</em>会导致<em>crash</em>，不知道是我使用的方式不对或者是其它原因，请指教。</p><h2 id="presenting-a-view-controller-in-a-popover">Presenting a ViewController in a Popover</h2><p>同上，这种方式也是使用api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent </span><br><span class="line">                     animated:(BOOL)flag </span><br><span class="line">                   completion:(void (^)(void))completion;</span><br></pre></td></tr></table></figure><p>来展现视图。与上不同的是，<em>popover</em>的展现方式还需要额外的配置。在设置<em>model presentationstyle</em>值为<em>UIModalPresentationPopover</em>之后，配置如下与<em>popover</em>相关的属性值:</p><ul><li>设置<em>presented viewcontroller</em>的<em>preferredContentSize</em>，将视图大小设置为期望的大小；</li><li>从<em>presented viewcontroller</em>的<em>popoverPresentationController</em>属性中获取关联的<em>UIPopoverPresentationController</em>对象，然后设置该对象的锚点。设置锚点可从如下两种方式中任选一种:<ul><li>设置<em>barButtonItem</em>属性值为一个<em>bar button item</em>;</li><li>设置<em>sourceView</em>和<em>sourceRect</em>属性值为视图中的特定区域；</li></ul></li></ul><p>你可以使用<em>UIPopoverPresentationController</em>对象来修改<em>popover</em>最终绘制出来的效果。<em>popoverpresentationcontroller</em>同样也支持使用一个<em>delegate</em>对象来监听<em>presentation</em>过程以做出对应的响应。例如，你可以使用该<em>delegate</em>对象来监听<em>popover</em>的<em>appears</em>,<em>disappears</em>, 或者<em>repositioned on thescreen</em>事件，以做出对应的响应。关于该对象的更多信息，请参考: <ahref="https://developer.apple.com/reference/uikit/uipopoverpresentationcontroller">UIPopoverPresentationControllerClass Reference</a></p><p><em>UIModalPresentationPopover</em>样式会以浮层的形式显示<em>viewcontroller</em>.<em>Popovers</em>可用来显示一些额外信息，或者，是当前聚焦或者选中对象关联的对象列表。在<em>horizontallyregular</em>环境，弹出的浮层只会覆盖屏幕的一部分，如下图所示。在<em>horizontallycompact</em>环境，<em>popovers</em>会默认适配为<em>UIModalPresentationOverFullScreen</em>样式。在浮层以外的区域点击则会自动使浮层消失。</p><div class="figure left" style="width:;"><img class="fig-img" src="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_popover-style_2x.png" alt="The popover presentation style"><span class="caption">The popover presentation style</span></div><div style="clear:both;"></div><p>由于<em>popovers</em>在<em>horizontallycompact</em>环境下会自动适配为<em>full-screenpresentations</em>，你需要编辑你的浮层代码以处理这种适配。在<em>full-screen</em>模式下，你需要一种方式来使<em>presentedpopover</em>消失。你可以添加一个按钮，将<em>popover</em>嵌入到可<em>dismissible</em>的容器视图控制器中，或者是修改该适配行为。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录的是对下图所示的&lt;em&gt;Kind&lt;/em&gt;, &lt;em&gt;Presentation&lt;/em&gt;,
&lt;em&gt;Transition&lt;/em&gt;的理解：&lt;/p&gt;
&lt;div class=&quot;figure left&quot; style=&quot;width:260;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;/img/system-presentation/system-presentation.png&quot; style=&quot;width:260;height:250;&quot;alt=&quot;iOS系统转场&quot;&gt;&lt;span class=&quot;caption&quot;&gt;iOS系统转场&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="转场" scheme="http://liumh.com/tags/%E8%BD%AC%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>创建模态视图</title>
    <link href="http://liumh.com/2016/10/03/swift-dim-background-viewcontroller/"/>
    <id>http://liumh.com/2016/10/03/swift-dim-background-viewcontroller/</id>
    <published>2016-10-03T01:48:56.000Z</published>
    <updated>2024-10-21T14:49:14.485Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的开发过程中，会遇到弹出模态视图进行交互的情况，用户实际操作区域只占屏幕的一部分，其余区域使用半透明黑色遮罩进行覆盖。下面就记录一下实现如下所示模态视图的方案。</p><span id="more"></span><div class="figure left" style="width:162;"><img class="fig-img" src="/img/modal-popup/modal-popup-window.gif" style="width:162;height:322;"alt="Popup_Window动画"><span class="caption">Popup_Window动画</span></div><div style="clear:both;"></div><p>这里有3种实现方案, 根据情况可选择合适的方案:</p><ol type="1"><li>添加视图到<code>ViewController.view.window</code>上</li><li>使用系统提供的模态转场</li><li>切换window</li></ol><h4id="添加视图到viewcontroller.view.window上">添加视图到<code>ViewController.view.window</code>上</h4><p>相信大多数人都对这种实现方式很熟悉。该方式是在当前视图的最上层添加一层自定义的黑色遮罩，然后在黑色遮罩上添加真正需要显示的视图，主要代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func showPopupView() &#123;</span><br><span class="line">    //1.创建黑色遮罩    </span><br><span class="line">    let screenRect = UIScreen.main.bounds;</span><br><span class="line">    var startFrame = screenRect;</span><br><span class="line">    startFrame.origin.x = screenRect.width;</span><br><span class="line">    dimmingView = UIView.init(frame: startFrame)</span><br><span class="line">    dimmingView.backgroundColor = UIColor.black.withAlphaComponent(0.6)</span><br><span class="line">    </span><br><span class="line">    let tapGesture = UITapGestureRecognizer.init(target: self, action: #selector(hiddenPopupView))</span><br><span class="line">    dimmingView.addGestureRecognizer(tapGesture)</span><br><span class="line">    </span><br><span class="line">    //2.创建用户真正关心的视图</span><br><span class="line">    var focusViewRect = screenRect</span><br><span class="line">    focusViewRect.size.width = 0.8 * screenRect.width</span><br><span class="line">    focusViewRect.origin.x = 0.2 * screenRect.width</span><br><span class="line">    let focusView = UIView.init(frame: focusViewRect)</span><br><span class="line">    focusView.backgroundColor = UIColor.init(red: 137.0/255.0, green: 1.0, blue: 152.0/255.0, alpha: 1)</span><br><span class="line">    </span><br><span class="line">    //3.添加视图到window上</span><br><span class="line">    dimmingView.addSubview(focusView)</span><br><span class="line">    self.view.window?.addSubview(dimmingView);</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.25, animations: &#123;</span><br><span class="line">        self.dimmingView.frame = screenRect</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func hiddenPopupView(_ sender: UITapGestureRecognizer) &#123;</span><br><span class="line">        </span><br><span class="line">    let screenRect = UIScreen.main.bounds;</span><br><span class="line">    var finalFrame = screenRect;</span><br><span class="line">    finalFrame.origin.x = screenRect.width;</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.25, animations: &#123;</span><br><span class="line">        self.dimmingView.frame = finalFrame</span><br><span class="line">        &#125;, completion: &#123; finished in</span><br><span class="line">        self.dimmingView.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方案时要注意，你若在模态视图中 <code>IQKeyboardManager</code>第三方库不会起作用。</p><h4 id="使用系统提供的模态转场">使用系统提供的模态转场</h4><p>按道理，这应该是代码量最小的实现方式，但是如果要实现本文开始所示动画(系统默认的是从屏幕底部往上推出视图)，则需要自定义动画。另外，由于能够透视遮罩下的视图，需要将弹出的ViewController的<code>modalPresentationStyle</code>设置成<code>UIModalPresentationOverFullScreen</code>,而该枚举值是iOS 8.0以上才支持。</p><p>自定义转场动画的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class SlideSegue: UIStoryboardSegue &#123;</span><br><span class="line"></span><br><span class="line">    override func perform() &#123;</span><br><span class="line">        </span><br><span class="line">        destination.transitioningDelegate = self</span><br><span class="line">        super.perform()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension SlideSegue: UIViewControllerTransitioningDelegate &#123;</span><br><span class="line">    </span><br><span class="line">    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        </span><br><span class="line">        return SlideInAnimator()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        </span><br><span class="line">        return SlideOutAnimator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// MARK - Animator</span><br><span class="line"></span><br><span class="line">class SlideInAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;</span><br><span class="line">        </span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        </span><br><span class="line">        let toViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to)!</span><br><span class="line">        let toView = transitionContext.view(forKey: UITransitionContextViewKey.to)</span><br><span class="line">        </span><br><span class="line">        if let toView = toView &#123;</span><br><span class="line">            transitionContext.containerView.addSubview(toView)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        let finalFrame = transitionContext.finalFrame(for: toViewController)</span><br><span class="line">        var startFrame = finalFrame</span><br><span class="line">        startFrame.origin.x = finalFrame.width</span><br><span class="line">    </span><br><span class="line">        toView?.frame = startFrame</span><br><span class="line">//        toView?.layoutIfNeeded()</span><br><span class="line">        </span><br><span class="line">        let duration = transitionDuration(using: transitionContext)</span><br><span class="line">        </span><br><span class="line">        UIView.animate(withDuration: duration, animations: &#123; </span><br><span class="line">            if let toView = toView &#123;</span><br><span class="line">                toView.frame = finalFrame</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, completion: &#123; finished in</span><br><span class="line">                transitionContext.completeTransition(true)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SlideOutAnimator:NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;</span><br><span class="line">        </span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">     </span><br><span class="line">        let fromViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from)!</span><br><span class="line">        let toView = transitionContext.view(forKey: UITransitionContextViewKey.to)</span><br><span class="line">        let fromView = transitionContext.view(forKey: UITransitionContextViewKey.from)</span><br><span class="line">        </span><br><span class="line">        if let toView = toView &#123;</span><br><span class="line">            if let fromView = fromView &#123;</span><br><span class="line">                transitionContext.containerView.insertSubview(toView, belowSubview: fromView)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var finialFrame = transitionContext.finalFrame(for: fromViewController)</span><br><span class="line">        finialFrame.origin.x += finialFrame.width</span><br><span class="line">        </span><br><span class="line">        let duration = transitionDuration(using: transitionContext)</span><br><span class="line">        UIView.animate(withDuration: duration, animations: &#123; </span><br><span class="line">            if let fromView = fromView &#123;</span><br><span class="line">                fromView.frame = finialFrame</span><br><span class="line">//                fromView.layoutIfNeeded()</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, completion: &#123; finished in</span><br><span class="line">                transitionContext.completeTransition(true)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余部分的 Storyboard 设置参考 <ahref="https://github.com/carya/PopupWindow">github上本工程代码</a>。</p><p>关于视图控制器的自定义转场，以后会单独写一篇来记录。</p><h4 id="切换window">切换window</h4><p>这种实现方式的好处是将弹出的用户关心的视图封装到一个新的视图控制器中，与当前的视图控制器分离，从而使业务分离，避免当前的试图控制器臃肿。显示模态视图的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func showPopupViewController(_ sender: AnyObject) &#123;</span><br><span class="line">    checkoutNewWindow()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func checkoutNewWindow() &#123;</span><br><span class="line">    </span><br><span class="line">    var frame = UIScreen.main.bounds</span><br><span class="line">    frame.origin.x += frame.size.width</span><br><span class="line">    popWindow = UIWindow.init(frame: frame)</span><br><span class="line">    </span><br><span class="line">    let storyboard = UIStoryboard.init(name: &quot;Main&quot;, bundle: nil)</span><br><span class="line">    let popupViewController = storyboard.instantiateViewController(withIdentifier: &quot;PopupViewController&quot;)</span><br><span class="line">    popWindow.rootViewController = popupViewController</span><br><span class="line">    popWindow.makeKeyAndVisible()</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.5, animations: &#123;</span><br><span class="line">        let rect = UIScreen.main.bounds</span><br><span class="line">        self.popWindow.frame = rect</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本工程所有代码见<ahref="https://github.com/carya/PopupWindow">github</a></p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS的开发过程中，会遇到弹出模态视图进行交互的情况，用户实际操作区域只占屏幕的一部分，其余区域使用半透明黑色遮罩进行覆盖。下面就记录一下实现如下所示模态视图的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="swift" scheme="http://liumh.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Xcode使用xcconfig文件配置环境</title>
    <link href="http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/"/>
    <id>http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/</id>
    <published>2016-05-22T01:42:50.000Z</published>
    <updated>2024-10-21T14:51:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>与公司 QA聊天，已不止一次被吐槽说移动端从开发环境转到生产环境时，还要靠修改代码来配置对应的环境参数。她认为，从App转测试之后，就不应该再修改代码，可以把所有的环境配置都整合到配置文件中，这样打不同环境下的安装包时，会自动选择对应的环境参数。这里说到的环境参数包括但不仅限于：webservice 地址，友盟 AppKey，极光推送 AppKey和是否是生产环境标志等。</p><p>其实，我也讨厌修改环境参数啊，😂</p><p>为达成上述目的，主要是使用 Xcode 的 Configurations SettingFile(即后缀为 xcconfig 文件)来配置开发不同阶段下的环境。本文包含的内容如下:</p><span id="more"></span><ol type="1"><li>Xcode Target</li><li>Xcode Project</li><li>Build Setting的继承关系</li><li>如何使用xcconfig文件来配置不同开发阶段的环境</li></ol><p>包含了一些与 build settings 相关的知识。</p><h3 id="xcode-target">Xcode Target</h3><p>target, 官方文档如下解释:</p><blockquote><p>A target specifies a product to build and contains the instructionsfor building the product from a set of files in a project or workspace.A target defines a single product; it organizes the inputs into thebuild system—the source files and instructions for processing thosesource files—required to build that product. Projects can contain one ormore targets, each of which produces one product.</p></blockquote><p>target 定义了生成的唯一 product, 它将构建该 product所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects会包含一个或者多个 targets,每一个 target 将会产出一个 product.</p><blockquote><p>The instructions for building a product take the form of buildsettings and build phases, which you can examine and edit in the Xcodeproject editor. <em>A target inherits the project build settings, butyou can override any of the project settings by specifying differentsettings at the target level.</em> There can be only one active targetat a time; the Xcode scheme specifies the active target.</p></blockquote><p>这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;BuildPhases)中进行查看和编辑。<em>target 中的 build setting 参数继承自project 的 build settings, 但是你可以在 target 中修改任意 settings来重写 project settings，这样，最终生效的 settings 参数以在 target中设置的为准</em>. Project 可包含多个 target, 但是在同一时刻，只会有一个target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效.</p><blockquote><p>A target and the product it creates can be related to another target.If a target requires the output of another target in order to build, thefirst target is said to depend upon the second. If both targets are inthe same workspace, Xcode can discover the dependency, in which case itbuilds the products in the required order. Such a relationship isreferred to as an implicit dependency. You can also specify explicittarget dependencies in your build settings, and you can specify that twotargets that Xcode might expect to have an implicit dependency areactually not dependent. For example, you might build both a library andan application that links against that library in the same workspace.Xcode can discover this relationship and automatically build the libraryfirst. However, if you actually want to link against a version of thelibrary other than the one built in the workspace, you can create anexplicit dependency in your build settings, which overrides thisimplicit dependency.</p></blockquote><p>target 和其生成的 product 可与另一个 target 有关，如果一个 target 的build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个target .如果这些 target 在同一个 workspace 中，那么 Xcode能够发现这种依赖关系，从而使其以我们期望的顺序生成products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。</p><p>指定 targets 之间的依赖关系的地方在 ProjectEditor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置。</p><h3 id="xcode-project">Xcode Project</h3><p>官方文档的解释如下:</p><blockquote><p>An Xcode project is a repository for all the files, resources, andinformation required to build one or more software products. A projectcontains all the elements used to build your products and maintains therelationships between those elements. It contains one or more targets,which specify how to build products. A project defines default buildsettings for all the targets in the project (each target can alsospecify its own build settings, which override the project buildsettings).</p></blockquote><p>Xcode project是一个仓库，该仓库包含了所有的文件，资源和用于生成一个或者多个 softwareproducts 的信息。它包含一个或者多个 targets，其中的每一个 target指明了如何生成 products。project 为其拥有的所有 targets 定义了默认的build settings，当然，每一个 target 能够制定其自己的 build settings，且target 的 build settings 会重写 project 的 build settings。</p><p>Xcode project 文件包含以下信息:</p><ul><li>源文件的引用:<ul><li>源码，包括头文件和实现文件</li><li>内部和外部的库或者框架</li><li>资源文件</li><li>图片文件</li><li>Interface Builder(nib)文件</li></ul></li><li>文件结构导航中用来组织源文件的组</li><li>Project-level build configurations.你可以为 project 指定多个 buildconfiguration，例如，project 中默认包含 debug 和 release 两种 buildsettings.</li><li>Targets, 每一个 target 指定了：<ul><li>project 生成的 product</li><li>生成 product 所需的源文件</li><li>生成 product 所需的配置文件，包括对其他 targets的依赖以及一些其他设置；当 targets 的 build configurations 没有重写project-level 的 build settings 时，会直接使用 project-level 的 buildsetting.</li></ul></li><li>可执行环境，该环境用于调试或者测试程序，每个可执行环境会指定：<ul><li>运行或者调试程序时加载的可执行程序</li><li>传递给可执行程序的命令行参数</li><li>运行程序时需设置的环境变量</li></ul></li></ul><p>project 可独立存在，也可被包含在 workspace 中。</p><h3 id="build-setting-的继承关系">Build Setting 的继承关系</h3><p>官方文档内容如下:</p><blockquote><p>A build setting is a variable that contains information about how aparticular aspect of a product’s build process should be performed. Forexample, the information in a build setting can specify which optionsXcode passes to the compiler.</p><p>You can specify build settings at the project or target level. Eachproject-level build setting applies to all targets in the project unlessexplicitly overridden by the build settings for a specific target.</p></blockquote><p>build setting 中包含了 product 生成过程中所需的参数信息。你可以在project-level 和 target-level 层指定 build settings。project-level 的build settings 适用于 project 中的所有targets，但是当 target-level 的build settings 重写了 project-level 的 build settings，以 target-level中的 build settings 中的值为准。</p><blockquote><p>Each target organizes the source files needed to build one product. Abuild configuration specifies a set of build settings used to build atarget's product in a particular way. For example, it is common to haveseparate build configurations for debug and release builds of aproduct.</p></blockquote><p>一个 build configaration 指定了一套 build settings 用于生成某一target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 buildconfigarations, 分别用于生成 debug 和 release 模式下的 product。</p><blockquote><p>In addition to the default build settings provided by Xcode when youcreate a new project from a project template, you can createuser-defined build settings for your project or for a particular target.You can also specify conditional build settings. The value of aconditional build setting depends on whether one or more prerequisitesare met. This mechanism allows you to, for example, specify the SDK touse to build a product based on the targeted architecture.</p></blockquote><p>除了创建工程时生成的默认 build settings，你也可以自定义 project-level或者 target-level 的 build settings.</p><p>关于继承关系，<ahref="http://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance">TheUnofficial Guide to xcconfig files</a>这里也有详细的说明，强烈建议阅读。</p><p>现在就来看看如何使用自定义的 build settings来达到本文开始处提到的需求.</p><h3 id="如何使用-xcconfig-文件来配置不同开发阶段的环境">如何使用xcconfig 文件来配置不同开发阶段的环境</h3><p>目前公司中的开发大致分两个阶段，第一阶段：开发阶段，此时所打包都是使用development的证书，极光和友盟统计的账号都是使用开发者自己申请的账号，webservice的地址使用开发环境地址；第二阶段：uat阶段，此时属于预发版阶段，此时打包使用 ad-hoc的证书，极光和友盟统计的账号使用公司申请生成账号，webservice使用的特定的预发版环境；另外，打上传到 App Store 的生产包，使用distribution 的证书，webservice 的地址使用生产环境的地址。</p><p>由此，可新建一种 build configuration, 由 Xcode 自动生成的 Release复制而来，如下所示:</p><!--![新建Configurations](/img/use-xcconfig/use_xcconfig_new_configuration.png)--><div class="figure center" style="width:476;"><img class="fig-img" src="/img/use-xcconfig/use_xcconfig_new_configuration.png" style="width:476;height:148;"alt="新建Configurations"><span class="caption">新建Configurations</span></div><p>并命名为 PreRelease。</p><p>官方文档<ahref="https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html#//apple_ref/doc/uid/TP40010155-CH13-SW1">Addinga Build Configuration</a> 中如下提到：</p><blockquote><p>A configuration file is a plain text file with a list of buildsetting definitions, one per line. You can base a build configurationonly on a configuration file that is in your project, not on an externalfile.</p><p><em>When you base a target or project’s build configuration on aconfiguration file, that build configuration automatically inherits thebuild setting definitions in that configuration file (and anyconfiguration files it includes). If you then modify the value of any ofthose build settings in the target or project, the new value is usedinstead of the value in the configuration file.</em></p><p>Build settings defined at the target level override any valuesassigned to those build settings at the project level. Therefore,target-level configurations take precedence over any project-levelconfigurations.</p></blockquote><p>这里需要注意的是：<em>当你的 target-level 或者 project-levle 的 buildconfigurations 基于配置文件时，build configuration会自动继承配置文件(以及配置文件中引入的配置文件)中定义的 buildsettings，但是如果你又在之后 target 或者 project中修改了配置文件中定义的 build settings值，那么最终配置文件中的值会失效，实际使用的是 target 或者 project中设置的值。</em></p><p>这里鉴于公司的情况，新建了Debug.xcconfig/PreRelease.xcconfig/Release.xcconfig配置对应于开发阶段、预发版阶段、上传 AppStore 三种情况下的打包。</p><p>新建一个 xcconfig 目录，在该目录下新建配置文件:</p><!--![创建配置文件](/img/use-xcconfig/use_xcconfig_new_configfile.png 476 148)--><div class="figure center" style="width:476;"><img class="fig-img" src="/img/use-xcconfig/use_xcconfig_new_configfile.png" style="width:476;height:148;"alt="创建配置文件"><span class="caption">创建配置文件</span></div><p>根据项目情况，每个配置文件中都包含同样的 key 值，内容大致如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//网络请求baseurl</span><br><span class="line">WEBSERVICE_URL = @&quot;http:\/\/127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">//友盟配置</span><br><span class="line">UMENG_APPKEY = @&quot;xxxvvv555999==&quot;</span><br><span class="line"></span><br><span class="line">//极光推送配置</span><br><span class="line">JPUSH_DEVELOPMENT_APPKEY = @&quot;nnncccvvvwww&quot;</span><br><span class="line">IS_PRODUCATION = NO</span><br><span class="line"></span><br><span class="line">#include &quot;Generator.xcconfig&quot;</span><br></pre></td></tr></table></figure><p>你可在配置文件中包含其他配置文件，其中 Generator.xcconfig文件的内容是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) WEBSERVICE_URL=&#x27;$(WEBSERVICE_URL)&#x27; MESSAGE_SYSTEM_URL=&#x27;$(MESSAGE_SYSTEM_URL)&#x27; UMENG_APPKEY=&#x27;$(UMENG_APPKEY)&#x27;  IS_PRODUCATION=&#x27;$(IS_PRODUCATION)&#x27;</span><br></pre></td></tr></table></figure><p>其作用是将配置文件中定义的常量定义成预编译宏，以便于在代码中获取。</p><p>其中 GCC_PREPROCESSOR_DEFINITIONS, 文档如下：</p><blockquote><p>Space-separated list of option specifications. Specifies preprocessormacros in the form foo (for a simple #define) or foo=1 (for a valuedefinition). This list is passed to the compiler through the gcc -Doption when compiling precompiled headers and implementation files.</p></blockquote><p>GCC_PREPROCESSOR_DEFINITIONS 是 GCC 预编译头参数，通常我们可以在Project 文件下的 Build Settings 对预编译宏定义进行默认赋值。在 Xcode7下的路径为 Build Settings-&gt;Apple LLVM 7.xPreprocessing-&gt;Preprocessor Macros，</p><!-- ![GCC_PREPROCESSOR_DEFINITIONS](/img/use-xcconfig/user_xcconfig_gcc_preprocessing.png)--><div class="figure center" style="width:514;"><img class="fig-img" src="/img/use-xcconfig/user_xcconfig_gcc_preprocessing.png" style="width:514;height:146;"alt="GCC_PREPROCESSOR_DEFINITIONS"><span class="caption">GCC_PREPROCESSOR_DEFINITIONS</span></div><p>想必大家看这个宏的名字已经知道它的作用了, 使用上和在 pch头文件中添加宏定义没有太大的区别, 但有以下好处:</p><ol type="1"><li>Xcode 的 Project 的 Build Settings 是由一个 plist 文件进行描述的,plist 本质上是一个 XML 配置文件, 通过外部的脚本比较容易去修改。</li><li>Preprocessor Macros 可以按照 Configuration 选项进行默认配置,也就是说可以根据不同的环境预先制定不同定义的宏，或者为不同环境下的相同变量定义不同的值</li></ol><p>xcconfig 支持可以根据不同的 Configuration 选项配置不同的文件。不同的xcconfig 可以指定不同的 Build Settings 里的属性值,这样子我们就可以通过项目 xcconfig 去修改 GCC_PREPROCESSOR_DEFINITIONS的值了(最终目的就达到了)。</p><p>配置文件中变量定义好之后，怎么让 Xcode自动加载呢？如下图设置所示，是将 project-level 的 build settings基于配置文件，三种情况的 configurations 分别选择与之对应的配置文件。</p><!--![将配置文件与项目关联](/img/use-xcconfig/use_xcconfig_linkto_configfile.png 444 232)--><div class="figure center" style="width:444;"><img class="fig-img" src="/img/use-xcconfig/use_xcconfig_linkto_configfile.png" style="width:444;height:232;"alt="将配置文件与项目关联"><span class="caption">将配置文件与项目关联</span></div><p>当我们想把 project-level 或者 target-level 中的 Build Settings的设置挪动到 xcconfig配置文件来设置时，是否需要一个个手动输入呢？当然不是，直接在 BuildSettings 中选中你想要在 xcconfig中配置的键值对所在行（当然也可以选多行），<em>command +c</em>复制，然后到对应的 xcconfig 中去粘贴就好了，记得在 Build Settings中改为你想要的值后再复制，如果为默认值的话则只可复制其键。如果需要改回去的话，还是选中这行，<code>command + delete</code>就恢复默认值了。</p><p>现在我们将设置挪动到了配置文件中，所有的配置文件都是键值对类型的文本文件，但是当同一个键同时存在于target-level、project-level和配置文件中时，到底是哪一个键值对起作用了呢？现在看看下图。</p><!--![多个配置项列](/img/use-xcconfig/use_xcconfig_valid_configuration_default.png)--><div class="figure center" style="width:583;"><img class="fig-img" src="/img/use-xcconfig/use_xcconfig_valid_configuration_default.png" style="width:583;height:126;"alt="多个配置项列"><span class="caption">多个配置项列</span></div><p>注意:Xcode以从左至右的顺序设置解析的优先级，从左至右优先级降低，最左边的具有最高优先级，即target-level &gt; project-level &gt; 自定义配置文件 &gt; iOS默认配置；且最左列 Resolved 列显示的是最终使用的值。那么如何使 Xcode使用配置文件中的配置项呢？这需要选中要使用配置文件的行，点击 Delete按键，你会发现项目的默认设置已经被删除，且 xcconfig的配置文件列被标记为绿色。标记为绿色代表该列的值生效，其值应该与Resolved 列的值相同。</p><p>最后，你可以像如下示例使用 xcconfig 中定义的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;webservice url: %@, umeng appkey: %@&quot;, WEBSERVICE_URL, UMENG_APPKEY);</span><br></pre></td></tr></table></figure><p>通过以上步骤，就达到了使用 xcconfig文件来配置开发不同阶段时的环境变量的目的了。</p><p>文中内容为自己学习总结，如有错误之处请指正。如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure center" style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div><hr /><p>参考:</p><ul><li><ahref="https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Targets.html">XcodeConcepts</a></li><li><ahref="http://www.jontolof.com/cocoa/using-xcconfig-files-for-you-xcode-project/">Usingxcconfig files for your XCode Project</a></li><li><ahref="http://blog.startry.com/2015/07/24/iOS_EnvWithXcconfig/">iOS开发必备- 环境变量配置</a></li><li><ahref="http://stackoverflow.com/questions/24668284/xcconfig-how-to-set-environment-variables">xcconfig-how-to-set-environment-variables</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;与公司 QA
聊天，已不止一次被吐槽说移动端从开发环境转到生产环境时，还要靠修改代码来配置对应的环境参数。她认为，从
App
转测试之后，就不应该再修改代码，可以把所有的环境配置都整合到配置文件中，这样打不同环境下的安装包时，会自动选择对应的环境参数。这里说到的环境参数包括但不仅限于：
webservice 地址，友盟 AppKey，极光推送 AppKey
和是否是生产环境标志等。&lt;/p&gt;
&lt;p&gt;其实，我也讨厌修改环境参数啊，😂&lt;/p&gt;
&lt;p&gt;为达成上述目的，主要是使用 Xcode 的 Configurations Setting
File(即后缀为 xcconfig 文件)
来配置开发不同阶段下的环境。本文包含的内容如下:&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="Xcode" scheme="http://liumh.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的对象等同性</title>
    <link href="http://liumh.com/2016/01/06/ios-object-equal/"/>
    <id>http://liumh.com/2016/01/06/ios-object-equal/</id>
    <published>2016-01-06T14:23:20.000Z</published>
    <updated>2024-10-21T14:42:31.495Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>==</code> 比较 iOS中的对象时，比较的是对象的指针。例如有如下比较时:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;origin1&quot;;</span><br><span class="line">NSString *strCopy = [str copy];</span><br><span class="line">NSString *str1 = [NSString stringWithFormat:@&quot;origin%@&quot;, @1];</span><br><span class="line">    </span><br><span class="line">BOOL equalA = (str == strCopy);</span><br><span class="line">BOOL equalB = (str == str1);</span><br><span class="line"></span><br><span class="line">BOOL equalC = [str isEqualToString:str1];  /**&lt; equalC is YES */</span><br><span class="line">BOOL equalD = [str isEqual:str1]; /**&lt; equalD is YES */</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>equalA</code> 的值会是 <code>YES</code>, 而 <code>equalB</code>的值会是 <code>NO</code>，虽然<code>str</code>、<code>str1</code>、<code>strCopy</code>指针所指的对象的值都是 <code>origin1</code>。</p><p>比较对象时，我们应该使用 <code>NSObject</code> 协议中声明的<code>isEqual:</code>方法来判断两个对象的等同性。一般来说，两个类型不同的对象总是不相等的。</p><p><code>NSObject</code> 协议中有两个判断对象等同性的关键方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object;</span><br><span class="line">@property (readonly) NSUInteger hash;</span><br></pre></td></tr></table></figure><p><code>NSObject</code> 对这两个类的默认实现是:当且仅当其 “指针值”完全相等时，这两个对象才相等。若想在自定义对象中正确覆写这两个方法，那么就必须先理解其约定:如果 <code>isEqual:</code> 方法判断两个对象相等，那么其<code>hash</code> 方法必须返回同一个值，但是如果两个对象的<code>hash</code> 方法返回同一个值，<code>isEqual:</code>方法未必会认为二者相等。</p><p>假如有如下类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ACLStudent : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSUInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>对于这样的自定义对象，可以像 <code>NSString</code> 的<code>- (BOOL)isEqualToString:(NSString *)aString</code>方法一样，创建一个属于该类的特定等同性方法。同时需要注意该类对象的使用场景，例如这里，我们在判定两个类对象是否相等时，不需要对象中的所有字段都判定相等，只需要其<code>studentId</code>相等就可判定两个对象表示的是同一个学生对象。方法实现像下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqualToStudent:(ACLStudent *)student &#123;</span><br><span class="line">    if (self == student) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.studentId == student.studentId) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议同时实现其 <code>isEqual:</code> 方法，像下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([self class] == [object class]) &#123;</span><br><span class="line">        return [self isEqualToStudent:object];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [super isEqual:object];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先比较其指针值，假如指针值相等，则对象相等，然后判断传入对象的类型，如果是类的类型，则调用类特定的等同性方法，否则交由父类来判断。</p><p>同时不要忘记覆写 <code>- (NSUInteger)hash</code> 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return self.studentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在覆写类的 <code>hash</code>方法时，要注意其有较高的执行效率，又能使生成的哈希码至少位于一定的范围内，不至于频繁的重复。编写<code>hash</code>方法时，可用当前的对象做实验，以便在减少哈希码碰撞频度与降低其运算复杂度之间取舍。</p><blockquote><p>假如类的 <code>hash</code> 方法计算值过于频繁的重复，在<code>collection</code> 中使用这种对象将会产生性能问题，因为<code>collection</code> 在检索哈希表时，会用对象的哈希码做索引。假如某个<code>collection</code> 是用 <code>set</code> 实现的，那么<code>set</code> 可能会根据哈希码把对象分装到不同的数组中。在向<code>set</code>中添加新对象时，要根据哈希码找到与之相关的那个数组，依次检查其中的各个元素，看数组中已有的对象是否和将要添加的对象相等。如果相等，那就说明要添加的对象已经在<code>set</code>中了。由此可知，如果令每个对象的都返回相同的哈希码，那么在<code>set</code> 中已有 1000000个对象的情况下，若是继续向其中添加对象，则需要将这 1000000个对象全部扫描一遍。</p></blockquote><p>例如下面两种实现方法, 方法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSString *stringToHash = [NSString stringWithFormat:@&quot;%@:%@:%@&quot;, @(self.studentId), self.firstName, self.lastName];</span><br><span class="line">    return [stringToHash hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSUInteger firstNameHash = [self.firstName hash];</span><br><span class="line">    NSUInteger lastNameHash = [self.lastName hash];</span><br><span class="line">    return firstNameHash ^ lastNameHash ^ self.studentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2 比 方法1更好，减少了创建字符串的开销，同时其哈希值不至于频繁重复。</p><p>注意，我们把对象放入 <code>collection</code>之后，就不应再改变其哈希码了。前面讲过，<code>collection</code>会把各个对象按照其哈希码分装到不同的"箱子数组"中。如果某个对象在放入"箱子"之后哈希码又变了，那么其现在所处的箱子对它来说是"错误"的。要解决这个问题，需要确保哈希码不是根据对象的“可变部分”(mutableportion)计算出来的，或者保证放入 <code>collection</code>之后就不再改变对象的内容了。</p><p>本文来自<code>&lt;&lt;Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法&gt;&gt;</code></p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;==&lt;/code&gt; 比较 iOS
中的对象时，比较的是对象的指针。例如有如下比较时:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *str = @&amp;quot;origin1&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *strCopy = [str copy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str1 = [NSString stringWithFormat:@&amp;quot;origin%@&amp;quot;, @1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalA = (str == strCopy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalB = (str == str1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalC = [str isEqualToString:str1];  /**&amp;lt; equalC is YES */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalD = [str isEqual:str1]; /**&amp;lt; equalD is YES */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS理解NSCopying协议</title>
    <link href="http://liumh.com/2015/12/12/ios-understand-copy/"/>
    <id>http://liumh.com/2015/12/12/ios-understand-copy/</id>
    <published>2015-12-12T14:04:30.000Z</published>
    <updated>2024-10-21T14:46:42.904Z</updated>
    
    <content type="html"><![CDATA[<p>如何让自定义对象支持 copy 操作？是重写 copy方法么？当然不是，而是需要让自定义类实现 NSCopying协议，该协议只有一个方法:</p><span id="more"></span><p><code>- (id)copyWithZone:(nullable NSZone *)zone;</code></p><p>以前开发程序时，会把内存分成不同的"区"，而对象会创建在某个区里。现在不用了，每个程序只有一个"默认区"(defaultzone)，实现该方法时，不必担心其中的 zone 参数。例如，我们要让自定义的<code>ACLStudent</code> 类支持拷贝功能，则可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@interface ACLStudent : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line">@end</span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">ACLStudent.m</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    ACLStudent *copy = [[[self class] allocWithZone:zone] initWithStudentId:_studentId firstName:_firstName lastName:_lastName];</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上例中 <code>copyWithZone:</code> 方法使用了全能初始化方法(designatedinitializer)来执行拷贝对象的所有初始化工作。这里需要注意，对于未能在全能初始化方法中设置好的变量，需要在<code>copyWithZone:</code> 方法中做特殊处理。例如，如果在<code>ACLStudent</code>类中增加一个变量，来存储当前学生所选选修课的科目，完整代码变成如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@class ACLCourse;</span><br><span class="line">@interface ACLStudent : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">- (void)addElective:(ACLCourse *)course;</span><br><span class="line"></span><br><span class="line">- (void)removeElective:(ACLCourse *)course;</span><br><span class="line">@end</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent &#123;</span><br><span class="line">    NSMutableSet *_electives;  /**&lt; 选修科目 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">        </span><br><span class="line">        _electives = [NSMutableSet new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addElective:(ACLCourse *)course &#123;</span><br><span class="line">    [_electives addObject:course];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeElective:(ACLCourse *)course &#123;</span><br><span class="line">    [_electives removeObject:course];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    ACLStudent *copy = [[[self class] allocWithZone:zone] initWithStudentId:_studentId firstName:_firstName lastName:_lastName];</span><br><span class="line">    copy-&gt;_electives = [[NSMutableSet alloc] initWithSet:_electives copyItems:YES];</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>注意全能初始化方法和 <code>copyWithZone:</code> 方法实现的变化,这里我们对 <code>_electives</code> 对象执行的是深拷贝。</p><p>假如我们想让自定义对象支持 <code>mutableCopy</code>操作，那又应该怎么操作呢?这需要自定义对象遵循<code>NSMutableCopying</code> 协议, 该协议也只有一个方法:</p><p><code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code></p><p>其与 copy 相似，也是使用默认的 zone 参数来调用<code>mutableCopyWithZone:</code>。</p><p>如果类分为可变版本和不可变版本，那么就应该实现<code>NSMutableCopying</code>, 且在可变类中覆写<code>copyWithZone:</code>方法时，应该返回一份不可变的版本。无论当前实例是否可变，若需获取其可变版本的拷贝，均应调用<code>mutableCopy</code> 方法，若需不可变的拷贝，则总应该调用<code>copy</code> 方法。例如对于不可变的 NSArray 和可变的NSMutableArray，以下关系总是成立:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure><hr /><p>如何对 <code>NSArray</code> 执行深拷贝呢？苹果官方文档 <ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html">CopyingCollections</a> 提供了以下两种方法。</p><p>方法1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES];</span><br></pre></td></tr></table></figure><p>这种方式执行拷贝时，<code>someArray</code>中的可变对象是执行深拷贝，而对于不可变对象，仍然执行的是浅拷贝。</p><p>方法2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];</span><br></pre></td></tr></table></figure><p>这种方式实现的是真正意义上的深拷贝，<code>oldArray</code>中所有元素都是深拷贝。</p><p>那么 <code>copy</code> 和 <code>mutableCopy</code>返回的对象是执行的深拷贝还是浅拷贝呢？这篇博客 [copy与mutableCopy][]对系统对象执行 <code>copy</code> 和 <code>mutableCopy</code>时到底执行的深拷贝还是浅拷贝进行了讨论。其中系统对象分为了两类:</p><ul><li>系统的非容器类对象，如<code>NSString</code>、<code>NSMutableString</code>、<code>NSNumber</code>等。</li><li>系统的容器类对象，如<code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>等。</li></ul><p>现把结论摘抄如下:</p><ol type="1"><li>对于系统的非容器类对象，如果对一不可变对象(如<code>NSString</code>)复制，<code>copy</code> 是指针复制(浅拷贝)和<code>mutableCopy</code> 就是对象复制(深拷贝); 如果是对可变对象(如<code>NSMutableString</code>)复制，<code>copy</code> 和<code>mutableCopy</code> 都是深拷贝，但是 <code>copy</code>返回的对象是不可变的。</li><li>对于系统的容器类对象，对不可变对象(如<code>NSArray</code>)进行复制，<code>copy</code> 是指针复制(浅拷贝)，<code>mutableCopy</code> 是对象复制(深拷贝), 但是不管是<code>copy</code> 还是 <code>mutableCopy</code>,且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。</li><li>对于系统的容器类对象，对可变对象(如<code>NSMutableArray</code>)进行复制时，<code>copy</code> 和<code>mutableCopy</code> 都是对象复制(深拷贝)，但是不管是<code>copy</code> 还是<code>mutableCopy</code>，且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。</li></ol><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何让自定义对象支持 copy 操作？是重写 copy
方法么？当然不是，而是需要让自定义类实现 NSCopying
协议，该协议只有一个方法:&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS修改声明为readonly的属性值</title>
    <link href="http://liumh.com/2015/12/08/ios-change-readonly-property/"/>
    <id>http://liumh.com/2015/12/08/ios-change-readonly-property/</id>
    <published>2015-12-08T14:03:24.000Z</published>
    <updated>2024-10-21T14:35:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论的是，对于类中声明为 readonly的属性值，我们就不可以修改其值了么？如何可以，那么如何修改呢？</p><p>为了便于说明，定义一个 <code>ACLStudent</code> 的类:</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@interface ACLStudent : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line">ACLStudent.m</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来定义一个 <code>ACLStudent</code> 类的对象:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACLStudent *student = [[ACLStudent alloc] initWithStudentId:1 firstName:@&quot;Carya&quot; lastName:@&quot;Liu&quot;];</span><br><span class="line">NSLog(@&quot;student firstName: %@&quot;, student.firstName);</span><br></pre></td></tr></table></figure><p>现在我们考虑的就是如何修改 <code>student</code> 对象的<code>firstName</code> 属性值为<code>@"Qiu"</code>。</p><p>如果直接调用 <code>firstName</code> 的 setter方法，<code>student.firstName = @"Qiu"</code>,那么就直接报错，提示不能够给声明为 readonly 的属性赋值。那么使用 KVC呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[student setValue:@&quot;Qiu&quot; forKey:NSStringFromSelector(@selector(firstName))];</span><br><span class="line">NSLog(@&quot;student firstName after changed: %@&quot;, student.firstName);</span><br></pre></td></tr></table></figure><p>运行，发现属性值被成功修改。哈哈，那么现在来看看 KVC为什么能够修改该属性值呢？看看文档 <ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/SearchImplementation.html">AccessorSearch Implementation Details</a>。</p><p>当使用 <code>setValue:forKey:</code>来设置对象的属性时，会以下面的优先顺序来寻找对应的<code>key</code>：</p><ol type="1"><li>消息接收对象会查找是否存在满足 <code>set&lt;Key&gt;:</code>格式的存取方法。</li><li>如果不存在满足条件的存取方法，且消息接收对象的类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回YES，那么该对象会以 <code>_&lt;key&gt;</code>,<code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code> 的顺序查找是否存在对应的key。</li><li>如果存在对应的存取方法或者找到对应的实例变量，那么就会改变该 key所对应的值 value。必要的话，value 所对应的值会从对象中解析出来，如 <ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/DataTypes.html#//apple_ref/doc/uid/20002171-184696">RepresentingNon-Object Values</a> 所描述的那样。</li><li>如果没有找到对应的存取方法或者实例变量，那么该消息对象的<code>setValue:forUndefinedKey:</code> 将会调用。</li></ol><p>对于上述第2点说明一下，如果我们不想让 <code>setValue:forKey:</code>方法改变对象的属性值，那么重写其类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回 NO(该方法默认返回YES，即在不存在满足条件的存取方法时，允许直接访问属性对应的实例变量)；在搜索实例变量时，会首先检查带下划线的实例变量，然后检查不带下划线的实例变量。</p><p>对于上述第3点举例说明，如果修改 <code>student</code> 对象的属性<code>NSInteger studentId</code>, 注意其是 <code>NSInteger</code>类型，我们在调用 <code>setValue:forKey:</code> 方法时可以像这样</p><p><code>[student setValue:@(20) forKey:NSStringFromSelector(@selector(studentId))];</code></p><p>传入一个 <code>NSNumber</code> 对象也可以，Objective-C会处理好一切。</p><p>对于上面的示例，使用 <code>setValue:forKey:</code> 实际修改的是student 实例中 <code>_firstName</code>实例变量的值。不要忘记，我们在声明一个 <code>firstName</code>的属性时，编译器会为我们自动合成一个 <code>_firstName</code>的实例变量。</p><p>总结:</p><ul><li>当我们声明一个 readonly 的属性，外部可能会通过 KVC修改该属性值。</li><li>为了避免 KVC 修改属性值，须将定义属性所在类的类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code> 重写，使其返回NO.</li></ul><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讨论的是，对于类中声明为 readonly
的属性值，我们就不可以修改其值了么？如何可以，那么如何修改呢？&lt;/p&gt;
&lt;p&gt;为了便于说明，定义一个 &lt;code&gt;ACLStudent&lt;/code&gt; 的类:&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="KVC" scheme="http://liumh.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>iOS中这样写注释</title>
    <link href="http://liumh.com/2015/12/07/ios-how-to-documentation/"/>
    <id>http://liumh.com/2015/12/07/ios-how-to-documentation/</id>
    <published>2015-12-07T13:58:31.000Z</published>
    <updated>2024-10-21T14:37:55.806Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录的是如何更好的编写注释。好的注释，可以让使用者能够像使用官方文档一样，使用<code>option + 单击</code> 就可查看其使用说明。</p><span id="more"></span><p>对于枚举类型，可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 定义的HTTP请求类型 */</span><br><span class="line">typedef NS_ENUM(NSUInteger, ACLApiManagerRequestType) &#123;</span><br><span class="line">    ACLApiManagerRequestTypeGet,   /**&lt; Get请求 */</span><br><span class="line">    ACLApiManagerRequestTypePost,  /**&lt; Post请求 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请自行注意注释使用的符号,注释枚举值和枚举类型时使用的符号也有差别。</p><p>对于属性，可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, readonly) NSString *errorMessage;  /**&lt; 错误信息说明 */</span><br></pre></td></tr></table></figure><p>对于方法的注释，强烈建议安装喵神的插件<ahref="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a>。然后在方法上部连续键入<code>///</code>触发插入注释，然后删除placeholder 的地方，填入实际的注释说明，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  &lt;#Description#&gt;</span><br><span class="line"> *</span><br><span class="line"> *  @param manager &lt;#manager description#&gt;</span><br><span class="line"> *  @param data    &lt;#data description#&gt;</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line"> - (BOOL)manager:(ACLAPIBaseManager *)manager isCorrectWithParamsData:(NSDictionary *)data;</span><br></pre></td></tr></table></figure><p>但是对于没有参数的方法，或者我们觉得方法的命名自解释已经很清楚了，则可以像如下注释:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** API 请求除 base url 之外的 url部分 */</span><br><span class="line">- (NSString *)methodName;</span><br></pre></td></tr></table></figure><p>使用 <code>|</code> 来引用注释中的变量名及符号名而不是使用引号。</p><p>这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号<code>count</code> ：</p><p><code>// Sometimes we need |count| to be less than zero.</code></p><p>参考:</p><p><a href="http://nshipster.com/documentation/">Documentation</a></p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录的是如何更好的编写注释。好的注释，可以让使用者能够像使用官方文档一样，使用
&lt;code&gt;option + 单击&lt;/code&gt; 就可查看其使用说明。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动打包并发布脚本</title>
    <link href="http://liumh.com/2015/11/25/ios-auto-archive-ipa/"/>
    <id>http://liumh.com/2015/11/25/ios-auto-archive-ipa/</id>
    <published>2015-11-25T13:38:11.000Z</published>
    <updated>2024-10-21T14:27:49.991Z</updated>
    
    <content type="html"><![CDATA[<p>本文最终实现的是使用脚本打 Ad-hoc包，并发布测试，当然稍微修改一下脚本参数就可以打其他类型的 ipa包了。另外该脚本还实现了将生成的 ipa 包上传至蒲公英进行测试分发。</p><span id="more"></span><ol type="1"><li><a href="#xcodebuild-简介">xcodebuild 简介</a></li><li><ahref="#使用xcodebuild和xcrun打包签名">使用xcodebuild和xcrun打包签名</a></li><li><a href="#将打包过程脚本化">将打包过程脚本化</a></li></ol><h2 id="xcodebuild-简介">xcodebuild 简介</h2><p><code>xcodebuild</code>是苹果提供的打包项目或者工程的命令，了解该命令最好的方式就是使用<code>man xcodebuild</code> 查看其 man page.尽管是英文，一定要老老实实的读一遍就好了。</p><blockquote><p>DESCRIPTION</p><p>xcodebuild builds one or more targets contained in an Xcode project,or builds a scheme contained in an Xcode workspace or Xcode project.</p><p>Usage</p><p>To build an Xcode project, run xcodebuild from the directorycontaining your project (i.e. the directory containing thename.xcodeproj package). If you have multiple projects in the thisdirectory you will need to use -project to indicate which project shouldbe built. By default, xcodebuild builds the first target listed in theproject, with the default build configuration. The order of the targetsis a property of the project and is the same for all users of theproject.</p><p>To build an Xcode workspace, you must pass both the -workspace and-scheme options to define the build. The parameters of the scheme willcontrol which targets are built and how they are built, although you maypass other options to xcodebuild to override some parameters of thescheme.</p><p>There are also several options that display info about the installedversion of Xcode or about projects or workspaces in the local directory,but which do not initiate an action. These include -list,-showBuildSettings, -showsdks, -usage, and -version.</p></blockquote><p>总结一下:</p><ol type="1"><li>需要在包含 name.xcodeproj 的目录下执行 <code>xcodebuild</code>命令，且如果该目录下有多个 projects，那么需要使用 <code>-project</code>指定需要 build 的项目。</li><li>在不指定 build 的 target 的时候，默认情况下会 build project下的第一个 target</li><li>当 build workspace 时，需要同时指定 <code>-workspace</code> 和<code>-scheme</code> 参数，scheme 参数控制了哪些 targets 会被 build以及以怎样的方式 build。</li><li>有一些诸如 <code>-list</code>, <code>-showBuildSettings</code>,<code>-showsdks</code> 的参数可以查看项目或者工程的信息，不会对 buildaction 造成任何影响，放心使用。</li></ol><p>那么，<code>xcodebuild</code> 究竟如何使用呢？ 继续看文档:</p><blockquote><p>NAME</p><p>xcodebuild -- build Xcode projects and workspaces</p><p>SYNOPSIS</p><ol type="1"><li><p>xcodebuild [-project name.xcodeproj] [[-target targetname] ... |-alltargets] [-configuration configurationname] [-sdk [sdkfullpath |sdkname]] [action ...] [buildsetting=value ...] [-userdefault=value...]</p></li><li><p>xcodebuild [-project name.xcodeproj] -scheme schemename[[-destination destinationspecifier] ...] [-destination-timeout value][-configuration configurationname] [-sdk [sdkfullpath | sdkname]][action ...] [buildsetting=value ...] [-userdefault=value ...]</p></li><li><p>xcodebuild -workspace name.xcworkspace -scheme schemename[[-destination destinationspecifier] ...] [-destination-timeout value][-configuration configurationname] [-sdk [sdkfullpath | sdkname]][action ...] [buildsetting=value ...] [-userdefault=value ...]</p></li><li><p>xcodebuild -version [-sdk [sdkfullpath | sdkname]][infoitem]</p></li><li><p>xcodebuild -showsdks</p></li><li><p>xcodebuild -showBuildSettings [-project name.xcodeproj |[-workspace name.xcworkspace -scheme schemename]]</p></li><li><p>xcodebuild -list [-project name.xcodeproj | -workspacename.xcworkspace]</p></li><li><p>xcodebuild -exportArchive -archivePath xcarchivepath -exportPathdestinationpath -exportOptionsPlist path</p></li><li><p>xcodebuild -exportLocalizations -project name.xcodeproj-localizationPath path [[-exportLanguage language] ...]</p></li><li><p>xcodebuild -importLocalizations -project name.xcodeproj-localizationPath path</p></li></ol></blockquote><p>挑几个我常用的形式介绍一下，较长的使用方式以序列号代替:</p><ul><li><p><code>xcodebuild -showsdks</code>: 列出 Xcode 所有可用的SDKs</p></li><li><p><code>xcodebuild -showBuildSettings</code>:上述序号6的使用方式，查看当前工程 build setting 的配置参数，Xcode 详细的build setting 参数参考官方文档 <ahref="https://developer.apple.com/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/">XcodeBuild Setting Reference</a>， 已有的配置参数可以在终端中以<code>buildsetting=value</code> 的形式进行覆盖重新设置.</p></li><li><p><code>xcodebuild -list</code>: 上述序号7的使用方式，查看 project中的 targets 和 configurations，或者 workspace 中 schemes,输出如下:</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Information about project &quot;NavTabBar&quot;:</span><br><span class="line">    Targets:</span><br><span class="line">        NavTabBar</span><br><span class="line">        NavTabBarTests</span><br><span class="line">        NavTabBarUITests</span><br><span class="line"></span><br><span class="line">    Build Configurations:</span><br><span class="line">        Debug</span><br><span class="line">        Release</span><br><span class="line">        Ad-hoc</span><br><span class="line"></span><br><span class="line">    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.</span><br><span class="line"></span><br><span class="line">    Schemes:</span><br><span class="line">        NavTabBar</span><br></pre></td></tr></table></figure><ul><li><p><code>xcodebuild [-project name.xcodeproj] [[-target targetname] ... | -alltargets] build</code>:上述序号1的使用方式，会 build 指定 project，其中 <code>-target</code> 和<code>-configuration</code> 参数可以使用 <code>xcodebuild -list</code>获得，<code>-sdk</code> 参数可由 <code>xcodebuild -showsdks</code>获得，<code>[buildsetting=value ...]</code>用来覆盖工程中已有的配置。可覆盖的参数参考官方文档 <ahref="https://developer.apple.com/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/">XcodeBuild Setting Reference</a>, <code>action...</code> 的可用选项如下,打包的话当然用 build，这也是默认选项。</p><ul><li><p>build<br />Build the target in the build root (SYMROOT). This is the defaultaction, and is used if no action is given.</p></li><li><p>analyze<br />Build and analyze a target or scheme from the build root (SYMROOT). Thisrequires specifying a scheme.</p></li><li><p>archive<br />Archive a scheme from the build root (SYMROOT). This requires specifyinga scheme.</p></li><li><p>test<br />Test a scheme from the build root (SYMROOT). This requires specifying ascheme and optionally a destination.</p></li><li><p>installsrc<br />Copy the source of the project to the source root (SRCROOT).</p></li><li><p>install<br />Build the target and install it into the target's installation directoryin the distribution root (DSTROOT).</p></li><li><p>clean<br />Remove build products and intermediate files from the build root(SYMROOT).</p></li></ul></li><li><p><code>xcodebuild -workspace name.xcworkspace -scheme schemename build</code>:上述序号3的使用方式，build 指定 workspace，当我们使用 CocoaPods来管理第三方库时，会生成 xcworkspace文件，这样就会用到这种打包方式.</p></li></ul><h2id="使用xcodebuild和xcrun打包签名">使用xcodebuild和xcrun打包签名</h2><p>开始之前，可以新建一个测试工程 TestImg来练习打包，在使用终端命令打包之前，请确认该工程也可以直接使用 Xcode真机调试成功。</p><p>然后，打开终端，进入包含 TestImg.xcodeproj的目录下，运行以下命令:</p><p><code>xcodebuild -project TestImg.xcodeproj -target TestImg -configuration Release</code></p><p>如果 build 成功，会看到 <code>** BUILD SUCCEEDED **</code>字样，且在终端会打印出这次 build 的签名信息，如下:</p><blockquote><p>Signing Identity: "iPhone Developer: xxx(59xxxxxx)"<br />Provisioning Profile: "iOS Team Provisioning Profile: *"</p></blockquote><p>且在该目录下会多出一个 <code>build</code> 目录，该目录下有<code>Release-iphoneos</code> 和 <code>TestImg.build</code>文件，根据我们 build <code>-configuration</code>配置的参数不同，<code>Release-iphoneos</code> 的文件名会不同。</p><p>在 <code>Release-iphoneos</code>文件夹下，有我们需要的<code>TestImg.app</code>文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用xcrun 命令。</p><p><code>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/TestImg.app -o ~/Desktop/TestImg.ipa</code></p><p>这里又冒出一个 <code>PackageApplication</code>,我刚开始也不知道这是个什么玩意儿，万能的google告诉我，这是 Xcode包里自带的工具，使用<code>xcrun -sdk iphoneos -v PackageApplication -help</code>查看帮助信息.</p><blockquote><p>Usage:<br />PackageApplication [-s signature] application [-o output_directory][-verbose] [-plugin plugin] || -man || -help</p><p>Options:</p><p><code>[-s signature]</code>: certificate name to resign applicationbefore packaging<br /><code>[-o output_directory]</code>: specify output filename<br /><code>[-plugin plugin]</code>: specify an optional plugin<br /><code>-help</code>: brief help message<br /><code>-man</code>: full documentation<br /><code>-v[erbose]</code>: provide details during operation</p></blockquote><p>如果执行成功，则会在你的桌面生成 TestImg.ipa文件，这样就可以发布测试了。如果你遇到以下警告信息:</p><blockquote><p>Warning: --resource-rules has been deprecated in Mac OS X &gt;=10.10! ResourceRules.plist: cannot read resources</p></blockquote><p>请参考 stackoverflow <ahref="http://stackoverflow.com/questions/32504355/error-itms-90339-this-bundle-is-invalid-the-info-plist-contains-an-invalid-ke/32762413#32762413">这个回答</a></p><h2 id="将打包过程脚本化">将打包过程脚本化</h2><p>工作中，特别是所做项目进入测试阶段，肯定会经常打 Ad-hoc包给测试人员进行测试，但是我们肯定不想每次进行打包的时候都要进行一些工程的设置修改，以及一系列的next 按钮点击操作，现在就让这些操作都交给脚本化吧。</p><ol type="1"><li>脚本化中使用如下的命令打包:</li></ol><p><code>xcodebuild -project name.xcodeproj -target targetname -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY="$(CODE_SIGN_IDENTITY)" PROVISIONING_PROFILE="$(PROVISIONING_PROFILE)"</code></p><p>或者</p><p><code>xcodebuild -workspace name.xcworkspace -scheme schemename -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY="$(CODE_SIGN_IDENTITY)" PROVISIONING_PROFILE="$(PROVISIONING_PROFILE)"</code></p><ol start="2" type="1"><li>然后使用 xcrun 生成 ipa 文件:</li></ol><p>`xcrun -sdk iphoneos -v PackageApplication./build/Release-iphoneos/$(target|scheme).app"</p><ol start="3" type="1"><li>清除 build 过程中产生的中间文件</li><li>结合蒲公英分发平台，将 ipa文件上传至蒲公英分发平台，同时在终端会打印上传结果以及上传应用后该应用的URL。蒲公英分发平台能够方便地将 ipa 文件尽快分发到测试人员，该平台有开放API，可避免人工上传。</li></ol><p>该脚本的使用可使用 <code>python autobuild.py -h</code> 查看，与<code>xcodebuild</code> 的使用相似:</p><blockquote><p>Usage: autobuild.py [options]</p><p>Options:<br /><code>-h, --help</code>: show this help message and exit<br /><code>-w name.xcworkspace, --workspace=name.xcworkspace</code>: Buildthe workspace name.xcworkspace.<br /><code>-p name.xcodeproj, --project=name.xcodeproj</code>: Build theproject name.xcodeproj.<br /><code>-s schemename, --scheme=schemename</code>: Build the schemespecified by schemename. Required if building a workspace.<br /><code>-t targetname, --target=targetname</code>: Build the targetspecified by targetname. Required if building a project.<br /><code>-o output_filename, --output=output_filename</code>: specifyoutput filename</p></blockquote><p>在脚本顶部，有几个全局变量，根据自己的项目情况修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CODE_SIGN_IDENTITY = &quot;iPhone Distribution: companyname (9xxxxxxx9A)&quot;</span><br><span class="line">PROVISIONING_PROFILE = &quot;xxxxx-xxxx-xxx-xxxx-xxxxxxxxx&quot;</span><br><span class="line">CONFIGURATION = &quot;Release&quot;</span><br><span class="line">SDK = &quot;iphoneos&quot;</span><br><span class="line"></span><br><span class="line">USER_KEY = &quot;15d6xxxxxxxxxxxxxxxxxx&quot;</span><br><span class="line">API_KEY = &quot;efxxxxxxxxxxxxxxxxxxxx&quot;</span><br></pre></td></tr></table></figure><p>其中，<code>CODE_SIGN_IDENTITY</code> 为开发者证书标识，可以在Keychain Access -&gt; Certificates -&gt; 选中证书右键弹出菜单 -&gt; GetInfo -&gt; Common Name 获取，类似<code>iPhone Distribution: Company name Co. Ltd (xxxxxxxx9A)</code>,包括括号内的内容。</p><p><code>PROVISIONING_PROFILE</code>: 这个是 mobileprovision 文件的identifier，获取方式：</p><p>Xcode -&gt; Preferences -&gt; 选中申请开发者证书的 Apple ID -&gt;选中开发者证书 -&gt; View Details... -&gt; 根据 Provisioning Profiles的名字选中打包所需的 mobileprovision 文件 -&gt; 右键菜单 -&gt; Show inFinder -&gt; 找到该文件后，除了该文件后缀名的字符串就是<code>PROVISIONING_PROFILE</code> 字段的内容。</p><p>当然也可以使用脚本获取, 此处参考 <ahref="http://my.oschina.net/ioslighter/blog/494342">命令行获取mobileprovision文件的UUID</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;Usage: getmobileuuid the-mobileprovision-file-path&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">mobileprovision_uuid=`/usr/libexec/PlistBuddy -c &quot;Print UUID&quot; /dev/stdin &lt;&lt;&lt; $(/usr/bin/security cms -D -i $1)`</span><br><span class="line">echo &quot;UUID is:&quot;</span><br><span class="line">echo $&#123;mobileprovision_uuid&#125;</span><br></pre></td></tr></table></figure><p><code>USER_KEY</code>, <code>API_KEY</code>: 是蒲公英开放 API的密钥。</p><p>将<code>autobuild.py</code>脚本放在你项目的根目录下，进入根目录，如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./autobuild.py -w yourname.xcworkspace -s schemename -o ~/Desktop/yourname.ipa</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./autobuild.py -p yourname.xcodeproj -t targetname -o ~/Desktop/yourname.ipa</span><br></pre></td></tr></table></figure><p>该脚本可在 <a href="https://github.com/carya/Util.git">github</a>查看，如有任何问题，请留言回复。</p><hr /><p>常见问题:</p><ol type="1"><li><p>找不到<em>request module</em>. <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">ImportError: No module named requests</span><br></pre></td></tr></table></figure> 找不到<em>requestmodule</em>，参考<ahref="http://stackoverflow.com/questions/17309288/importerror-no-module-named-requests">stackoverflow</a>,使用<code>$ sudo pip install requests</code>或者<code>sudo easy_install -U requests</code>;</p></li><li><p>如果使用了上传蒲公英，且安装需要密码，请打开脚本，搜一下脚本里的<em>password</em>，将其值设置为空。</p></li></ol><p>========== update 2016-12-28 ==========</p><p>github上脚本进行更新：</p><ol type="1"><li>使用<code>xcodebuild -exportArchive</code>替换<em>PackageApplication</em>进行打包.</li><li>解析传入参数使用<em>argparse</em>替换<em>OptionParser</em>.</li><li>去掉对<em>PROVISIONING_PROFILE</em>和<em>CODE_SIGN_IDENTITY</em>的配置，请使用<em>Xcode8</em>的自动证书管理。</li><li>新增<em>exportOptions.plist</em>文件，用于设置导出<em>ipa</em>文件的参数，该文件中的可配置参数可使用<code>xcodebuild --help</code>查看。</li><li>脚本传入参数去掉<code>--target</code>和<code>--output</code>，<em>ipa</em>文件默认会存放在<em>Desktop</em>创建诸如<em>{scheme}{2016-12-28_08-08-10}</em>格式的文件夹中。</li></ol><p>假如你的项目目录如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|____AOP</span><br><span class="line">| |____AppDelegate.h</span><br><span class="line">| |____AppDelegate.m</span><br><span class="line">| |____Base.lproj</span><br><span class="line">| | |____LaunchScreen.xib</span><br><span class="line">| | |____Main.storyboard</span><br><span class="line">| |____Images.xcassets</span><br><span class="line">| |____Info.plist</span><br><span class="line">| |____main.m</span><br><span class="line">| |____ViewController.h</span><br><span class="line">| |____ViewController.m</span><br><span class="line">|____AOP.xcodeproj</span><br><span class="line">|____autobuild</span><br><span class="line">| |____autobuild.py</span><br><span class="line">| |____exportOptions.plist</span><br></pre></td></tr></table></figure><p>先进入<em>autobuild</em>目录，使用脚本打包的命令如下:</p><p><code>python autobuild.py -p ../AOP.xcodeproj -s AOP</code></p><p>脚本执行完毕，若成功，则会在桌面生成<em>ipa</em>文件。</p><p>若是打包<em>xcworkspace</em>项目，则打包命令格式如下所示:</p><p><code>python autobuild.py -w ../yourworkspace.xcworkspace -s yourscheme</code></p><p><em>exportOptions.plist</em>文件中的可选配置参数如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">compileBitcode : Bool</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">embedOnDemandResourcesAssetPacksInBundle : Bool</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, if the app uses On Demand Resources and this is YES, asset   </span><br><span class="line">  packs are embedded in the app bundle so that the app can be tested without a server to   </span><br><span class="line">  host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.</span><br><span class="line"></span><br><span class="line">iCloudContainerEnvironment</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, if the app is using CloudKit, this configures the   </span><br><span class="line">  &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options:   </span><br><span class="line">  Development and Production. Defaults to Development.</span><br><span class="line"></span><br><span class="line">manifest : Dictionary</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, users can download your app over the web by opening your   </span><br><span class="line">  distribution manifest file in a web browser. To generate a distribution manifest, the   </span><br><span class="line">  value of this key should be a dictionary with three sub-keys: appURL, displayImageURL,   </span><br><span class="line">  fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.</span><br><span class="line"></span><br><span class="line">method : String</span><br><span class="line"></span><br><span class="line">  Describes how Xcode should export the archive. Available options: app-store, ad-hoc,   </span><br><span class="line">  package, enterprise, development, and developer-id. The list of options varies based on   </span><br><span class="line">  the type of archive. Defaults to development.</span><br><span class="line"></span><br><span class="line">onDemandResourcesAssetPacksBaseURL : String</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, if the app uses On Demand Resources and   </span><br><span class="line">  embedOnDemandResourcesAssetPacksInBundle isn&#x27;t YES, this should be a base URL specifying   </span><br><span class="line">  where asset packs are going to be hosted. This configures the app to download asset   </span><br><span class="line">  packs from the specified URL.</span><br><span class="line"></span><br><span class="line">teamID : String</span><br><span class="line"></span><br><span class="line">  The Developer Portal team to use for this export. Defaults to the team used to build the archive.</span><br><span class="line"></span><br><span class="line">thinning : String</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, should Xcode thin the package for one or more device   </span><br><span class="line">  variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app),   </span><br><span class="line">  &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned   </span><br><span class="line">  variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.</span><br><span class="line"></span><br><span class="line">uploadBitcode : Bool</span><br><span class="line"></span><br><span class="line">  For App Store exports, should the package include bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">uploadSymbols : Bool</span><br><span class="line"></span><br><span class="line">  For App Store exports, should the package include symbols? Defaults to YES.</span><br></pre></td></tr></table></figure><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文最终实现的是使用脚本打 Ad-hoc
包，并发布测试，当然稍微修改一下脚本参数就可以打其他类型的 ipa
包了。另外该脚本还实现了将生成的 ipa 包上传至蒲公英进行测试分发。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈iOS中的命名规范</title>
    <link href="http://liumh.com/2015/11/19/ios-talk-naming-guide/"/>
    <id>http://liumh.com/2015/11/19/ios-talk-naming-guide/</id>
    <published>2015-11-19T14:59:16.000Z</published>
    <updated>2024-10-21T14:45:52.304Z</updated>
    
    <content type="html"><![CDATA[<p>本文谈谈 iOS开发中的命名规范，主要涉及常量命名、枚举命名、类及其方法命名，以及分类及其方法命名。如果你找的是官网的编码规范，请移步:<ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH">CodingGuidelines for Cocoa</a>。当然本文会讲一些官网没有的东西。</p><span id="more"></span><ul><li>常量命名</li><li>用枚举表示状态、选项、状态码</li><li>类及其方法命名</li><li>分类及其方法命名</li></ul><h1 id="常量命名">常量命名</h1><p>iOS开发中，肯定避免不了要命名一些常量，那么，我们应该怎样来命名常量呢？</p><p>在讨论上述问题前，先来了解定义常量的两种方式。</p><p>第一种，使用 <code>#define</code> 预处理定义常量。例如：</p><p><code>#define ANIMATION_DURATION 0.3</code></p><p>定义一个 <code>ANIMATION_DURATION</code> 常量来表示 UI动画的一个常量时间，这样，代码中所有使用 <code>ANIMATION_DURATION</code>的地方都会被替换成0.3，但是这样定义的常量无类型信息，且如果你在调试时想要查看<code>ANIMATION_DURATION</code>的值却无从下手，因为在预处理阶段<code>ANIMATION_DURATION</code>就已经被替换了，不便于调试。因此，弃用这种方式定义常量。</p><p>第二种，使用类型常量。将上面的预处理定义常量修改成类型常量:</p><p><code>static const NSTimeInterval kAnimationDuration = 0.3;</code></p><p>这样就为常量带入了类型信息，那么定义类型常量又有什么规范呢？</p><ul><li>对于局限于某编译单元(实现文件)的常量，通常以字符<code>k</code>开头，例如上文中的<code>kAnimationDuration</code>，且需要以 <code>static const</code>修饰，例如:</li></ul><p><code>static const NSTimeInterval kAnimationDuration = 0.3;</code></p><ul><li>对于定义于类头文件的常量，外部可见，则通常以定义该常量所在类的类名开头，例如<code>EOCViewClassAnimationDuration</code>, 仿照苹果风格，在头文件中进行extern 声明，在实现文件中定义其值:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EOCViewClass.h</span><br><span class="line"></span><br><span class="line">extern const NSTimeInterval EOCViewClassAnimationDuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EOCViewClass.m</span><br><span class="line"></span><br><span class="line">const NSTimeInterval EOCViewClassAnimationDuration = 0.3;</span><br></pre></td></tr></table></figure><p>对于字符串常量，则会像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EOCViewClass.h</span><br><span class="line"></span><br><span class="line">extern NSString *const EOCViewClassStringConstant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EOCViewClass.m</span><br><span class="line"></span><br><span class="line">NSString *const EOCViewClassStringConstant = @&quot;EOCStringConstant&quot;;</span><br></pre></td></tr></table></figure><p>常量定义是从右往左解读，上面的示例中就是定义了一个常量指针，其指向一个NSString 对象,这样该常量就不会被随意修改。至于这种暴露出来的类常量最前面是否加上字母<code>k</code>,可以根据自己习惯在团队中进行约定，因为从 iOS的接口中我看到这两种情况都有, 如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *const UIApplicationLaunchOptionsRemoteNotificationKey;</span><br><span class="line">NSString *const UIApplicationLaunchOptionsLocalNotificationKey;</span><br></pre></td></tr></table></figure><p>还有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *const kCAAnimationCubic;</span><br><span class="line">NSString *const kCAAnimationCubicPaced;</span><br></pre></td></tr></table></figure><h1 id="用枚举表示状态选项状态码">用枚举表示状态、选项、状态码</h1><p>项目中，可用枚举来表示一系列的状态、选项和状态码。例如 iOS SDK 中表示UICollectionView 滑动方向的枚举定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123;</span><br><span class="line">    UICollectionViewScrollDirectionVertical,</span><br><span class="line">    UICollectionViewScrollDirectionHorizontal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者定义 UITableView Style 的枚举:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITableViewStyle) &#123;</span><br><span class="line">    UITableViewStylePlain,      // regular table view</span><br><span class="line">    UITableViewStyleGrouped     // preferences style table view</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里可以看出，定义的枚举类型名称应以 2~3个大写字母开头，而这通常与项目设置的类文件前缀相同，跟随其后的命名应采用驼峰命名法则，命名应准确表述枚举表示的意义，枚举中各个值都应以定义的枚举类型开头，其后跟随各个枚举值对应的状态、选项或者状态码。</p><p>对于需要以按位或操作来组合的枚举都应使用 NS_OPTIONS 宏来定义，例如SDK 中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class="line">    UIViewAutoresizingNone                 = 0,</span><br><span class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</span><br><span class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</span><br><span class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</span><br><span class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</span><br><span class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</span><br><span class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的选项能够以 <strong>按位或操作符</strong>来进行组合，枚举中每个值均可启用或者禁用某一选项，在使用时，可以使用<strong>按位与操作符</strong> 来检测是否启用了某一选项，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</span><br><span class="line"></span><br><span class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;</span><br><span class="line">// UIViewAutoresizingFlexibleWidth is set</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可能使用 switch 语句时，会在最后加上 default分支，但是若用枚举定义状态机，则最好不要使用 default分支，因为如果稍后再加了一种状态，那么编译器就会发出警告，提示新加入的状态并未在switch 分支中处理。假如写上了 default分支，那么它就会处理这个新状态，从而导致编译器不发出警告，用 NS_ENUM定义其他枚举类型时也要注意此问题。例如在定义代表 UI元素样式的枚举时，通常要确保 switch 语句能正确处理所有样式。</p><p>总结一下:</p><ul><li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。</li><li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2 的幂，以便通过按位或操作将其组合起来。</li><li>用 NS_ENUM 与 NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样就可以确保枚举是用开发者所选的底层数据类型实现出来的，而不是采用编译器所选的类型。</li><li>在处理枚举类型的 switch 语句中不要实现 default分支。这样加入新的枚举值之后，编译器就会发出警告提示，switch还有未处理的枚举值。</li></ul><h1 id="类及其方法命名">类及其方法命名</h1><p>Objective-C没有其他语言那种内置的命名空间(namespace)机制。因此，我们在起名时要设法避免潜在的命名冲突，否则很容易就重名了。避免此问题的唯一方法就是变相实现命名空间:为所有名称都加上适当前缀。所选前缀可以是与公司、应用程序或者二者皆有关联的名字。使用Cocoa 和 Cocoa Touch 创建应用程序时一定要注意，Apple宣传其保留使用所有"两个字母前缀"(tow-letterprefixed)的权利。所以你自己选用的前缀应该是三个字母的。你可以在苹果官网<ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html">ClassNames Must Be Unique Across an Entire App</a> 看到上述说明:</p><blockquote><p>In order to keep class names unique, the convention is to useprefixes on all classes. You’ll have noticed that Cocoa and Cocoa Touchclass names typically start either with NS or UI. Two-letter prefixeslike these are reserved by Apple for use in framework classes.</p><p>Your own classes should use three letter prefixes. These might relateto a combination of your company name and your app name, or even aspecific component within your app.</p><p>You should also name your classes using a noun that makes it clearwhat the class represents, like these examples from Cocoa and CocoaTouch:</p><div class="line-block">NSWindow | CAAnimation | NSWindowController |NSManagedObjectContext</div></blockquote><p>另外，在文档 <ahref="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH">CodingGuidelines for Cocoa</a> 中提到:</p><blockquote><p>Use prefixes when naming classes, protocols, functions, constants,and typedef structures. Do not use prefixes when naming methods; methodsexist in a name space created by the class that defines them. Also,don’t use prefixes for naming the fields of a structure.</p></blockquote><p>这里需要说明两点:</p><ul><li>上述所说的<code>functions</code>指的是纯 C 函数。对于纯 C函数和全局变量，不论其处于头文件或者其实现文件中，在编译好的目标文件中，这些名称要算作"顶级符号"(top-levelsymbol)的。因此我们总应该为这种 C 函数的名字加上前缀。通常情况下，这类 C函数我们可以以定义其类的名字作为前缀。这样，在调试时，若此符号出现在栈回溯信息中，则很容易就能判明问题源自哪块代码。例如:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ACLSoundPlayer.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ACLSoundPlayer : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ACLSoundPlayer.m</span><br><span class="line"></span><br><span class="line">#import &quot;ACLSoundPlayer.h&quot;</span><br><span class="line">#import &lt;AudioToolbox/AudioToolbox.h&gt;</span><br><span class="line"></span><br><span class="line">void ACLSoundPlayerCompletion(SystemSoundID ssID, void *clientData) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation ACLSoundPlayer</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>上述引用说到不应该为 Objective-C methods添加前缀，我觉得应该添加一个例外，当我们定义分类中的方法时，则总应该为其添加前缀，这会在下一条详细说明。</li></ul><p>最后一种情况，若为第三库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用时，你应该给你所用的那份第三方库代码都加上你自己的前缀。为便于说明，假如你要发布的程序库叫EOCLibrary，你所使用的第三方库叫 XYZLibrary，则你应该把你使用的XYZLibrary 中所有名字都冠以 <code>EOC</code>, 成为<code>EOCXYZLibrary</code>, 原因如下:</p><ul><li>你的程序所包含的那个第三方库也许还会为应用程序本身所引入。</li><li>你可能会想，让应用程序本身不要直接引入 XYZLibrary，改用 EOCLibrary中使用的那个，但是，应用程序也许还会引入另一个名为 ABCLibrary的第三方库，而该库中又包含了 XYZLibrary。此时，如果你和 ABCLibrary的作者都不给各自所用的 XYZLibrary加前缀，那么应用程序依然会出现重复符号错误。</li><li>你的库里所引用的第三方库是 X 版本的，而应用程序却需要引用第三库的 Y版本的功能。</li></ul><p>对于类中的方法命名，应遵循以下规则:</p><ul><li>如果方法的返回值是新建的，那么方法名的首个词应是返回值的类型，例如:<code>+stringWithString:</code>。除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式。</li><li>BOOL属性应加 is 前缀。如果某方法返回非属性的 Boolean值，那么应该根据你功能，选用 has 或 is 当前缀。</li></ul><h1 id="分类及其方法命名">分类及其方法命名</h1><p>分类机制通常用于向无源码的既有类中新增功能。分类中的方法是直接加在类里面的，它们就好比这个类固有的方法，将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。如果类中本来就有此方法，而分类中又实现了一次，那么分类中的方法会覆盖原来那一份实现代码。实际上可能会发生很多次覆盖，比如某个分类中的方法覆盖了"主实现"中的相关方法，而另外一个分类中的方法又覆盖了这个分类中的方法，多次覆盖的结果以最后一个分类为准。当有多份实现时，无法确定运行时使用的是那份实现。由这样引发的bug 很难追查。</p><p>那么，如何来最大限度的避免这种覆盖呢?</p><p>在 iOS开发中，没有命名空间的概念。通常，我们通过为项目中所有类命名加上特有的前缀来实现命名空间的功能，来避免可能发生的与使用第三方库中的方法命名相同。同样的，这里我们也是为分类，以及分类中的所有方法都加上特定前缀。这个前缀应该与应用程序库中其他地方所用的前缀相同，通常会使用公司名或应用程序名来做决定。例如来编写一个判断对象是否为空的分类方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSObject+ACLNetworkingMethods.h</span><br><span class="line"></span><br><span class="line">@interface NSObject (ACLNetworkingMethods)</span><br><span class="line"></span><br><span class="line">- (BOOL)acl_isEmptyObject;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里为分类名以及分类中的方法加上了 <code>ACL</code>的前缀。注意在方法中，需前缀小写。</p><p>另外，使用分类时，不要刻意覆写分类中的方法，尤其是当你把代码发布为程序库供其他开发者使用时，因为你无法决定其他开发者需要的是方法哪份实现。</p><p>总结:</p><ul><li>向第三方类中添加分类时，总应该给分类名称加上你专有的前缀，前缀须大写。</li><li>向第三方类中添加分类时，总应该给分类中的方法名加上你专有的前缀，前缀须小写，且以下划线连接前缀与方法名。</li></ul><hr /><p>本文内容主要来自[编写高质量iOS与OS X代码的52个有效方法]一书，欢迎留言交流。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文谈谈 iOS
开发中的命名规范，主要涉及常量命名、枚举命名、类及其方法命名，以及分类及其方法命名。如果你找的是官网的编码规范，请移步:
&lt;a
href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH&quot;&gt;Coding
Guidelines for Cocoa&lt;/a&gt;。当然本文会讲一些官网没有的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS屏幕适配</title>
    <link href="http://liumh.com/2015/10/21/ios-image-related-matching/"/>
    <id>http://liumh.com/2015/10/21/ios-image-related-matching/</id>
    <published>2015-10-21T14:16:35.000Z</published>
    <updated>2024-10-21T14:38:12.210Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，屏幕适配也是项很重要的工作，本文记录了一些在屏幕适配的过程中与图片相关的工作。</p><h3 id="基本概念">基本概念</h3><p>首先，理解几个概念: Points, Rendered Pixels, Physical Pixels,Physical Device。</p><ul><li>Points:是iOS开发中引入的抽象单位，称作点。开发过程中所有基于坐标系的绘制都是以point 作为单位，在iPhone 2G,3G,3GS的年代，point和屏幕上的像素是完全一一对应的，即 320 * 480 (points), 也是 320 * 480(pixels)</li><li>Rendered Pixels: 渲染像素， 以 point 为单位的绘制最终都会渲染成pixels，这个过程被称为光栅化。基于 point的坐标系乘以比例因子可以得到基于像素的坐标系，高比例因子会使更多的细节展示，目前的比例因子会是1x，2x，3x</li><li>Physical Pixels: 物理像素，就是设备屏幕实际的像素</li><li>Physical Device: 设备屏幕的物理长度，使用英寸作为单位。比如iPhone4屏幕是3.5英寸，iPhone 5 是4英寸，iphone6是4.7英寸，这里的数字是指手机屏幕对角线的物理长度。实际上会是PhysicalPixels的像素值(而不是Rendered Pixels的像素值)会渲染到该屏幕上, 屏幕会有PPI(pixels-per-inch) 的特性，PPI 的值告诉你每英寸会有多少像素渲染。</li></ul><span id="more"></span><p>那么，iOS 开发中，上述单位会有什么对应关系呢？列表回答:</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr><th style="text-align: center;">机型</th><th style="text-align: center;">屏幕宽高(point)</th><th style="text-align: center;">渲染像素(pixel)</th><th style="text-align: center;">物理像素(pixel)</th><th style="text-align: center;">屏幕对角线长度(英寸)</th><th style="text-align: center;">屏幕模式</th></tr></thead><tbody><tr><td style="text-align: center;">iPhone 2G, 3G, 3GS</td><td style="text-align: center;">320 * 480</td><td style="text-align: center;">320 * 480</td><td style="text-align: center;">320 * 480</td><td style="text-align: center;">3.5(163PPI)</td><td style="text-align: center;">1x</td></tr><tr><td style="text-align: center;">iPhone 4, 4s</td><td style="text-align: center;">320 * 480</td><td style="text-align: center;">640 * 960</td><td style="text-align: center;">640 * 960</td><td style="text-align: center;">3.5 (326PPI)</td><td style="text-align: center;">2x</td></tr><tr><td style="text-align: center;">iPhone 5, 5s</td><td style="text-align: center;">320 * 568</td><td style="text-align: center;">640 * 1136</td><td style="text-align: center;">640 * 1136</td><td style="text-align: center;">4 (326PPI)</td><td style="text-align: center;">2x</td></tr><tr><td style="text-align: center;">iPhone 6, 6s</td><td style="text-align: center;">375 * 667</td><td style="text-align: center;">750 * 1334</td><td style="text-align: center;">750 * 1334</td><td style="text-align: center;">4.7 (326PPI)</td><td style="text-align: center;">2x</td></tr><tr><td style="text-align: center;">iPhone 6 Plus, 6s Plus</td><td style="text-align: center;">414 * 736</td><td style="text-align: center;">1242 * 2208</td><td style="text-align: center;">1080 * 1920</td><td style="text-align: center;">5.5 (401PPI)</td><td style="text-align: center;">3x</td></tr></tbody></table><p>关于上述关系 PaintCode 绘制图形进行了详细说明，可以移步查看 <ahref="http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">TheUltimate Guide To iPhone Resolutions</a>.</p><p>由上可以看出，所谓的屏幕模式，描述的就是屏幕中一个点有多少个 RenderedPixels 渲染，对于2倍屏(又称 Retina 显示屏)，会有 2 * 2 = 4个像素的面积渲染，对于3倍屏(又称 Retina HD 显示屏)，会有 3 * 3 = 9个像素的面积渲染。</p><p>关于 Points 和 Pixels 的描述，参考官方文档: <ahref="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW7">PointsVersus Pixels</a>.</p><p>iOS开发中，所有控件的坐标以及控件大小都是以点为单位的，假如我在屏幕上需要展示一张20 * 20(单位：point)大小的图片，那么设计师应该怎么给我图呢？这里就会用到屏幕模式的概念，如果屏幕是2x，那么就需要提供 40 * 40 (单位: pixel)大小的图片，如果屏幕是3x，那么就提供 60 * 60 大小的图片，且图片的命名需要遵守以下规范:</p><ul><li>Standard:<code>&lt;ImageName&gt;&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li><li>High resolution:<code>&lt;ImageName&gt;@2x&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li><li>High HD resolution:<code>&lt;ImageName&gt;@3x&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li></ul><p>其中</p><ul><li>ImageName: 图片名字，根据场景命名</li><li>device_modifier: 可选，可以是 <code>~ipad</code> 或者<code>~iphone</code>, 当需要为 iPad 和 iPhone分别指定一套图时需要加上此字段</li><li>filename_extension: 图片后缀名，iOS中使用 png 图片</li></ul><p>例如:</p><ul><li><p>MyImage.png - 1x 显示屏自动加载的图片版本</p></li><li><p>MyImage@2x.png - 2x 显示屏自动加载的图片版本</p></li><li><p>MyImage@3x.png - 3x 显示屏自动加载的图片版本</p></li><li><p>MyImage@2x~iphone.png - 2x iPhone 和 iPod touch显示屏自动加载的图片版本</p></li><li><p>MyImage@3x~iphone.png - 3x iPhone and iPod显示屏自动加载的图片版本</p></li></ul><p>2x屏幕的设备会自动加载 xxx@2x.png命名的图片资源，3x屏幕的设备会自动加载 xxx@3x.png 的图片, 现在基本没有1x屏幕的设备了，可以不用提供这个分辨率的图片了。</p><h3 id="研发工作流程">研发工作流程</h3><p>现在iPhone的屏幕尺寸也不再单一，那么现在以怎样的流程来进行iOS的研发更合适呢？这个问题知乎上<ahref="http://www.zhihu.com/question/25308946">这个问题</a>讨论很完善了，这里把<ahref="http://www.zhihu.com/question/25308946/answer/32240185">手机淘宝设计师pigtwo的回答</a>部分转来如下:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/iOS_Adaptive.png" alt="手机淘宝团队适配协作模式"><span class="caption">手机淘宝团队适配协作模式</span></div><div style="clear:both;"></div><p>第一步，视觉设计阶段，设计师按宽度750px（iPhone6）做设计稿，除图片外所有设计元素用矢量路径来做。设计定稿后在750px的设计稿上做标注，输出标注图。同时等比放大1.5倍生成宽度1125px的设计稿，在1125px的稿子里切图。</p><p>第二步，输出两个交付物给开发工程师：一个是程序用到的@3x切图资源，另一个是宽度750px的设计标注图。</p><p>第三步，开发工程师拿到750px标注图和@3x切图资源，完成iPhone6（375pt）的界面开发。此阶段不能用固定宽度的方式开发界面，得用自动布局（autolayout），方便后续适配到其它尺寸。</p><p>第四步，适配调试阶段，基于iPhone 6的界面效果，分别向上向下调试iPhone6 plus（414pt）和iPhone5S及以下（320pt）的界面效果。由此完成大中小三屏适配。</p><p>为什么选择iPhone6作为基准尺寸？当面对大中小三种屏幕需要适配的时候，很容易想到先做好一种屏幕，再去适配剩下两种屏幕。第一个决定是到底以哪种屏幕作为设计和开发的基准尺寸。我们选择中间尺寸的iPhone6（750px/375pt）作为基准，基于几个原因：</p><ol type="1"><li>从中间尺寸向上和向下适配的时候界面调整的幅度最小。375pt下的设计效果适配到414pt和320pt偏差不会太大。假设以414pt为基准做出很优雅的设计，到320pt可能元素之间比例就不是那么回事了，比如图片和文字之间视觉比例可能失调。</li><li>iPhone 6plus有两种显示模式，标准模式分辨率为1242x2208，放大模式分辨率为1125x2001（即iPhone6的1.5倍）。可见官方系统里iPhone 6和iPhone 6plus分辨率之间就存在1.5倍的倍率关系。很多情况下这两种尺寸可以用1.5倍直接等比适配。</li><li>1242x2208这个奇葩的数值是苹果官方都不愿意公开宣传的一个分辨率，不便于记忆和计算栅格。640x1136虽然是广泛应用的一个分辨率，但是大屏时代依然以小尺寸为设计基准显然不合时宜，设计师会停留在小屏的视角做设计。所以，iPhone6的750x1334是最适合基准尺寸。</li></ol><p>只交付一套设计稿，默认用什么规则来适配？</p><p>前文提到适配策略是先选择iPhone6作为基准设计尺寸，然后通过一套适配规则自动适配到另外两种尺寸。这套适配规则总结起来就一句话：文字流式，控件弹性，图片等比缩放。</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/iOS_Adaptive_layout.png" alt=""></div><div style="clear:both;"></div><p>控件弹性指的是，navigation、cell、bar等适配过程中垂直方向上高度不变；水平方向宽度变化时，通过调整元素间距或元素右对齐的方式实现自适应。这样屏幕越大，在垂直方向上可以显示更多内容，发挥大屏幕的优势。</p><h3 id="图片的resize处理">图片的Resize处理</h3><p><code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets</code>可以使用此方法生成一个新的图片，其参数 capInsets 是个结构体，可用<code>UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)</code>定义，由 top，left，bottom，right 参数定义的区域在拉伸时会保持不变，其中top、left、bottom、right 的单位都是 point，以实例说明该方法的使用吧。</p><p>实例1，从下图左边的原图，水平拉伸想得到右边的图片:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_stretches.png" alt="图片 Stretches"><span class="caption">图片 Stretches</span></div><div style="clear:both;"></div><p>保持图片左边(包括下三角处)在图片的水平拉伸处理中保持原样不变，通过代码设置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *img = [UIImage imageNamed:@&quot;popup&quot;];</span><br><span class="line">img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(0, 13, 0, 55) resizingMode:UIImageResizingModeStretch];</span><br><span class="line">self.resizableImgView.image = img;</span><br></pre></td></tr></table></figure><p>其中 CapInsets 的 left 值为 13 point，right 值为 55point，这个值的确定需要根据具体图片其保持不变的区域来确定，目前，也可以通过Xcode xcassets 的 Slicing 功能完成，如下图所示:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_stretches_slicing.png" alt="Xcode 中使用 Slicing 功能拉伸处理图片"><span class="caption">Xcode 中使用 Slicing 功能拉伸处理图片</span></div><div style="clear:both;"></div><p>其中红色框 Slices处可以控制该图片是水平拉伸(Horizontal)，垂直拉伸(Vertical)或者水平垂直方向同时(Horizontaland Vertical)拉伸, 其值 Left 26，Right 110 单位是 pixels，我们通过API<code>resizableImageWithCapInsets</code> 设置时，需要联合红色框 Scale处的值转换为单位为 point 的值，红色框 Center处的值控制图片变换的方式，这里 Stretches 表示将 width 为 4 pixels的图片区域进行拉伸，还有另一种方式Tiles，表示将设置的区域进行平铺，这种方式稍后以实例2来说明。红色框Slices 和 Center处的数值可以直接改变输入框中的数值改变，也可以拖动左侧图片中的竖直虚线设置，可以自己试试。</p><p>实例2，从下图左边的原图，将图片指定区域平铺想得到右边的图片:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_tiles.png" alt="图片 Tiles"><span class="caption">图片 Tiles</span></div><div style="clear:both;"></div><p>将图片中五角星的图样进行平铺，通过代码设置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *img = [UIImage imageNamed:@&quot;about&quot;];</span><br><span class="line">img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(0, 11.5, 0, 11) resizingMode:UIImageResizingModeTile];</span><br><span class="line">self.resizableImgView.image = img;</span><br></pre></td></tr></table></figure><p>请注意，这里 <code>resizingMode</code> 的值设置成<code>UIImageResizingModeTile</code>，表示图片的处理方式。由于这里只是水平平铺，所以其top 和 bottom 都是 0，left 和 right的值都是根据需要平铺的区域来设定。同样，这也可以通过 Xcode xcassets 的Slices 来完成。如下图所示:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_tiles_slicing.png" alt="Xcode 中使用 Slicing 功能平铺处理图片"><span class="caption">Xcode 中使用 Slicing 功能平铺处理图片</span></div><div style="clear:both;"></div><p>从上述可以看出，善于 Xcode 可以减少代码量，以更快完成开发任务。</p><h3 id="启动图设置">启动图设置</h3><p>如果你认为启动图同屏幕适配没有半毛钱关系，那就错了，例如，如果你把Launch Screen File处清空，使用iPhone5s模拟器启动运行程序，你会看到下图:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_Adaptive_launchimage.png" alt=""></div><div style="clear:both;"></div><p>红线框处是项目的设置，右边是 iPhone5s的运行结果，屏幕上下都留有黑条，这是因为没有设置对应的启动图所致，只要在Assets.xcassets 的 LaunchImage 处添加对应的启动图就可以了。</p><p>不过，现在 Xcode7 新建项目时，项目中就自动创建了LaunchScreen.storyboard 的启动画面文件了，不过若要适配 iOS7.1 及 iOS7.1以下的低版本，还是需要设置启动图片的。</p><p>文中如果有错误之处请指正，或者你有任何问题请留言。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS开发中，屏幕适配也是项很重要的工作，本文记录了一些在屏幕适配的过程中与图片相关的工作。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;首先，理解几个概念: Points, Rendered Pixels, Physical Pixels,
Physical Device。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Points:
是iOS开发中引入的抽象单位，称作点。开发过程中所有基于坐标系的绘制都是以
point 作为单位，在iPhone 2G,3G,3GS的年代，point
和屏幕上的像素是完全一一对应的，即 320 * 480 (points), 也是 320 * 480
(pixels)&lt;/li&gt;
&lt;li&gt;Rendered Pixels: 渲染像素， 以 point 为单位的绘制最终都会渲染成
pixels，这个过程被称为光栅化。基于 point
的坐标系乘以比例因子可以得到基于像素的坐标系，高比例因子会使更多的细节展示，目前的比例因子会是
1x，2x，3x&lt;/li&gt;
&lt;li&gt;Physical Pixels: 物理像素，就是设备屏幕实际的像素&lt;/li&gt;
&lt;li&gt;Physical Device: 设备屏幕的物理长度，使用英寸作为单位。比如iPhone
4屏幕是3.5英寸，iPhone 5 是4英寸，iphone
6是4.7英寸，这里的数字是指手机屏幕对角线的物理长度。实际上会是Physical
Pixels的像素值(而不是Rendered Pixels的像素值)会渲染到该屏幕上, 屏幕会有
PPI(pixels-per-inch) 的特性，PPI 的值告诉你每英寸会有多少像素渲染。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="AutoLayout" scheme="http://liumh.com/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 百分比布局</title>
    <link href="http://liumh.com/2015/09/27/ios-autolayout-multiplier/"/>
    <id>http://liumh.com/2015/09/27/ios-autolayout-multiplier/</id>
    <published>2015-09-27T00:55:16.000Z</published>
    <updated>2024-10-21T14:29:17.837Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录如何在 UIStoryboard 或者 xib 中进行百分比布局，包括</p><ul><li>View.Width 占其 Superview.Width 的百分比</li><li>View.Leading 与 Superview.Leading 间距占 Superview.Width的百分比</li><li>View.Trailing 与 Superview.Trailing 间距占 Superview.Width的百分比</li><li>View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width的百分比</li><li>限定View的宽高比</li><li>以 Superview.Width 宽度的某一百分比为 View 之间的间隔</li></ul><span id="more"></span><p>在 <a href="/2015/08/11/ios-autolayout-priority/"title="iOS NSLayoutConstraint priority">iOS NSLayoutConstraintpriority</a> 一文中提到过 multiplier, 上述提到的百分比布局都是基于multiplier 实现的，下面来一一查看其实现。</p><h4 id="view.width-占其-superview.width-的百分比">View.Width 占其Superview.Width 的百分比</h4><p>该功能实现很简单，以一个居中的按钮 Button为例，首先将按钮相对于父容器添加 <code>Equal Width</code> 的constraint，然后将它的 multiplier 设成 0.2，这样就可实现 Button1的宽度为父容器宽度的 0.2 倍。操作步骤如下:</p><figure><imgsrc="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/widthpercent.gif"alt="View宽度占父视图宽度百分比" /><figcaption aria-hidden="true">View宽度占父视图宽度百分比</figcaption></figure><h4id="view.leading-与-superview.leading-间距占-superview.width-的百分比">View.Leading与 Superview.Leading 间距占 Superview.Width 的百分比</h4><p>该功能实现其实是使 View.Leading 相对于 Superview.Trailing布局，然后再调整 multiplier 参数实现，如下操作步骤实现了将 Button的左边距离父视图左边界的距离站父视图宽度的0.2倍，如下:</p><figure><imgsrc="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/leadingpercent.gif"alt="View.Leading与Superview.Leading间距占Superview.Width的百分比" /><figcaptionaria-hidden="true">View.Leading与Superview.Leading间距占Superview.Width的百分比</figcaption></figure><h4id="view.trailing-与-superview.trailing-间距占-superview.width-的百分比">View.Trailing与 Superview.Trailing 间距占 Superview.Width 的百分比</h4><p>该需求实现是使 View.Trailing 相对于 Superview.Trailing布局，然后再调整 multiplier 参数，需要注意的是使用<code>Reverse First And Second Item</code> 调整如下表达式中 item1 和item2 在等式中两边的位置。</p><p><code>item1.attribute1 = multiplier × item2.attribute2 + constant</code></p><p>以下步骤实现 Button 的 Trailing距离父视图右边距为父视图宽度的0.2倍，需要注意的是，此时的 multiplier 是(1-0.2=0.8)，在修改 Button约束值时，可以从顶部导航中看到约束表达式的变化:</p><figure><imgsrc="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/trailingpercent.gif"alt="View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比" /><figcaption aria-hidden="true">View.Trailing 与 Superview.Trailing间距占 Superview.Width 的百分比</figcaption></figure><h4id="view.leading-与-superview.centerx-间距占父视图-superview.width-的百分比">View.Leading与 Superview.CenterX 间距占父视图 Superview.Width 的百分比</h4><p>有时间需要将 UI 组件相对于父视图的中线进行布局，比如将 View.Leading与父视图中线的距离设定为父视图宽度20%, 即相对于父视图 CenterX 的multiplier 值为 1.4</p><figure><imgsrc="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/centerpercent.gif"alt="View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比" /><figcaption aria-hidden="true">View.Leading 与 Superview.CenterX间距占父视图 Superview.Width 的百分比</figcaption></figure><h4 id="限定view的宽高比">限定View的宽高比</h4><p>有时候我们需要保持视图的宽高比不变进行缩放，此时可以设定其 AspectRatio 保持其在进行缩放时宽高比固定。</p><h4 id="以-superview.width-宽度的某一百分比为-view-之间的间隔">以Superview.Width 宽度的某一百分比为 View 之间的间隔</h4><p>要实现这个需求就没有之前那么简单了，这需要添加一个间距视图，设置每个视图与相邻间距视图的边缘间距约束，然后给所有的间距视图添加相对于其父视图的等宽约束，设置合适的比例即可。这里借用<a href="http://www.cocoachina.com/ios/20141020/9978.html">为iPhone6设计自适应布局</a> 文中一图:</p><figure><imgsrc="http://cdn.cocimg.com/cms/uploads/allimg/141020/4196_141020155715_1.jpg"alt="以 Superview.Width 宽度的某一百分比为 View 之间的间隔" /><figcaption aria-hidden="true">以 Superview.Width 宽度的某一百分比为View 之间的间隔</figcaption></figure><p>关于文中所涉及到的方法，可在 <ahref="https://github.com/carya/AutoLayoutMultiplier">AutoLayoutMultiplier</a>工程中查看。</p><p>参考:</p><ul><li><a href="http://www.cocoachina.com/ios/20141020/9978.html">为iPhone6设计自适应布局</a></li><li><ahref="http://maogm.com/blog/percentage-width-in-autolayout.html">Autolayout中的百分比宽度</a></li></ul><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录如何在 UIStoryboard 或者 xib 中进行百分比布局，包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View.Width 占其 Superview.Width 的百分比&lt;/li&gt;
&lt;li&gt;View.Leading 与 Superview.Leading 间距占 Superview.Width
的百分比&lt;/li&gt;
&lt;li&gt;View.Trailing 与 Superview.Trailing 间距占 Superview.Width
的百分比&lt;/li&gt;
&lt;li&gt;View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width
的百分比&lt;/li&gt;
&lt;li&gt;限定View的宽高比&lt;/li&gt;
&lt;li&gt;以 Superview.Width 宽度的某一百分比为 View 之间的间隔&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="AutoLayout" scheme="http://liumh.com/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>GCD 深入理解：第二部分</title>
    <link href="http://liumh.com/2015/09/07/grand-central-dispatch-in-depth-part-2/"/>
    <id>http://liumh.com/2015/09/07/grand-central-dispatch-in-depth-part-2/</id>
    <published>2015-09-07T02:20:22.000Z</published>
    <updated>2024-10-21T14:23:38.257Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自: <ahref="https://github.com/nixzhu/dev-blog">https://github.com/nixzhu/dev-blog</a></p><hr /><p>本文翻译自 <ahref="http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2">http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2</a></p><p>原作者：<a href="http://www.raywenderlich.com/u/Lolgrep"><em>DerekSelander</em></a></p><p>译者：<a href="http://weibo.com/riven0951"><em>Riven</em></a>、<ahref="https://twitter.com/nixzhu"><em>nixzhu</em></a></p><p>前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX整理校对并翻译后半部分。</p><span id="more"></span><p>==============================</p><p>欢迎来到GCD深入理解系列教程的第二部分（也是最后一部分）。</p><p>在本系列的<ahref="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">第一部分</a>中，你已经学到超过你想像的关于并发、线程以及GCD如何工作的知识。通过在初始化时利用<code>dispatch_once</code>，你创建了一个线程安全的<code>PhotoManager</code> 单例，而且你通过使用<code>dispatch_barrier_async</code> 和 <code>dispatch_sync</code>的组合使得对 <code>Photos</code> 数组的读取和写入都变得线程安全了。</p><p>除了上面这些，你还通过利用 <code>dispatch_after</code>来延迟显示提示信息，以及利用 <code>dispatch_async</code> 将 CPU密集型任务从 ViewController的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p><p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以<ahref="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip">下载第一部分最终的代码</a>。</p><p>那就让我们来更深入地探索 GCD 吧！</p><h2 id="纠正过早弹出的提示">纠正过早弹出的提示</h2><p>你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个<code>UIAlertView</code> 会在图片下载完成之前就弹出，如下如所示：</p><figure><imgsrc="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM-308x500.png"alt="Premature Completion Block" /><figcaption aria-hidden="true">Premature Completion Block</figcaption></figure><p>问题的症结在 PhotoManagers 的<code>downloadPhotoWithCompletionBlock:</code>里，它目前的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line"> </span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (completionBlock) &#123;</span><br><span class="line">        completionBlock(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法的最后你调用了 <code>completionBlock</code>——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p><p><code>Photo</code> 类的实例方法用某个 URL开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当<code>downloadPhotoWithCompletionBlock:</code> 在其末尾调用<code>completionBlock</code>时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p><p>然而，<code>-[Photo initWithURL:withCompletionBlock:]</code>是异步执行的，会立即返回——所以这种方式行不通。</p><p>因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block之后，<code>downloadPhotoWithCompletionBlock:</code> 才能调用它自己的<code>completionBlock</code>。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p><p>或许你可以写一些比较 Hacky的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p><p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计dispatch_group 的目的。</p><h3 id="dispatch-groups调度组">Dispatch Groups（调度组）</h3><p>Dispatch Group会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，DispatchGroup可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个<code>dispatch_group_t</code> 的实例来记下这些不同的任务。</p><p>当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。</p><p>第一种是 <code>dispatch_group_wait</code>，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p><p>打开 PhotoManager.m，用下列实现替换<code>downloadPhotosWithCompletionBlock:</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1</span><br><span class="line"> </span><br><span class="line">        __block NSError *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); // 2</span><br><span class="line"> </span><br><span class="line">        for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSURL *url;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            dispatch_group_enter(downloadGroup); // 3</span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                      if (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); // 4</span><br><span class="line">                                  &#125;];</span><br><span class="line"> </span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; // 6</span><br><span class="line">            if (completionBlock) &#123; // 7</span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照注释的顺序，你会看到：</p><ol type="1"><li>因为你在使用的是同步的 <code>dispatch_group_wait</code>，它会阻塞当前线程，所以你要用 <code>dispatch_async</code>将整个方法放入后台队列以避免阻塞主线程。</li><li>创建一个新的 DispatchGroup，它的作用就像一个用于未完成任务的计数器。</li><li><code>dispatch_group_enter</code> 手动通知 Dispatch Group任务已经开始。你必须保证 <code>dispatch_group_enter</code> 和<code>dispatch_group_leave</code>成对出现，否则你可能会遇到诡异的崩溃问题。</li><li>手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group的次数和离开 Group 的次数相等。</li><li><code>dispatch_group_wait</code>会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用<code>DISPATCH_TIME_FOREVER</code>让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。</li><li>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行<code>completionBlock</code>回调。这会将工作放到主线程上，并在稍后执行。</li><li>最后，检查 <code>completionBlock</code> 是否为nil，如果不是，那就运行它。</li></ol><p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行completionBlock 的。</p><blockquote><p>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察completionBlock 被调用的时刻，那么你可以在 Settings应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往Network Link Conditioner 区，开启它，再选择一个 Profile，“Very BadNetwork” 就不错。</p></blockquote><p>如果你是在模拟器里运行应用，你可以使用 <ahref="http://nshipster.com/network-link-conditioner/">来自 GitHub 的Network Link Conditioner</a>来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p><p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p><p>在我们转向另外一种使用 Dispatch Group的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的Dispatch Group ：</p><ul><li>自定义串行队列：它很适合当一组任务完成时发出通知。</li><li>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新UI 的方式。</li><li>并发队列：它也很适合 Dispatch Group 和完成时通知。</li></ul><h3 id="dispatch-group第二种方式">Dispatch Group，第二种方式</h3><p>上面的一切都很好，但在另一个队列上异步调度然后使用dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……</p><p>在 PhotoManager.m 中找到<code>downloadPhotosWithCompletionBlock:</code>方法，用下面的实现替换它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); // 2</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); // 3</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; // 4</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释新的异步方法如何工作：</p><ol type="1"><li>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在<code>async</code> 调用中。</li><li>同样的 <code>enter</code> 方法，没做任何修改。</li><li>同样的 <code>leave</code> 方法，也没做任何修改。</li><li><code>dispatch_group_notify</code> 以异步的方式工作。当 DispatchGroup 中没有任何任务时，它就会执行其代码，那么<code>completionBlock</code> 便会运行。你还指定了运行<code>completionBlock</code> 的队列，此处，主队列就是你所需要的。</li></ol><p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p><h2 id="太多并发带来的风险">太多并发带来的风险</h2><p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？</p><figure><imgsrc="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Thread_All_The_Code_Meme.jpg"alt="Thread_All_The_Code_Meme" /><figcaption aria-hidden="true">Thread_All_The_Code_Meme</figcaption></figure><p>看看 PhotoManager 中的 <code>downloadPhotosWithCompletionBlock</code>方法。你可能已经注意到这里的 <code>for</code>循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 <code>for</code>循环并发运行，以提高其速度。</p><p><code>dispatch_apply</code> 刚好可用于这个任务。</p><p><code>dispatch_apply</code> 表现得就像一个 <code>for</code>循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的<code>for</code> 循环一样，它只会在所有工作都完成后才会返回。</p><p>当在 Block内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为<code>跨越式（striding）</code>的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p><blockquote><p>译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！</p></blockquote><p>那何时才适合用 <code>dispatch_apply</code> 呢？</p><ul><li>自定义串行队列：串行队列会完全抵消 <code>dispatch_apply</code>的功能；你还不如直接使用普通的 <code>for</code> 循环。</li><li>主队列（串行）：与上面一样，在串行队列上不适合使用<code>dispatch_apply</code> 。还是用普通的 <code>for</code>循环吧。</li><li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li></ul><p>回到 <code>downloadPhotosWithCompletionBlock:</code>并用下列实现替换它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line">    dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) &#123;</span><br><span class="line"> </span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup);</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的循环现在是并行运行的了；在上面的代码中，在调用<code>dispatch_apply</code>时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个Block。</p><p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p><p>编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？</p><p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p><p>实际上，在这个例子里并不值得。下面是原因：</p><ul><li>你创建并行运行线程而付出的开销，很可能比直接使用 <code>for</code>循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用<code>dispatch_apply</code>。</li><li>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在Instruments 里分析你的应用，找出最长运行时间的方法。看看 <ahref="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">如何在Xcode 中使用 Instruments</a> 可以学到更多相关知识。</li><li>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</li></ul><p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p><h2 id="gcd-的其他趣味">GCD 的其他趣味</h2><p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p><h3 id="阻塞正确的方式">阻塞——正确的方式</h3><p>这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:]我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p><p>Xcode 里的测试在 <code>XCTestCase</code>的子类上执行，并运行任何方法签名以 <code>test</code>开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p><p>当一个给定的测试方法运行完成，XCTest方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p><p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p><blockquote><p>注意：有一些人会说，这种类型的测试不属于集成测试的首选集（PreferredSet）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p></blockquote><figure><imgsrc="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Gandalf_Semaphore.png"alt="Gandalf_Semaphore" /><figcaption aria-hidden="true">Gandalf_Semaphore</figcaption></figure><p>导航到 GooglyPuffTests.m 并查看<code>downloadImageURLWithString:</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __block BOOL isFinishedDownloading = NO;</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 isFinishedDownloading = YES;</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    while (!isFinishedDownloading) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种测试异步网络代码的幼稚方式。 While循环在函数的最后一直等待，直到 <code>isFinishedDownloading</code>布尔值变成 True，它只会在 Completion Block里发生。让我们看看这样做有什么影响。</p><p>通过在 Xcode 中点击 Product / Test运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ⌘+U来运行你的测试。</p><p>在测试运行时，注意 Xcode debug 导航栏里的 CPU使用率。这个设计不当的实现就是一个基本的 <ahref="http://en.wikipedia.org/wiki/Spinlock">自旋锁</a>。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU周期；而且它也几乎没有扩展性。</p><blockquote><p>译者注：所谓自旋锁，就是某个线程一直抢占着 CPU不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p></blockquote><p>你可能需要使用前面提到的 Network Link Conditioner，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p><blockquote><p>译者注：作者反复提到网速太快，而我们还需要对付GFW，简直泪流满面！</p></blockquote><p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p><h3 id="信号量">信号量</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p><p>如果你想学到更多关于信号量的知识，看看这个链接<ahref="http://greenteapress.com/semaphores/">它更细致地讨论了信号量理论</a>。如果你是学术型，那可以看一个软件开发中经典的<ahref="http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家进餐问题</a>，它需要使用信号量来解决。</p><p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。</p><p>让我们来使用信号量吧！</p><p>打开 GooglyPuffTests.m 并用下列实现替换<code>downloadImageURLWithString:</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"> </span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"> </span><br><span class="line">                                 // 2</span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    if (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        XCTFail(@&quot;%@ timed out&quot;, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来说明你代码中的信号量是如何工作的：</p><ol type="1"><li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li><li>在 Completion Block里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li><li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过10 秒钟就会返回——一个平衡点！</li></ol><p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意CPU 的使用率，与之前使用自旋锁的实现作个对比。</p><p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开Mac 的网络链接。测试会在 10秒后失败。这很棒，它真的能按照预想的那样工作！</p><p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p><h3 id="使用-dispatch-source">使用 Dispatch Source</h3><p>GCD 的一个特别有趣的特性是 DispatchSource，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix信号、文件描述符、Mach 端口、VFS节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个Dispatch Source对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p><p>第一次使用 Dispatch Source可能会迷失在如何使用一个源，所以你需要知晓的第一件事是<code>dispatch_source_create</code>如何工作。下面是创建一个源的函数原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t dispatch_source_create(</span><br><span class="line">   dispatch_source_type_t type,</span><br><span class="line">   uintptr_t handle,</span><br><span class="line">   unsigned long mask,</span><br><span class="line">   dispatch_queue_t queue);</span><br></pre></td></tr></table></figure><p>第一个参数是 <code>dispatch_source_type_t</code>。这是最重要的参数，因为它决定了 handle 和 mask参数将会是什么。你可以查看 <ahref="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants">Xcode文档</a> 得到哪些选项可用于每个 <code>dispatch_source_type_t</code>参数。</p><p>下面你将监控 <code>DISPATCH_SOURCE_TYPE_SIGNAL</code> 。如<ahref="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL%22">文档所显示的</a>：</p><p>一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask未使用（传 0 即可）。</p><p>这些 Unix 信号组成的列表可在头文件 <ahref="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h">signal.h</a>中找到。在其顶部有一堆 <code>#define</code> 语句。你将监控此信号列表中的<code>SIGSTOP</code>信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用LLDB 调试器调试应用时你使用的也是这个信号。</p><p>去往 PhotoCollectionViewController.m 并添加如下代码到<code>viewDidLoad</code> 的顶部，就在 <code>[super viewDidLoad]</code>下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line"> </span><br><span class="line">  // 1</span><br><span class="line">  #if DEBUG</span><br><span class="line">      // 2</span><br><span class="line">      dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">      // 3</span><br><span class="line">      static dispatch_source_t source = nil;</span><br><span class="line"> </span><br><span class="line">      // 4</span><br><span class="line">      __typeof(self) __weak weakSelf = self;</span><br><span class="line"> </span><br><span class="line">      // 5</span><br><span class="line">      static dispatch_once_t onceToken;</span><br><span class="line">      dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">          // 6</span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue);</span><br><span class="line"> </span><br><span class="line">          // 7</span><br><span class="line">          if (source)</span><br><span class="line">          &#123;</span><br><span class="line">              // 8</span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  // 9</span><br><span class="line">                  NSLog(@&quot;Hi, I am: %@&quot;, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); // 10</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  #endif</span><br><span class="line"> </span><br><span class="line">  // The other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：</p><ol type="1"><li>最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（InterestedParties）”很多关于你应用的洞察。 :]</li><li>Just to mix things up，你创建了一个 <code>dispatch_queue_t</code>实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。</li><li>你需要 <code>source</code>在方法范围之外也可被访问，所以你使用了一个 static 变量。</li><li>使用 <code>weakSelf</code> 以确保不会出现保留环（RetainCycle）。这对 <code>PhotoCollectionViewController</code>来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。</li><li>使用 <code>dispatch_once</code> 确保只会执行一次 Dispatch Source的设置。</li><li>初始化 <code>source</code> 变量。你指明了你对信号监控感兴趣并提供了<code>SIGSTOP</code>信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。</li><li>如果你提供的参数不合格，那么 Dispatch Source对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的Dispatch Source 。</li><li>当你收到你所监控的信号时，<code>dispatch_source_set_event_handler</code>就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（LogicHandler）。</li><li>一个基本的 <code>NSLog</code> 语句，它将对象打印到控制台。</li><li>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</li></ol><p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am:</span><br></pre></td></tr></table></figure><p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p><p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p><blockquote><p>译者注：好像挺有用！</p></blockquote><p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。</p><figure><imgsrc="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/What_Meme.jpg"alt="What_Meme" /><figcaption aria-hidden="true">What_Meme</figcaption></figure><p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！</p><figure><imgsrc="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/I_See_What_You_Did_Meme.png"alt="I_See_What_You_Did_Meme" /><figcaption aria-hidden="true">I_See_What_You_Did_Meme</figcaption></figure><p>将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的<code>NSLog</code>语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的PhotoCollectionViewController 方法深处。你可以访问PhotoCollectionViewController 的实例得到你关心的内容。非常方便！</p><blockquote><p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被libdispatch 跟随，它是 GCD的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p></blockquote><p>在调试器里，键入命令：<code>po [[weakSelf navigationItem] setPrompt:@"WOOT!"]</code></p><p>然后恢复应用的执行。你会看到如下内容：</p><figure><imgsrc="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console-650x500.png"alt="Dispatch_Sources_Xcode_Breakpoint_Console" /><figcaptionaria-hidden="true">Dispatch_Sources_Xcode_Breakpoint_Console</figcaption></figure><figure><imgsrc="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI-308x500.png"alt="Dispatch_Sources_Debugger_Updating_UI" /><figcaptionaria-hidden="true">Dispatch_Sources_Debugger_Updating_UI</figcaption></figure><p>使用这个方法，你可以更新UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p><blockquote><p>译者注：发挥这一点，是可以做出一些调试库的吧？</p></blockquote><h2 id="之后又该往何处去">之后又该往何处去？</h2><p>你可以<ahref="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff-Final.zip">在此下载最终的项目</a>。</p><p>我讨厌再次提及此主题，但你真的要看看 <ahref="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">如何使用Instruments</a>教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewedSolution）。</p><p>同样请看看 <ahref="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues">如何使用NSOperations 和 NSOperationQueues</a> 吧，它们是建立在 GCD之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用GCD 的最佳实践，。NSOperations提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p><p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别API），否则永远应尝试并坚持使用高级的API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入Apple 的黑暗艺术。</p><hr /><p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载自: &lt;a
href=&quot;https://github.com/nixzhu/dev-blog&quot;&gt;https://github.com/nixzhu/dev-blog&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;本文翻译自 &lt;a
href=&quot;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&quot;&gt;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者：&lt;a href=&quot;http://www.raywenderlich.com/u/Lolgrep&quot;&gt;&lt;em&gt;Derek
Selander&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;http://weibo.com/riven0951&quot;&gt;&lt;em&gt;Riven&lt;/em&gt;&lt;/a&gt;、&lt;a
href=&quot;https://twitter.com/nixzhu&quot;&gt;&lt;em&gt;nixzhu&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX
整理校对并翻译后半部分。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="GCD" scheme="http://liumh.com/tags/GCD/"/>
    
  </entry>
  
</feed>
