<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaryaLiu&#39;s blog</title>
  
  <subtitle>keep learning, keep moving</subtitle>
  <link href="http://liumh.com/atom.xml" rel="self"/>
  
  <link href="http://liumh.com/"/>
  <updated>2021-09-26T13:34:24.000Z</updated>
  <id>http://liumh.com/</id>
  
  <author>
    <name>CaryaLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之接口隔离原则</title>
    <link href="http://liumh.com/2021/09/26/design-principles-isp-md/"/>
    <id>http://liumh.com/2021/09/26/design-principles-isp-md/</id>
    <published>2021-09-26T00:05:28.000Z</published>
    <updated>2021-09-26T13:34:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<a href="http://gk.link/a/10xaT">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h1><p>今天来看看<code>SOLID</code>中的<code>I</code>, 接口隔离原则。</p><h2 id="如何理解“接口隔离原则”？"><a href="#如何理解“接口隔离原则”？" class="headerlink" title="如何理解“接口隔离原则”？"></a>如何理解“接口隔离原则”？</h2><p>接口隔离原则（<code>Interface Segregation Principle</code>），缩写为<code>ISP</code>。其定义：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use。</p><p>客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p></blockquote><p>“接口”这个名词，在软件开发中，我们既可以把它看做一组抽象的约定，也可以具体指系统与系统之间的<code>API</code>接口，还可以特指面向对象编程语言中的接口等。</p><p>理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解以下三种：</p><ul><li>一组<code>API</code>接口集合</li><li>单个<code>API</code>接口或函数</li><li><code>OOP</code>中的接口概念</li></ul><p>接下来看看，按照这三种理解方式，在不同的场景下，这条原则具体是如何解读和应用的。</p><span id="more"></span><h3 id="把“接口”理解成一组API接口集合"><a href="#把“接口”理解成一组API接口集合" class="headerlink" title="把“接口”理解成一组API接口集合"></a>把“接口”理解成一组<code>API</code>接口集合</h3><p>举个例子。客户端开发中，声明了一组<code>API</code>来规范列表类业务开发的逻辑，比如翻页、<code>UITableView</code>的<code>DataSource</code>协议中的计算逻辑。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfSections</span>() -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfRowsIn</span>(<span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="comment">// ...其他行为约定...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span>: <span class="title class_ inherited__">TableViewModel</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们如上定义协议，有一个问题就是，业务是一个列表类型的展示，但是没有翻页的业务场景，但是我遵循了该协议就必须声明翻页逻辑相关的字段。或许可以通过给<code>TableViewModel</code>中的翻页逻辑字段定义默认实现，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，按照接口隔离原则，调用者不应该依赖它不需要的接口，没有翻页逻辑的业务，就不应该遵循上述翻页的接口。</p><p>将翻页的接口单独放到另外一个接口<code>Pageable</code>中，然后将<code>TableViewModel &amp; Pageable</code>打包给具有翻页逻辑的列表使用，不具有翻页逻辑的列表只依赖<code>TableViewModel</code>即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 使用`TableView`实现的列表相关接口</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">TableViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfSections</span>() -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">numberOfRowsIn</span>(<span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="comment">// ...其他行为约定...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 翻页相关接口</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Pageable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageSize: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> pageNum: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> hasNextPage: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 具有翻页的列表</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">PageableTableViewModel</span> <span class="operator">=</span> <span class="type">TableViewModel</span> &amp; <span class="type">Pageable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span>: <span class="title class_ inherited__">PageableTableViewModel</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<code>Pageable</code>协议独立后，可以与项目中<code>UICollectionView</code>实现的列表打包结合使用。</p><p>在上面的例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个视图的接口，也可以是某个类库的接口等等。在设计视图或者类库接口的时候，<strong>如果部分接口只被部分调用者使用</strong>，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h3 id="把“接口”理解为单个API接口或函数"><a href="#把“接口”理解为单个API接口或函数" class="headerlink" title="把“接口”理解为单个API接口或函数"></a>把“接口”理解为单个<code>API</code>接口或函数</h3><p>我们再换一种理解方式，把接口理解为单个接口或函数（以下简称为“函数”）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。接下来，我们还是通过一个例子来解释一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123;</span><br><span class="line">  <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">  <span class="comment">//...省略计算逻辑...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>count()</code>函数的功能包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。</p><p>如果在项目中，对每个统计需求，<code>Statistics</code>定义的那几个统计信息都有涉及，那 <code>count()</code> 函数的设计就是合理的。相反，如果每个统计需求只涉及<code>Statistics</code>罗列的统计信息中一部分，比如，有的只需要用到 <code>max</code>、<code>min</code>、<code>average</code>这三类统计信息，有的只需要用到 <code>average</code>、<code>sum</code>。而 <code>count()</code> 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，<code>count()</code> 函数的设计就有点不合理了，我们应该按照接口隔离原则，把 <code>count()</code> 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure><p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。</p><ul><li>单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，它更侧重于接口的设计;</li><li>接口隔离原则的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</li></ul><h3 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h3><p>我们还可以把“接口”理解为 OOP 中的接口概念，比如 iOS 中的协议（<code>Protocol</code>），这里不考虑利用协议实现委托的场景。举一个简单的例子。</p><p>假如项目中要做习题的功能，分为两种模式：练习模式和挑战模式。练习模式的习题是客户端随机生成，挑战模式下的习题是从数据库中获取。现定义有如下接口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LearnService</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchSectionItems</span>(<span class="params">isInit</span>: <span class="type">Bool</span>) -&gt; [<span class="type">Equation</span>]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentItem</span>() -&gt; <span class="type">Equation</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hasFinishSection</span>() -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">//...其他接口...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChallengeService</span>: <span class="title class_ inherited__">LearnService</span> &#123;</span><br><span class="line">    <span class="comment">// ...忽略实现...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LearnService的使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExerciseViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> service: <span class="type">LearnService</span>!</span><br><span class="line">    <span class="comment">// ...省略其他属性...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchDataAndRefresh</span>(<span class="params">isInit</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> items <span class="operator">=</span> service.fetchSectionItems(isInit: isInit)</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>items.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...其他逻辑代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现增加错题本，在练习模式下，错误习题记录到错题本，而在挑战模式下，无需记录。这种情况下，新增接口</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">record</span>(<span class="params">wrong</span>: <span class="type">Equation</span>?)</span><br></pre></td></tr></table></figure><p>是应该放置在<code>LearnService</code>中还是另新增协议<code>RecordService</code>单独维护呢，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">RecordService</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">record</span>(<span class="params">wrong</span>: <span class="type">Equation</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据接口隔离原则，应该使用新增<code>RecordService</code>协议单独维护，这样可以避免在挑战模式下依赖不需要的接口。虽然，在iOS中可以将接口定义成可选类型(<code>optional</code>)，来避免实现不需要的接口，但是这样的话，违背了单一职责原则和接口隔离原则。</p><p>对于第三方库<code>Reusable</code>中，开发者也是将<code>NibLoadable</code>协议和<code>Reusable</code>协议独立，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Reusable</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="comment">/// The reuse identifier to use when registering and later dequeuing a reusable cell</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">NibLoadable</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="comment">/// The nib file to use to load a new instance of the View designed in a XIB</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> nib: <span class="type">UINib</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">NibReusable</span> <span class="operator">=</span> <span class="type">Reusable</span> &amp; <span class="type">NibLoadable</span></span><br></pre></td></tr></table></figure><p>满足接口隔离原则，避免实现者依赖不需要的接口。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ol><li>如何理解“接口隔离原则”？</li></ol><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><ol start="2"><li>接口隔离原则与单一职责原则的区别</li></ol><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a href=&quot;http://gk.link/a/10xaT&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;接口隔离原则（ISP）&quot;&gt;&lt;a href=&quot;#接口隔离原则（ISP）&quot; class=&quot;headerlink&quot; title=&quot;接口隔离原则（ISP）&quot;&gt;&lt;/a&gt;接口隔离原则（ISP）&lt;/h1&gt;&lt;p&gt;今天来看看&lt;code&gt;SOLID&lt;/code&gt;中的&lt;code&gt;I&lt;/code&gt;, 接口隔离原则。&lt;/p&gt;
&lt;h2 id=&quot;如何理解“接口隔离原则”？&quot;&gt;&lt;a href=&quot;#如何理解“接口隔离原则”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“接口隔离原则”？&quot;&gt;&lt;/a&gt;如何理解“接口隔离原则”？&lt;/h2&gt;&lt;p&gt;接口隔离原则（&lt;code&gt;Interface Segregation Principle&lt;/code&gt;），缩写为&lt;code&gt;ISP&lt;/code&gt;。其定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clients should not be forced to depend upon interfaces that they do not use。&lt;/p&gt;
&lt;p&gt;客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“接口”这个名词，在软件开发中，我们既可以把它看做一组抽象的约定，也可以具体指系统与系统之间的&lt;code&gt;API&lt;/code&gt;接口，还可以特指面向对象编程语言中的接口等。&lt;/p&gt;
&lt;p&gt;理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一组&lt;code&gt;API&lt;/code&gt;接口集合&lt;/li&gt;
&lt;li&gt;单个&lt;code&gt;API&lt;/code&gt;接口或函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOP&lt;/code&gt;中的接口概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来看看，按照这三种理解方式，在不同的场景下，这条原则具体是如何解读和应用的。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之里氏替换原则</title>
    <link href="http://liumh.com/2021/09/11/design-principles-lsp-md/"/>
    <id>http://liumh.com/2021/09/11/design-principles-lsp-md/</id>
    <published>2021-09-11T00:02:58.000Z</published>
    <updated>2021-09-26T13:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<a href="http://gk.link/a/10xaN">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h1><p>今天来看看<code>SOLID</code> 中的<code>L</code>, 里氏替换原则。</p><h2 id="如何理解“里式替换原则”？"><a href="#如何理解“里式替换原则”？" class="headerlink" title="如何理解“里式替换原则”？"></a>如何理解“里式替换原则”？</h2><p>里式替换原则（<code>Liskov Substitution Principle</code>），缩写为 <code>LSP</code>。最早是在 1986 年由 Barbara Liskov 提出。里氏替换原则的定义：</p><blockquote><p>子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p></blockquote><span id="more"></span><p>举个例子来解释。如下代码，父类<code>UserManager</code>通过接口<code>getUserInfo()</code>来获取存储在本地的用户信息，子类<code>SecurityUserManager</code>增加了额外功能，将用户信息中的加密字段解密完成后，再返回给上层业务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">/// 获取本地用户信息，如果获取出现错误，则返回`nil`，获取的值为空，则返回`[:]`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="comment">// 获取本地用户信息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">#function</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> decryptionKey: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">decryptionKey</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.decryptionKey <span class="operator">=</span> decryptionKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getUserInfo</span>(<span class="keyword">_</span> <span class="params">manager</span>: <span class="type">UserManager</span>) &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> manager.getUserInfo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XXViewController</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> demo <span class="operator">=</span> <span class="type">XXViewModel</span>()</span><br><span class="line">    <span class="comment">// 里氏替换原则</span></span><br><span class="line">    demo.getUserInfo(<span class="type">SecurityUserManager</span>(decryptionKey: <span class="string">&quot;kkk&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类<code>SecurityUserManager</code>的设计完全符合里氏替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？</p><p>现在对上面<code>SecurityUserManager</code>中的接口<code>getUserInfo()</code>改造一下。改造前：获取本地用户信息，如果获取出现错误，则返回<code>nil</code>，获取的值为空，则返回<code>[:]</code>；改造后：获取本地用户信息，出现错误或者获取的值为空，都返回<code>[:]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUserManager</span>: <span class="title class_ inherited__">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">getUserInfo</span>() -&gt; [<span class="type">String</span>: <span class="keyword">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> decryptionKey.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> [:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SecurityUserManager: <span class="subst">\(<span class="keyword">#function</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> result <span class="operator">=</span> <span class="keyword">super</span>.getUserInfo() &#123;</span><br><span class="line">            <span class="comment">// 解密result中的加密字段，并将解密结果放入result中</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在改造后的代码中，如果传递给<code>XXViewModel.getUserInfo(:)</code>函数的是<code>SecurityUserManager</code>对象，业务层获取到的数据含义发生改变，整个程序的逻辑行为有了改变。</p><p>虽然改造之后的代码仍然可以通过多态语法，动态地用子类<code>SecurityUserManager</code>来替换父类 <code>UserManager</code>，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，<code>SecurityUserManager</code> 的设计是不符合里式替换原则的。</p><p>总结：虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，<strong>是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</strong></p><h2 id="哪些代码明显违背了-LSP？"><a href="#哪些代码明显违背了-LSP？" class="headerlink" title="哪些代码明显违背了 LSP？"></a>哪些代码明显违背了 LSP？</h2><p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。</p><p>子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：</p><ul><li><p>函数声明要实现的功能；</p></li><li><p>对输入、输出、异常的约定；</p></li><li><p>注释中所罗列的任何特殊说明。</p></li></ul><p>实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><p>违反里氏替换原则的例子。</p><ol><li><p>子类违背父类声明要实现的功能</p><p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p></li><li><p>子类违背父类对输入、输出、异常的约定</p><p>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回 <code>null</code>。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p></li></ol><p>以上便是三种典型的违背里式替换原则的情况。除此之外，可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解里式替换原则跟多态的区别。多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a href=&quot;http://gk.link/a/10xaN&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;里氏替换原则（LSP）&quot;&gt;&lt;a href=&quot;#里氏替换原则（LSP）&quot; class=&quot;headerlink&quot; title=&quot;里氏替换原则（LSP）&quot;&gt;&lt;/a&gt;里氏替换原则（LSP）&lt;/h1&gt;&lt;p&gt;今天来看看&lt;code&gt;SOLID&lt;/code&gt; 中的&lt;code&gt;L&lt;/code&gt;, 里氏替换原则。&lt;/p&gt;
&lt;h2 id=&quot;如何理解“里式替换原则”？&quot;&gt;&lt;a href=&quot;#如何理解“里式替换原则”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“里式替换原则”？&quot;&gt;&lt;/a&gt;如何理解“里式替换原则”？&lt;/h2&gt;&lt;p&gt;里式替换原则（&lt;code&gt;Liskov Substitution Principle&lt;/code&gt;），缩写为 &lt;code&gt;LSP&lt;/code&gt;。最早是在 1986 年由 Barbara Liskov 提出。里氏替换原则的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子类对象（object of subtype&amp;#x2F;derived class）能够替换程序（program）中父类对象（object of base&amp;#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之开闭原则</title>
    <link href="http://liumh.com/2021/08/26/design-principles-ocp-md/"/>
    <id>http://liumh.com/2021/08/26/design-principles-ocp-md/</id>
    <published>2021-08-25T23:59:48.000Z</published>
    <updated>2021-09-26T13:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<a href="http://gk.link/a/10wrA">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p><h2 id="如何理解“对扩展开放、修改关闭”？"><a href="#如何理解“对扩展开放、修改关闭”？" class="headerlink" title="如何理解“对扩展开放、修改关闭”？"></a>如何理解“对扩展开放、修改关闭”？</h2><p>开闭原则（Open Closed Principle）,简写为OCP。其定义：</p><blockquote><p>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。</p><p>软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p></blockquote><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><span id="more"></span><p>为了便于理解该原则，这里举一个例子。下面是一个Web容器中的一段代码，意在根据操作类型判断处理是否导航到新的内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> wkWebView: <span class="type">WKWebView</span> <span class="operator">=</span> createWkWebView()</span><br><span class="line">    <span class="keyword">var</span> url <span class="operator">=</span> <span class="string">&quot;https://taobao.com&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        setupWkWebView()</span><br><span class="line">        wkWebView.load(<span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: url)<span class="operator">!</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupWkWebView</span>() &#123;</span><br><span class="line">        view.addSubview(wkWebView)</span><br><span class="line">        wkWebView.snp.makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">            make.edges.equalToSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">        wkWebView.navigationDelegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">createWkWebView</span>() -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">        configuration.allowsInlineMediaPlayback <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        configuration.dataDetectorTypes <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">let</span> wkWebView <span class="operator">=</span> <span class="type">WKWebView</span>(frame: <span class="type">CGRect</span>.zero, configuration: configuration)</span><br><span class="line">        <span class="keyword">return</span> wkWebView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊scheme的事件</span></span><br><span class="line">        <span class="keyword">let</span> hasHandledNavigation <span class="operator">=</span> handleNavigation(navigationAction)</span><br><span class="line">        <span class="keyword">if</span> hasHandledNavigation &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们现在有一种新的业务场景，比如需要对接快电，我们需要判断<code>navigationAction</code>中的<code>url</code>是否包含快电的域名，然后做出对应的处理。主要的改动有：</p><ol><li>增加判断是否包含快电的域名，并做出处理快电业务的逻辑</li><li>根据判断结果，进行对应的回调处理</li></ol><p>修改的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊scheme的事件</span></span><br><span class="line">        <span class="keyword">let</span> hasHandledNavigation <span class="operator">=</span> handleNavigation(navigationAction)</span><br><span class="line">        <span class="keyword">if</span> hasHandledNavigation &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改动点1：针对处理快电的逻辑进行回调</span></span><br><span class="line">        <span class="comment">// 处理第三方对接</span></span><br><span class="line">        <span class="keyword">if</span> handleFleetingPower(navigationAction) &#123;</span><br><span class="line">            decisionHandler(.cancel)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改动点2：处理快电的业务逻辑</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">handleFleetingPower</span>(<span class="keyword">_</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url<span class="operator">?</span>.absoluteString,</span><br><span class="line">           url.contains(<span class="string">&quot;fleetingpower.com&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理快电业务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p><p>我们先重构一下之前的 代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul><li>引入<code>HybridWebNavigationPolicy</code>协议，用于抽象在上述代理方法中进行处理的各种判断策略</li><li>引入<code>WebNavigationPolicyManager</code>管理类，用户处理各种策略的优先级以及策略集合的组装</li></ul><p>具体代码实现如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 处理特殊scheme的事件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CommonNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url <span class="keyword">as</span> <span class="type">NSURL</span>?</span><br><span class="line">        <span class="keyword">let</span> scheme <span class="operator">=</span> url<span class="operator">?</span>.scheme</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> url, <span class="keyword">let</span> scheme <span class="operator">=</span> scheme &#123;</span><br><span class="line">            <span class="keyword">if</span> scheme <span class="operator">==</span> <span class="string">&quot;tel&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> resourceSpecifier <span class="operator">=</span> url.resourceSpecifier</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    <span class="comment">// 拨打电话</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> scheme <span class="operator">==</span> <span class="string">&quot;itms-apps&quot;</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到AppStore</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebNavigationPolicyManager</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">navigationPolicics</span>() -&gt; [<span class="type">HybridWebNavigationPolicy</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> common <span class="operator">=</span> <span class="type">CommonNavigationPolicy</span>()</span><br><span class="line">        <span class="keyword">return</span> [common]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">/// 依赖注入的方式</span></span><br><span class="line">    <span class="keyword">var</span> policies <span class="operator">=</span> <span class="type">WebNavigationPolicyManager</span>.navigationPolicics()</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> policy <span class="keyword">in</span> policies &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>policy.decidePolicy(for: navigationAction, webController: owner) &#123;</span><br><span class="line">                decisionHandler(.cancel)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(.allow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，对接快电的业务，我们又该如何改动代码呢？主要的改动有下面四处。</p><ul><li>改动点1，新增<code>FleetingPowerNavigationPolicy</code>，遵循<code>HybridWebNavigationPolicy</code>协议，用于处理快电业务</li><li>改动点2，在<code>WebNavigationPolicyManager</code>中<code>static func navigationPolicics() -&gt; [HybridWebNavigationPolicy]</code>函数返回数组中增加<code>FleetingPowerNavigationPolicy</code>的实例</li></ul><p>具体代码实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 处理特殊scheme的事件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CommonNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 改动点1：处理快电业务</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FleetingPowerNavigationPolicy</span>: <span class="title class_ inherited__">HybridWebNavigationPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">decidePolicy</span>(<span class="params">for</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">webController</span>: <span class="type">HybridWebController</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url<span class="operator">?</span>.absoluteString,</span><br><span class="line">           url.contains(<span class="string">&quot;fleetingpower.com&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebNavigationPolicyManager</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">navigationPolicics</span>() -&gt; [<span class="type">HybridWebNavigationPolicy</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> common <span class="operator">=</span> <span class="type">CommonNavigationPolicy</span>()</span><br><span class="line">        <span class="comment">// 改动点2：新增`FleetingPowerNavigationPolicy`的实例</span></span><br><span class="line">        <span class="keyword">let</span> fleetingPower <span class="operator">=</span> <span class="type">FleetingPowerNavigationPolicy</span>()</span><br><span class="line">        <span class="keyword">return</span> [common, fleetingPower]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">// 代码未改动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">HybridWebController</span>: <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// 代码未改动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的基于操作的导航判断，只需要基于扩展的方式创建新的<code>Policy</code>类即可，不需要改动原来的<code>webView(_:decidePolicyFor:decisionHandler:)</code>函数的逻辑。</p><h2 id="修改代码就意味着违背开闭原则吗？"><a href="#修改代码就意味着违背开闭原则吗？" class="headerlink" title="修改代码就意味着违背开闭原则吗？"></a>修改代码就意味着违背开闭原则吗？</h2><p>从开闭原则的定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p><p>看了上面重构之后的代码，你可能还会有疑问：在添加新的判断处理逻辑的时候，尽管改动点1（添加新的<code>Policy</code>类）是基于扩展而非修改的方式来完成，但是改动点2貌似不是基于扩展而是基于修改的方式来完成的，那改动点1不就违背开闭原则了吗？</p><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p><p>在重构之后的<code>webView(_:decidePolicyFor:decisionHandler:)</code>代码实现中，我们的核心逻辑集中在该方法中以及各个<code>Policy</code>中，当我们在添加新的判断处理逻辑的时候，该方法完全不需要修改，而只需要扩展一个新的<code>Policy</code>类。如果我们把该方法及各个<code>Policy</code>类合起来看做一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。</p><p>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h2 id="如何做到“对扩展开放、修改关闭”？"><a href="#如何做到“对扩展开放、修改关闭”？" class="headerlink" title="如何做到“对扩展开放、修改关闭”？"></a>如何做到“对扩展开放、修改关闭”？</h2><p>开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p><p><strong>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，<strong>提供抽象化的不可变接口</strong>，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。</p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</p><h2 id="如何在项目中灵活应用开闭原则？"><a href="#如何在项目中灵活应用开闭原则？" class="headerlink" title="如何在项目中灵活应用开闭原则？"></a>如何在项目中灵活应用开闭原则？</h2><p>写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？</p><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p><p>即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><p>开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a href=&quot;http://gk.link/a/10wrA&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a&gt;开闭原则&lt;/h1&gt;&lt;p&gt;在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。&lt;/p&gt;
&lt;h2 id=&quot;如何理解“对扩展开放、修改关闭”？&quot;&gt;&lt;a href=&quot;#如何理解“对扩展开放、修改关闭”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“对扩展开放、修改关闭”？&quot;&gt;&lt;/a&gt;如何理解“对扩展开放、修改关闭”？&lt;/h2&gt;&lt;p&gt;开闭原则（Open Closed Principle）,简写为OCP。其定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。&lt;/p&gt;
&lt;p&gt;软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单一职责原则</title>
    <link href="http://liumh.com/2021/08/06/design-principles-srp-md/"/>
    <id>http://liumh.com/2021/08/06/design-principles-srp-md/</id>
    <published>2021-08-05T23:51:27.000Z</published>
    <updated>2021-09-26T13:33:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接<a href="http://gk.link/a/10vlE">阅读原文</a>获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。</p><h1 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h1><p><code>SOLID</code>原则是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 <code>SOLID</code> 中的 S、O、L、I、D 这 5 个英文字母。今天学习的是 <code>SOLID</code> 原则中的第一个原则：单一职责原则。</p><span id="more"></span><h2 id="如何理解单一职责原则（SRP）？"><a href="#如何理解单一职责原则（SRP）？" class="headerlink" title="如何理解单一职责原则（SRP）？"></a>如何理解单一职责原则（SRP）？</h2><p>单一职责原则（<code>Single Responsibility Principle</code>)，缩写为 <code>SRP</code>。其定义：</p><blockquote><p>A class or module should have a single responsibility。</p><p>一个类或者模块只负责完成一个职责（或者功能）。</p></blockquote><p>这个原则描述的两个对象，一个是类（class），一个是模块（module）。关于这两个概念，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p><p>一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><p>单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><h2 id="如何判断类的职责是否足够单一？"><a href="#如何判断类的职责是否足够单一？" class="headerlink" title="如何判断类的职责是否足够单一？"></a>如何判断类的职责是否足够单一？</h2><p>对于如何判断类的职责是否单一，不能脱离具体的应用场景。不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判断，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或者在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p><p>比如对于下面的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> long userId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> username;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> email;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> telephone;</span><br><span class="line">  <span class="keyword">private</span> long createTime;</span><br><span class="line">  <span class="keyword">private</span> long lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul><li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li><li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li><li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；</li><li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li><li>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li></ul><p>对于上述第一条，如何判定类中的代码行数、函数或属性过多，可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个。实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。</p><h2 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。</p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是极客时间里王争专栏《设计模式之美》的学习笔记，你可以通过链接&lt;a href=&quot;http://gk.link/a/10vlE&quot;&gt;阅读原文&lt;/a&gt;获取更加详尽的描述，也可以通过该链接进行订阅和购买获取优惠。&lt;/p&gt;
&lt;h1 id=&quot;单一职责原则（SRP）&quot;&gt;&lt;a href=&quot;#单一职责原则（SRP）&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则（SRP）&quot;&gt;&lt;/a&gt;单一职责原则（SRP）&lt;/h1&gt;&lt;p&gt;&lt;code&gt;SOLID&lt;/code&gt;原则是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 &lt;code&gt;SOLID&lt;/code&gt; 中的 S、O、L、I、D 这 5 个英文字母。今天学习的是 &lt;code&gt;SOLID&lt;/code&gt; 原则中的第一个原则：单一职责原则。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计原则" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>阿里组件化框架BeeHive解析</title>
    <link href="http://liumh.com/2018/10/11/beehive-analysis/"/>
    <id>http://liumh.com/2018/10/11/beehive-analysis/</id>
    <published>2018-10-11T03:14:46.000Z</published>
    <updated>2021-04-18T03:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是基于BeeHive版本1.6.0进行分析。</p><p>BeeHive核心思想涉及两个部分：</p><ol><li>各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。</li><li>App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。</li></ol><p>Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。</p><span id="more"></span><p>本文会按照以下顺序进行介绍：</p><ul><li><a href="#beehive-overview">BeeHive概览</a></li><li><a href="#beehive-lifecycle-event">BeeHive模块生命周期事件</a><ul><li><a href="#beehive-system-event">系统事件</a></li><li><a href="#beehive-event-extension">通用事件</a></li><li><a href="#beehive-custom-event">业务自定义事件</a></li></ul></li><li><a href="#beehive-register-module">BeeHive模块注册</a><ul><li><a href="#annotation-register-module">Annotation方式注册</a></li><li><a href="#plist-register-module">读取本地Plist方式注册</a></li><li><a href="#load-register-module">Load方法注册</a></li></ul></li><li><a href="#beehive-register-service">BeeHive模块间调用</a><ul><li><a href="#annotation-register-service">Annotation方式注册</a></li><li><a href="#plist-register-service">读取本地Plist方式注册</a></li><li><a href="#api-register-service">API注册</a></li></ul></li><li><a href="#beehive-context">上下文环境Context</a></li></ul><h1 id="BeeHive概览"><a href="#BeeHive概览" class="headerlink" title="BeeHive概览"></a>BeeHive概览</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是基于BeeHive版本1.6.0进行分析。&lt;/p&gt;
&lt;p&gt;BeeHive核心思想涉及两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。&lt;/li&gt;
&lt;li&gt;App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计模式" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS策略设计模式实践</title>
    <link href="http://liumh.com/2018/09/18/design-pattern-strategy/"/>
    <id>http://liumh.com/2018/09/18/design-pattern-strategy/</id>
    <published>2018-09-18T14:51:41.000Z</published>
    <updated>2021-04-18T03:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>情景：把一堆算法塞到同一段代码中，然后使用<code>if-else</code>或者<code>switch-case</code>条件语句来决定要使用哪个算法？这些算法可能是一堆相似的类函数或方法，用以解决相关的问题。例如验证数据输入的情形，数据本身可以是任何数据类型(如CGFloat，NSString，NSInteger等)，每种数据类型需要不同的算法。如果把每一种算法封装成一个对象，那么就能消除根据数据类型决定使用什么算法的一堆<code>if-else</code>或<code>switch-case</code>语句。<br>面向对象软件设计中，我们可以把相关算法分离为不同的类，成为策略，对应的设计模式称为策略模式。</p><span id="more"></span><h1 id="何为策略模式"><a href="#何为策略模式" class="headerlink" title="何为策略模式"></a>何为策略模式</h1><p>策略模式的使用可以粗暴的分为3个角色。</p><ol><li>策略类，或者定义为策略接口、策略协议，它为所有支持的或相关的算法声明了一个共同接口。</li><li>策略对象：它会实现策略协议，策略对象通常存在多个，分别封装实现具体的算法。</li><li>场景(context)类对象：配置有一个具体策略对象的示例，场景对象使用策略接口调用由具体策略类定义的算法。</li></ol><p>它们的静态关系如下图所示：</p><!--![](http://readus-org.qiniudn.com/img/design/overview-strategy-pattern.png)--><div class="figure center" style="width:622;"><img class="fig-img" src="/img/design-pattern-strategy/overview-strategy-pattern.png" style="width:622;height:303;"alt="策略模式类图静态关系"><span class="caption">策略模式类图静态关系</span></div><p>一组算法，或者说算法的一个层次结构，以ConcreteStrategy(A、B和C)类的形式，共享相同的AlgorithmInterface接口，这样Context就能使用相同的接口访问算法的各种变体。</p><p>Context的实例可以在运行时用不同的ConcreteStrategy对象进行配置，这可以理解成更换context对象的『内容』，因为变更是发生在对象的内部。</p><h1 id="何时使用策略模式"><a href="#何时使用策略模式" class="headerlink" title="何时使用策略模式"></a>何时使用策略模式</h1><p>在以下情形，考虑使用策略模式。</p><ul><li>一个类在其操作中使用多个条件语句来定义许多行为，我们可以把相关的条件分支移动到它们自己的策略类中。</li><li>需要算法的各种变体。</li><li>需要避免把复杂的、与算法相关的数据结构暴露给客户端。</li></ul><h1 id="在UITextField中应用策略模式"><a href="#在UITextField中应用策略模式" class="headerlink" title="在UITextField中应用策略模式"></a>在UITextField中应用策略模式</h1><p>类图设计如下图所示：</p><!--![](http://readus-org.qiniudn.com/img/design/inputvalidator-strategy-pattern.png)--><div class="figure center" style="width:611;"><img class="fig-img" src="/img/design-pattern-strategy/inputvalidator-strategy-pattern.png" style="width:611;height:176;"alt="策略模式在输入验证中的应用"><span class="caption">策略模式在输入验证中的应用</span></div><h2 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h2><p>这里策略类抽象了两个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@protocol ACITextFieldInputValidator &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateInput:(UITextField *)textField</span><br><span class="line">    charactersInRange:(NSRange)range</span><br><span class="line">    replacementString:(NSString *)string</span><br><span class="line">                error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingInput:(UITextField *)textField error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateInput:(UITextField *)textField</span><br><span class="line">    charactersInRange:(NSRange)range</span><br><span class="line">    replacementString:(NSString *)string</span><br><span class="line">                error:(NSError **)error;</span><br></pre></td></tr></table></figure><p>在UITextFieldDelegate的<code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</code>方法中进行验证。</p><p><code>- (BOOL)validateEndEditingInput:(UITextField *)textField error:(NSError **)error;</code>在UITextFieldDelegate的<code>- (void)textFieldDidEndEditing:(UITextField *)textField</code>方法中进行验证。</p><p>这里特殊说明一下：</p><p>接口中使用UITextField作为入参而不是使用NSString作为入参，是因为如果只用NSString值，那么策略对象中的动作就是单向的。就是说，验证器只能检查，然后返回结果，而不能修改原始值。而使用UITextField型的输入参数，就可以两全其美。验证器可以选择修改文本框的原始值(比如删除无效的值),或者只检查而不修改。</p><p>另一个问题是，如果输入值错误，为什么不引发一个NSException异常呢？这是因为在Cocoa Touch框架中，引发自己的异常然后再用<code>try-catch</code>语句块来捕捉，这非常耗资源，所以不推荐，返回NSError对象的开销相对较小。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>这里使用策略的场景是UITextField，在UITextField的子类InputValidateTextField中，声明一个遵循策略协议的对象属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface ACIInputValidateTextField : UITextField</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) id&lt;ACITextFieldInputValidator&gt; inputValidator;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateCharactersInRange:(NSRange)range</span><br><span class="line">                replacementString:(NSString *)string</span><br><span class="line">                            error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingWithError:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>同时，场景对象中会声明方法来处理调用策略对象的接口方法。具体示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@implementation ACIInputValidateTextField</span><br><span class="line"></span><br><span class="line">- (BOOL)validateCharactersInRange:(NSRange)range</span><br><span class="line">                replacementString:(NSString *)string</span><br><span class="line">                            error:(NSError **)error &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL shouldChange = [self.inputValidator validateInput:self charactersInRange:range replacementString:string error:error];</span><br><span class="line">    return shouldChange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)validateEndEditingWithError:(NSError **)error &#123;</span><br><span class="line">    BOOL isValid = [self.inputValidator validateEndEditingInput:self error:error];</span><br><span class="line">    return isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="策略对象"><a href="#策略对象" class="headerlink" title="策略对象"></a>策略对象</h2><p>策略对象，这里是遵循了策略协议的<code>TextFieldInputValidator</code>的对象。每个对象会实现TextFieldInputValidator的方法，其中封装了具体的策略实现。</p><p>具体代码示例详见<a href="https://github.com/carya/InputValidator">github InputValidator</a></p><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;情景：把一堆算法塞到同一段代码中，然后使用&lt;code&gt;if-else&lt;/code&gt;或者&lt;code&gt;switch-case&lt;/code&gt;条件语句来决定要使用哪个算法？这些算法可能是一堆相似的类函数或方法，用以解决相关的问题。例如验证数据输入的情形，数据本身可以是任何数据类型(如CGFloat，NSString，NSInteger等)，每种数据类型需要不同的算法。如果把每一种算法封装成一个对象，那么就能消除根据数据类型决定使用什么算法的一堆&lt;code&gt;if-else&lt;/code&gt;或&lt;code&gt;switch-case&lt;/code&gt;语句。&lt;br&gt;面向对象软件设计中，我们可以把相关算法分离为不同的类，成为策略，对应的设计模式称为策略模式。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://liumh.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="设计模式" scheme="http://liumh.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__</title>
    <link href="http://liumh.com/2018/08/18/ios-attribute-section/"/>
    <id>http://liumh.com/2018/08/18/ios-attribute-section/</id>
    <published>2018-08-18T14:43:39.000Z</published>
    <updated>2021-04-18T03:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code>是在C, C++, Objective-C语言中使用的编译指令，一般以<code>__attribute__(xxx)</code>的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。</p><span id="more"></span><!-- toc --><h1 id="Attribute语法"><a href="#Attribute语法" class="headerlink" title="Attribute语法"></a>Attribute语法</h1><p>关于Attribute的语法描述见官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">Attribute Syntax</a></p><blockquote></blockquote><p>An attribute specifier is of the form <code>__attribute__ ((attribute-list))</code>. An attribute list is a possibly empty comma-separated sequence of attributes, where each attribute is one of the following:</p><blockquote></blockquote><ul><li>Empty. Empty attributes are ignored.</li><li>An attribute name (which may be an identifier such as <em>unused</em>, or a reserved word such as <em>const</em>).</li><li>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:<blockquote><ul><li>An identifier. For example, <em>mode</em> attributes use this form.</li><li>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, <em>format</em> attributes use this form.</li><li>A possibly empty comma-separated list of expressions. For example, <em>format_arg</em> attributes use this form with the list being a single integer constant expression, and <em>alias</em> attributes use this form with the list being a single string constant.</li></ul></blockquote></li></ul><h1 id="used"><a href="#used" class="headerlink" title="used"></a>used</h1><p><em>used</em>的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。具体的描述可以看<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes">gun的官方文档</a>。</p><blockquote></blockquote><p><em>used</em></p><blockquote></blockquote><p>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</p><blockquote></blockquote><p>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</p><h1 id="section"><a href="#section" class="headerlink" title="section"></a>section</h1><p>通常情况下，编译器会将对象放置于DATA段的<em>data</em>或者<em>bss</em>节中。但是，有时我们需要将数据放置于特殊的节中，此时<em>section</em>可以达到目的。例如，BeeHive中就把module注册数据存在__DATA数据段里面的”BeehiveMods”section中。</p><p><em>section</em>通常用于修饰全局变量。以下是gnu官网对<em>section</em>属性的说明。</p><blockquote></blockquote><p><em>section (“section-name”)</em></p><blockquote></blockquote><p>Normally, the compiler places the objects it generates in sections like <em>data</em> and <em>bss</em>. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The <em>section</em> attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:</p><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;</span><br><span class="line">struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;</span><br><span class="line">char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;</span><br><span class="line">int init_data __attribute__ ((section (&quot;INITDATA&quot;)));</span><br><span class="line">main() &#123;</span><br><span class="line">  /* Initialize stack pointer */</span><br><span class="line">  init_sp (stack + sizeof (stack));</span><br><span class="line">  /* Initialize initialized data */</span><br><span class="line">  memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</span><br><span class="line">  /* Turn on the serial ports */</span><br><span class="line">  init_duart (&amp;a);</span><br><span class="line">  init_duart (&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Use the <em>section</em> attribute with <em>global</em> variables and not <em>local</em> variables, as shown in the example.</p></blockquote><p>You may use the <em>section</em> attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the <em>common</em> (or <em>bss</em>) section and can be multiply “defined”. Using the <em>section</em> attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the <em>-fno-common</em> flag or the <em>nocommon</em> attribute.</p><blockquote></blockquote><p>Some file formats do not support arbitrary sections so the <em>section</em> attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</p><p><code>__attribute__</code>的更多使用示例可参考<a href="https://github.com/facebook/Tweaks">FBTweak</a></p><blockquote><p>编译器提供了我们一种<code>__attribute__((section(&quot;xxx段，xxx节&quot;)</code>的方式让我们将一个指定的数据储存到我们需要的节当中。</p></blockquote><p>在<a href="https://github.com/alibaba/BeeHive">BeeHive框架</a>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>通过使用<code>__attribute__((section(&quot;name&quot;)))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段。</p><p>编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)格式主要是</p><ul><li>Windows下的PE(Portable Executable)</li><li>Linux的ELF(Executable Linkable Format)</li><li>macOS&#x2F;iOS系统上的Mach-O（Mach Object File Format）</li></ul><p>程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，<em>data</em>和*.bss*节属于数据段。</p><!--![Mach-O内存布局](/img/ios-attribute-section/Mach-O.png)--><div class="figure center" style="width:431;"><img class="fig-img" src="/img/ios-attribute-section/Mach-O.png" style="width:431;height:496;"alt="Mach-O内存布局"><span class="caption">Mach-O内存布局</span></div><p>Mach-O的组成结构如上图所示包括了Header、Load commands、Data（包含Segement的具体数据），我们平时了解到的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。</p><blockquote><p>一个现代<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>的主要工作流程如下：</p></blockquote><p>源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（Linker）→ 可执行文件（executables）， 最后打包好的文件就可以给计算机去判读运行了。</p><p>编译后各个section存储的内容如下：</p><table><thead><tr><th>Segment and Section Name</th><th>Contents</th></tr></thead><tbody><tr><td>__TEXT,__text</td><td>Executable machine code. The compiler places only executable code in this section; no tables or data of any sort are stored here.</td></tr><tr><td>__TEXT,__cstring</td><td>Constant C strings. A C string is a sequence of non-null bytes that ends with a null byte (‘\0’). The static linker coalesces constant C string values, removing duplicates, when building the final product.</td></tr><tr><td>__TEXT,__picsymbol_stub</td><td>Position -independent indirect symbol stubs. See “Indirect Addressing” for more information.</td></tr><tr><td>__TEXT,__symbol_stub</td><td>Indirect symbol stubs. See “Indirect Addressing” for more information.</td></tr><tr><td>__TEXT,__const</td><td>Initialized constant variables. The compiler places all data declared const in this section.</td></tr><tr><td>__TEXT,__literal4</td><td>4-byte literal values. The compiler places single-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.</td></tr><tr><td>__TEXT,__literal8</td><td>8-byte literal values. The compiler places double-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.</td></tr><tr><td>__DATA,__data</td><td>Initialized mutable variables, such as writable C strings and data arrays.</td></tr><tr><td>__DATA,__la_symbol_ptr</td><td>Lazy symbol pointers, which are indirect references to functions imported from a different file. See “Indirect Addressing” for more information.</td></tr><tr><td>__DATA,__nl_symbol_ptr</td><td>Non-lazy symbol pointers, which are indirect references to data items imported from a different file. See “Indirect Addressing” for more information.</td></tr><tr><td>__DATA,__dyld</td><td>Information used by the static linker.</td></tr><tr><td>__DATA,__const</td><td>Unintialized constant variables.</td></tr><tr><td>__DATA,__mod_init_func</td><td>Module initialization functions. The C++ compiler places static constructors here.</td></tr><tr><td>__DATA,__mod_term_func</td><td>Module termination functions.</td></tr><tr><td>__DATA,__bss</td><td>Data for uninitialized static variables (for example, static int i;).</td></tr><tr><td>__DATA,__common</td><td>Uninitialized imported symbol definitions (for example, int i;) located in the global scope (outside of a function declaration).</td></tr></tbody></table><p>从上面的表格可以看出：</p><ul><li>__TEXT,__text：可执行的机器码(代码段)</li><li>__TEXT,__const：已初始化的常量，编译器会将所有声明为const的数据放置在该section；</li><li>__DATA,__data：已初始化的可变全局变量；</li><li>__DATA,__bss：未初始化的全局静态变量和局部静态变量，例如 <code>static int i;</code></li><li>__DATA,__common：未初始化的全局变量；</li></ul><p>全局变量是放在全局内存中的，用static修饰的局部变量也是会放在放全局内存的，它的作用域是局部的，但生命期是全局的。</p><p>全局强调的是它的生命期，而不是它的作用域，所以有时可能把两者的概念互换。一般来说，在一起定义的两个全局变量，在内存的中位置是相邻的。这是一个简单的常识，但有时挺有用，如果一个全局变量被破坏了，不防先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>上一节只是讲到如何将数据存入特殊的section中，那么如何把存入的数据读取出来呢？</p><p>这里先介绍一下<code>__attribute__((constructor))</code>。</p><p><em>constructor</em>：顾名思义，构造器加上这个属性的函数会在可执行文件（或 shared library）load时被调用，可以理解为在 main() 函数调用前执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;main&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;</span><br></pre></td></tr></table></figure><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机：</p><ol><li>所有Class都已经加载完成</li><li>main 函数还未执行</li><li>无需像 +load 还得挂载在一个Class中</li></ol><h1 id="读取section中的值"><a href="#读取section中的值" class="headerlink" title="读取section中的值"></a>读取section中的值</h1><p>现在来了解如何将存储在特殊section中的数据读出。</p><p>在BeeHive源码中有下面一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls = NSClassFromString(modName);</span><br><span class="line">            </span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>void initProphet()</code>使用了<code>__attribute__((constructor))</code>修饰，其执行时机已在上一节提到。该函数的实现体里使用了<code>_dyld_register_func_for_add_image</code>函数，现在看看该函数的作用。</p><p><code>_dyld_register_func_for_add_image</code>:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following functions allow you to install callbacks which will be called   </span><br><span class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line"> * and before the image is un-memory-mapped.</span><br><span class="line"> */</span><br><span class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) </span><br><span class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))</span><br></pre></td></tr></table></figure><p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调<code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的mach_header以及一个虚拟内存地址 intptr_t。</p><p>mach_header是定义在<code>usr/include/mach-o/loader.h</code>中的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">     uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">     cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">     cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">     uint32_t    filetype;    /* type of file */</span><br><span class="line">     uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">     uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">     uint32_t    flags;        /* flags */</span><br><span class="line">     uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过调用<em>BHReadConfiguration</em>函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p><p>参考：</p><ul><li><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">Attribute Syntax</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html#//apple_ref/doc/uid/20001860-BAJGJEJC">Overview of the Mach-O Executable Format</a></li><li><a href="https://lowlevelbits.org/parsing-mach-o-files/">PARSING MACH-O FILES</a></li></ul><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt;是在C, C++, Objective-C语言中使用的编译指令，一般以&lt;code&gt;__attribute__(xxx)&lt;/code&gt;的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UICollectionViewLayoutAttributes初探</title>
    <link href="http://liumh.com/2017/12/29/ios-uicollectionviewlayoutattributes/"/>
    <id>http://liumh.com/2017/12/29/ios-uicollectionviewlayoutattributes/</id>
    <published>2017-12-29T14:51:09.000Z</published>
    <updated>2021-04-18T03:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>UICollectionViewLayoutAttributes是UICollectionView的重要组成部分，本文从其基本定义、如何使用以及使用场景几方面来简单介绍。文末以自定义UICollectionView各个Section的背景色的示例来展示UICollectionViewLayoutAttributes的应用。</p><span id="more"></span><h1 id="UICollectionViewLayoutAttributes概览"><a href="#UICollectionViewLayoutAttributes概览" class="headerlink" title="UICollectionViewLayoutAttributes概览"></a>UICollectionViewLayoutAttributes概览</h1><p>UICollectionViewLayoutAttributes的官方解释：</p><blockquote><p>A layout object that manages the layout-related attributes for a given item in a collection view.Layout objects create instances of this class when asked to do so by the collection view. In turn, the collection view uses the layout information to position cells and supplementary views inside its bounds.</p></blockquote><p>UICollectionViewLayoutAttributes是管理collection view中指定元素的布局属性的对象。collection view使用该对象中的布局属性来控制cells和supplementary views的显示位置。</p><p>下面是UICollectionViewLayoutAttributes类的定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewLayoutAttributes : NSObject &lt;NSCopying, UIDynamicItem&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic) CGRect frame;</span><br><span class="line">@property (nonatomic) CGPoint center;</span><br><span class="line">@property (nonatomic) CGSize size;</span><br><span class="line">@property (nonatomic) CATransform3D transform3D;</span><br><span class="line">@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);</span><br><span class="line">@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);</span><br><span class="line">@property (nonatomic) CGFloat alpha;</span><br><span class="line">@property (nonatomic) NSInteger zIndex; // default is 0</span><br><span class="line">@property (nonatomic, getter=isHidden) BOOL hidden; // As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES</span><br><span class="line">@property (nonatomic, strong) NSIndexPath *indexPath;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;</span><br><span class="line">@property (nonatomic, readonly, nullable) NSString *representedElementKind; // nil when representedElementCategory is UICollectionElementCategoryCell</span><br><span class="line"></span><br><span class="line">+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中UICollectionElementCategory的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, UICollectionElementCategory) &#123;</span><br><span class="line">    UICollectionElementCategoryCell,</span><br><span class="line">    UICollectionElementCategorySupplementaryView,</span><br><span class="line">    UICollectionElementCategoryDecorationView</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Because layout attribute objects may be copied by the collection view, it conforms to the <code>NSCopying</code> protocol. It is very important that we also conform to this protocol and implement <code>copyWithZone:</code>. Otherwise, our property will always be zero (as guaranteed by the compiler). </p></blockquote><p>由于layout attributes对象可能会被collection view复制，因此layout attributes对象应该遵循<code>NSCoping</code>协议，并实现<code>copyWithZone:</code>方法，否则我们获取的自定义属性会一直是空值。</p><blockquote><p>If you subclass and implement any custom layout attributes, you must also override the inherited <code>isEqual:</code> method to compare the values of your properties. In iOS 7 and later, the collection view does not apply layout attributes if those attributes have not changed. It determines whether the attributes have changed by comparing the old and new attribute objects using the <code>isEqual:</code> method. Because the default implementation of this method checks only the existing properties of this class, you must implement your own version of the method to compare any additional properties. If your custom properties are all equal, call super and return the resulting value at the end of your implementation.</p></blockquote><p>如果继承了UICollectionViewLayoutAttributes并且添加了任何自定义的layout attributes，也必须实现<code>isEqual:</code>方法来比较自定义属性。在iOS7(包括iOS7)以后，如果UICollectionViewLayoutAttributes 的属性值没有改变，collection view不会应用layout attributes，这些layout attributes的是否改变由<code>isEqual:</code>的返回值来决定。在重写<code>isEqual:</code>时，除了需要处理自定义属性外，还需要注意父类方法的调用。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** subclass must conforms to the NSCopying protocol */</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    </span><br><span class="line">    CLSectionColorLayoutAttributes *layoutAttributes = [super copyWithZone:zone];</span><br><span class="line">    layoutAttributes.sectionColor = self.sectionColor;</span><br><span class="line">    return layoutAttributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** In iOS 7 and later, the collection view does not apply layout attributes if</span><br><span class="line"> those attributes have not changed. It determines whether the attributes have changed</span><br><span class="line"> by comparing the old and new attribute objects using the isEqual: method. */</span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([object class] == [self class]) &#123;</span><br><span class="line">        return [super isEqual:object] &amp;&amp; (self.sectionColor == [object sectionColor]);</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Subclassing-Notes"><a href="#Subclassing-Notes" class="headerlink" title="Subclassing Notes"></a>Subclassing Notes</h1><p>首先，在UICollectionViewLayoutAttributes的子类中重写<code>copyWithZone:</code>方法和<code>isEqual:</code>方法。其原因已在上一节讲到。</p><p>接下来需要告诉collection view使用自定义的类而不是系统的UICollectionViewLayoutAttributes类，需要在自定义的CLCollectionViewFlowLayout中重写类方法<code>+(Class)layoutAttributesClass</code>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layoutAttributesClass &#123;</span><br><span class="line">    return [CLSectionColorLayoutAttributes class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了与系统的配置属性使用保持一致，我们可以在CLCollectionViewFlowLayout头文件中暴露自定义属性，以便对该属性的统一设置。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">@property (nonatomic, strong) UIColor *sectionColor;</span><br><span class="line"></span><br><span class="line">.m</span><br><span class="line">- (void)setSectionColor:(UIColor *)sectionColor &#123;</span><br><span class="line">    _sectionColor = sectionColor;</span><br><span class="line">    [self invalidateLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了达到与系统的<code>UICollectionViewDelegateFlowLayout</code>使用达到一致，可以支持自定义属性针对不同indexPath的设置，我们声明protocol以供业务层调用，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol CLCollectionViewDelegateFlowLayout &lt;UICollectionViewDelegateFlowLayout&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (UIColor *)collectionView:(UICollectionView *)collectionView</span><br><span class="line">                     layout:(UICollectionViewLayout *)collectionViewLayout</span><br><span class="line">     colorForSectionAtIndex:(NSInteger)section;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里需要注意，我们自定义的协议遵循了UICollectionViewDelegateFlowLayout协议,且无需在CLCollectionViewFlowLayout类中声明一个遵循该协议的delegate对象，该协议的使用与UICollectionViewDelegateFlowLayout一致。layout的实现文件中优先使用该协议返回的值，否则使用属性中传入的值。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIColor *)sectionColorAtSection:(NSInteger)section &#123;</span><br><span class="line">    UIColor *sectionColor = self.sectionColor;</span><br><span class="line">    //if implemented collectionView:layout:colorForSectionAtIndex: use the return value</span><br><span class="line">    if ([self.collectionView.delegate respondsToSelector:@selector(collectionView:layout:colorForSectionAtIndex:)]) &#123;</span><br><span class="line">        id&lt;CLCollectionViewDelegateFlowLayout&gt; temp = (id&lt;CLCollectionViewDelegateFlowLayout&gt;)self.collectionView.delegate;</span><br><span class="line">        sectionColor = [temp collectionView:self.collectionView layout:self colorForSectionAtIndex:section];</span><br><span class="line">    &#125;</span><br><span class="line">    return sectionColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sectionColorAtSection:</code>方法会在<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>中调用。</p><p>至此，自定义属性传递给了layout，但是是怎样应用到具体的Cell或者SupplementaryView上的呢？继承自UICollectionReusableView或者UICollectionViewCell的控制，包含如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Classes that want to support custom layout attributes specific to a given UICollectionViewLayout subclass can apply them here.</span><br><span class="line">// This allows the view to work in conjunction with a layout class that returns a custom subclass of UICollectionViewLayoutAttributes from -layoutAttributesForItem: or the corresponding layoutAttributesForHeader/Footer methods.</span><br><span class="line">// -applyLayoutAttributes: is then called after the view is added to the collection view and just before the view is returned from the reuse queue.</span><br><span class="line">// Note that -applyLayoutAttributes: is only called when attributes change, as defined by -isEqual:.</span><br><span class="line">- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes;</span><br></pre></td></tr></table></figure><p>例如如下的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes &#123;</span><br><span class="line">    [super applyLayoutAttributes:layoutAttributes];</span><br><span class="line">    if ([layoutAttributes isKindOfClass:[CLSectionColorLayoutAttributes class]]) &#123;</span><br><span class="line">        CLSectionColorLayoutAttributes *attributes = (CLSectionColorLayoutAttributes *)layoutAttributes;</span><br><span class="line">        self.backgroundColor = attributes.sectionColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This method belongs to UICollectionReusableView because layout attributes are applicable to cells, supplementary views, and decoration views. First, you must call super’s implementation. Next, it checks to ensure that the layout attributes are an instance of our custom subclass before casting the pointer.</p></blockquote><p>注意：该方法声明在UICollectionReusableView类中，适用于cells、supplementary view、decoration views。首先你必须调用父类的实现，然后检查layoutAttributes是否自定义类的实例，来决定是否进行指针的强制转换。</p><h1 id="自定义UICollectionView各个Section的背景色"><a href="#自定义UICollectionView各个Section的背景色" class="headerlink" title="自定义UICollectionView各个Section的背景色"></a>自定义UICollectionView各个Section的背景色</h1><p>前面讲解了UICollectionViewLayoutAttributes的基本使用，使用的示例代码是为了能够达到自定义UICollectionView的各个Section的背景色。你可能对这个需求有疑惑，在UICollectionView中，每个Section中可以定义sectionInset、minimumLineSpacing、minimumInteritemSpacing属性值，而这些属性值定义的空白区域的背景色是与UICollectionView的背景色保持一致，当我们的需求中需要定义与UICollectionView的背景色不一致时，或者各个Section定义的背景色也各有区别时，</p><p>为了达到此目的，方案是在各个section中添加decoration view，然后设置decoration view的颜色就是各个section的背景色，具体的代码见<br><a href="https://github.com/carya/SectionBackgroundColor">github</a>中下载,如有错误之处，欢迎指正。</p><p>需要重点提出的是，如果你想在删除cell或者section的时候动态添加或者删除decoration view，你可能需要花点功夫来使cell的添加或者删除动画与decoration view的添加与删除动画保持同步。</p><blockquote><p>footerReferenceSize and headerReferenceSize During layout, only the size that corresponds to the appropriate scrolling direction is used. For example, for the vertical scrolling direction, the layout object uses the height value returned by your method. (In that instance, the width of the header would be set to the width of the collection view.) If the size in the appropriate scrolling dimension is 0, no header is added.</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>UICollectionViewLayoutAttributes使用场景，个人总结如下：<br>1.与DataSource无关，但想控制UIReusableView或者UICollectionViewCell的显示属性，例如在ViewController中配置UIImageView的显示模式。<br>2.UICollectionviewCell的某一属性需要跟随UICollectionViewLayout的改变而改变，例如CoverFlow类型的展示。</p><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;UICollectionViewLayoutAttributes是UICollectionView的重要组成部分，本文从其基本定义、如何使用以及使用场景几方面来简单介绍。文末以自定义UICollectionView各个Section的背景色的示例来展示UICollectionViewLayoutAttributes的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="UICollectionViewLayoutAttributes" scheme="http://liumh.com/tags/UICollectionViewLayoutAttributes/"/>
    
    <category term="UICollectionView" scheme="http://liumh.com/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的系统转场</title>
    <link href="http://liumh.com/2016/11/09/ios-system-presentation/"/>
    <id>http://liumh.com/2016/11/09/ios-system-presentation/</id>
    <published>2016-11-09T01:03:06.000Z</published>
    <updated>2018-11-19T23:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录的是对下图所示的<em>Kind</em>, <em>Presentation</em>, <em>Transition</em>的理解：</p><div class="figure left" style="width:260;"><img class="fig-img" src="/img/system-presentation/system-presentation.png" style="width:260;height:250;"alt="iOS系统转场"><span class="caption">iOS系统转场</span></div><div style="clear:both;"></div><span id="more"></span><p>目录如下：</p><ol><li><a href="#size-classes">Size Classes</a></li><li><a href="#presentation-kind">Kind转场类型</a><ul><li><a href="#presentation-kind-show">Show</a></li><li><a href="#presentation-kind-showdetail">Show Detail</a></li><li><a href="#presentation-kind-present-modally">Present Modally</a><ul><li><a href="#presentation-style">Presentation Styles</a></li><li><a href="#transiton-style">Transition Styles</a></li></ul></li><li><a href="#presenting-popover">Presenting a View Controller in a Popover</a></li></ul></li></ol><h1 id="Size-Classes"><a href="#Size-Classes" class="headerlink" title="Size Classes"></a>Size Classes</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录的是对下图所示的&lt;em&gt;Kind&lt;/em&gt;, &lt;em&gt;Presentation&lt;/em&gt;, &lt;em&gt;Transition&lt;/em&gt;的理解：&lt;/p&gt;
&lt;div class=&quot;figure left&quot; style=&quot;width:260;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;/img/system-presentation/system-presentation.png&quot; style=&quot;width:260;height:250;&quot;alt=&quot;iOS系统转场&quot;&gt;&lt;span class=&quot;caption&quot;&gt;iOS系统转场&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="转场" scheme="http://liumh.com/tags/%E8%BD%AC%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>创建模态视图</title>
    <link href="http://liumh.com/2016/10/03/swift-dim-background-viewcontroller/"/>
    <id>http://liumh.com/2016/10/03/swift-dim-background-viewcontroller/</id>
    <published>2016-10-03T01:48:56.000Z</published>
    <updated>2021-04-18T03:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的开发过程中，会遇到弹出模态视图进行交互的情况，用户实际操作区域只占屏幕的一部分，其余区域使用半透明黑色遮罩进行覆盖。下面就记录一下实现如下所示模态视图的方案。</p><span id="more"></span><div class="figure left" style="width:162;"><img class="fig-img" src="/img/modal-popup/modal-popup-window.gif" style="width:162;height:322;"alt="Popup_Window动画"><span class="caption">Popup_Window动画</span></div><div style="clear:both;"></div><p>这里有3种实现方案, 根据情况可选择合适的方案:</p><ol><li>添加视图到<code>ViewController.view.window</code>上</li><li>使用系统提供的模态转场</li><li>切换window</li></ol><h4 id="添加视图到ViewController-view-window上"><a href="#添加视图到ViewController-view-window上" class="headerlink" title="添加视图到ViewController.view.window上"></a>添加视图到<code>ViewController.view.window</code>上</h4><p>相信大多数人都对这种实现方式很熟悉。该方式是在当前视图的最上层添加一层自定义的黑色遮罩，然后在黑色遮罩上添加真正需要显示的视图，主要代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func showPopupView() &#123;</span><br><span class="line">    //1.创建黑色遮罩    </span><br><span class="line">    let screenRect = UIScreen.main.bounds;</span><br><span class="line">    var startFrame = screenRect;</span><br><span class="line">    startFrame.origin.x = screenRect.width;</span><br><span class="line">    dimmingView = UIView.init(frame: startFrame)</span><br><span class="line">    dimmingView.backgroundColor = UIColor.black.withAlphaComponent(0.6)</span><br><span class="line">    </span><br><span class="line">    let tapGesture = UITapGestureRecognizer.init(target: self, action: #selector(hiddenPopupView))</span><br><span class="line">    dimmingView.addGestureRecognizer(tapGesture)</span><br><span class="line">    </span><br><span class="line">    //2.创建用户真正关心的视图</span><br><span class="line">    var focusViewRect = screenRect</span><br><span class="line">    focusViewRect.size.width = 0.8 * screenRect.width</span><br><span class="line">    focusViewRect.origin.x = 0.2 * screenRect.width</span><br><span class="line">    let focusView = UIView.init(frame: focusViewRect)</span><br><span class="line">    focusView.backgroundColor = UIColor.init(red: 137.0/255.0, green: 1.0, blue: 152.0/255.0, alpha: 1)</span><br><span class="line">    </span><br><span class="line">    //3.添加视图到window上</span><br><span class="line">    dimmingView.addSubview(focusView)</span><br><span class="line">    self.view.window?.addSubview(dimmingView);</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.25, animations: &#123;</span><br><span class="line">        self.dimmingView.frame = screenRect</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func hiddenPopupView(_ sender: UITapGestureRecognizer) &#123;</span><br><span class="line">        </span><br><span class="line">    let screenRect = UIScreen.main.bounds;</span><br><span class="line">    var finalFrame = screenRect;</span><br><span class="line">    finalFrame.origin.x = screenRect.width;</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.25, animations: &#123;</span><br><span class="line">        self.dimmingView.frame = finalFrame</span><br><span class="line">        &#125;, completion: &#123; finished in</span><br><span class="line">        self.dimmingView.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方案时要注意，你若在模态视图中 <code>IQKeyboardManager</code> 第三方库不会起作用。</p><h4 id="使用系统提供的模态转场"><a href="#使用系统提供的模态转场" class="headerlink" title="使用系统提供的模态转场"></a>使用系统提供的模态转场</h4><p>按道理，这应该是代码量最小的实现方式，但是如果要实现本文开始所示动画(系统默认的是从屏幕底部往上推出视图)，则需要自定义动画。另外，由于能够透视遮罩下的视图，需要将弹出的ViewController的<code>modalPresentationStyle</code>设置成<code>UIModalPresentationOverFullScreen</code>, 而该枚举值是iOS 8.0以上才支持。</p><p>自定义转场动画的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class SlideSegue: UIStoryboardSegue &#123;</span><br><span class="line"></span><br><span class="line">    override func perform() &#123;</span><br><span class="line">        </span><br><span class="line">        destination.transitioningDelegate = self</span><br><span class="line">        super.perform()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension SlideSegue: UIViewControllerTransitioningDelegate &#123;</span><br><span class="line">    </span><br><span class="line">    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        </span><br><span class="line">        return SlideInAnimator()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">        </span><br><span class="line">        return SlideOutAnimator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// MARK - Animator</span><br><span class="line"></span><br><span class="line">class SlideInAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;</span><br><span class="line">        </span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        </span><br><span class="line">        let toViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to)!</span><br><span class="line">        let toView = transitionContext.view(forKey: UITransitionContextViewKey.to)</span><br><span class="line">        </span><br><span class="line">        if let toView = toView &#123;</span><br><span class="line">            transitionContext.containerView.addSubview(toView)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        let finalFrame = transitionContext.finalFrame(for: toViewController)</span><br><span class="line">        var startFrame = finalFrame</span><br><span class="line">        startFrame.origin.x = finalFrame.width</span><br><span class="line">    </span><br><span class="line">        toView?.frame = startFrame</span><br><span class="line">//        toView?.layoutIfNeeded()</span><br><span class="line">        </span><br><span class="line">        let duration = transitionDuration(using: transitionContext)</span><br><span class="line">        </span><br><span class="line">        UIView.animate(withDuration: duration, animations: &#123; </span><br><span class="line">            if let toView = toView &#123;</span><br><span class="line">                toView.frame = finalFrame</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, completion: &#123; finished in</span><br><span class="line">                transitionContext.completeTransition(true)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SlideOutAnimator:NSObject, UIViewControllerAnimatedTransitioning &#123;</span><br><span class="line">    </span><br><span class="line">    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;</span><br><span class="line">        </span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">     </span><br><span class="line">        let fromViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from)!</span><br><span class="line">        let toView = transitionContext.view(forKey: UITransitionContextViewKey.to)</span><br><span class="line">        let fromView = transitionContext.view(forKey: UITransitionContextViewKey.from)</span><br><span class="line">        </span><br><span class="line">        if let toView = toView &#123;</span><br><span class="line">            if let fromView = fromView &#123;</span><br><span class="line">                transitionContext.containerView.insertSubview(toView, belowSubview: fromView)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var finialFrame = transitionContext.finalFrame(for: fromViewController)</span><br><span class="line">        finialFrame.origin.x += finialFrame.width</span><br><span class="line">        </span><br><span class="line">        let duration = transitionDuration(using: transitionContext)</span><br><span class="line">        UIView.animate(withDuration: duration, animations: &#123; </span><br><span class="line">            if let fromView = fromView &#123;</span><br><span class="line">                fromView.frame = finialFrame</span><br><span class="line">//                fromView.layoutIfNeeded()</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, completion: &#123; finished in</span><br><span class="line">                transitionContext.completeTransition(true)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余部分的 Storyboard 设置参考 <a href="https://github.com/carya/PopupWindow">github上本工程代码</a>。</p><p>关于视图控制器的自定义转场，以后会单独写一篇来记录。</p><h4 id="切换window"><a href="#切换window" class="headerlink" title="切换window"></a>切换window</h4><p>这种实现方式的好处是将弹出的用户关心的视图封装到一个新的视图控制器中，与当前的视图控制器分离，从而使业务分离，避免当前的试图控制器臃肿。显示模态视图的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func showPopupViewController(_ sender: AnyObject) &#123;</span><br><span class="line">    checkoutNewWindow()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func checkoutNewWindow() &#123;</span><br><span class="line">    </span><br><span class="line">    var frame = UIScreen.main.bounds</span><br><span class="line">    frame.origin.x += frame.size.width</span><br><span class="line">    popWindow = UIWindow.init(frame: frame)</span><br><span class="line">    </span><br><span class="line">    let storyboard = UIStoryboard.init(name: &quot;Main&quot;, bundle: nil)</span><br><span class="line">    let popupViewController = storyboard.instantiateViewController(withIdentifier: &quot;PopupViewController&quot;)</span><br><span class="line">    popWindow.rootViewController = popupViewController</span><br><span class="line">    popWindow.makeKeyAndVisible()</span><br><span class="line">    </span><br><span class="line">    UIView.animate(withDuration: 0.5, animations: &#123;</span><br><span class="line">        let rect = UIScreen.main.bounds</span><br><span class="line">        self.popWindow.frame = rect</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本工程所有代码见<a href="https://github.com/carya/PopupWindow">github</a></p><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS的开发过程中，会遇到弹出模态视图进行交互的情况，用户实际操作区域只占屏幕的一部分，其余区域使用半透明黑色遮罩进行覆盖。下面就记录一下实现如下所示模态视图的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="swift" scheme="http://liumh.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Xcode使用xcconfig文件配置环境</title>
    <link href="http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/"/>
    <id>http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/</id>
    <published>2016-05-22T01:42:50.000Z</published>
    <updated>2021-04-18T03:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>与公司 QA 聊天，已不止一次被吐槽说移动端从开发环境转到生产环境时，还要靠修改代码来配置对应的环境参数。她认为，从 App 转测试之后，就不应该再修改代码，可以把所有的环境配置都整合到配置文件中，这样打不同环境下的安装包时，会自动选择对应的环境参数。这里说到的环境参数包括但不仅限于： webservice 地址，友盟 AppKey，极光推送 AppKey 和是否是生产环境标志等。</p><p>其实，我也讨厌修改环境参数啊，😂</p><p>为达成上述目的，主要是使用 Xcode 的 Configurations Setting File(即后缀为 xcconfig 文件) 来配置开发不同阶段下的环境。本文包含的内容如下:</p><span id="more"></span><ol><li><a href="#xcode-target">Xcode Target</a></li><li><a href="#xcode-project">Xcode Project</a></li><li><a href="#inherits-build-setting">Build Setting的继承关系</a></li><li><a href="#xcconfig-environment">如何使用xcconfig文件来配置不同开发阶段的环境</a></li></ol><p>包含了一些与 build settings 相关的知识。</p><h3 id="Xcode-Target"><a href="#Xcode-Target" class="headerlink" title="Xcode Target"></a>Xcode Target</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;与公司 QA 聊天，已不止一次被吐槽说移动端从开发环境转到生产环境时，还要靠修改代码来配置对应的环境参数。她认为，从 App 转测试之后，就不应该再修改代码，可以把所有的环境配置都整合到配置文件中，这样打不同环境下的安装包时，会自动选择对应的环境参数。这里说到的环境参数包括但不仅限于： webservice 地址，友盟 AppKey，极光推送 AppKey 和是否是生产环境标志等。&lt;/p&gt;
&lt;p&gt;其实，我也讨厌修改环境参数啊，😂&lt;/p&gt;
&lt;p&gt;为达成上述目的，主要是使用 Xcode 的 Configurations Setting File(即后缀为 xcconfig 文件) 来配置开发不同阶段下的环境。本文包含的内容如下:&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="Xcode" scheme="http://liumh.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的对象等同性</title>
    <link href="http://liumh.com/2016/01/06/ios-object-equal/"/>
    <id>http://liumh.com/2016/01/06/ios-object-equal/</id>
    <published>2016-01-06T14:23:20.000Z</published>
    <updated>2016-01-14T14:37:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>==</code> 比较 iOS 中的对象时，比较的是对象的指针。例如有如下比较时:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;origin1&quot;;</span><br><span class="line">NSString *strCopy = [str copy];</span><br><span class="line">NSString *str1 = [NSString stringWithFormat:@&quot;origin%@&quot;, @1];</span><br><span class="line">    </span><br><span class="line">BOOL equalA = (str == strCopy);</span><br><span class="line">BOOL equalB = (str == str1);</span><br><span class="line"></span><br><span class="line">BOOL equalC = [str isEqualToString:str1];  /**&lt; equalC is YES */</span><br><span class="line">BOOL equalD = [str isEqual:str1]; /**&lt; equalD is YES */</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>equalA</code> 的值会是 <code>YES</code>, 而 <code>equalB</code> 的值会是 <code>NO</code>，虽然 <code>str</code>、<code>str1</code>、<code>strCopy</code> 指针所指的对象的值都是 <code>origin1</code>。</p><p>比较对象时，我们应该使用 <code>NSObject</code> 协议中声明的 <code>isEqual:</code> 方法来判断两个对象的等同性。一般来说，两个类型不同的对象总是不相等的。</p><p><code>NSObject</code> 协议中有两个判断对象等同性的关键方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object;</span><br><span class="line">@property (readonly) NSUInteger hash;</span><br></pre></td></tr></table></figure><p><code>NSObject</code> 对这两个类的默认实现是:当且仅当其 “指针值” 完全相等时，这两个对象才相等。若想在自定义对象中正确覆写这两个方法，那么就必须先理解其约定: 如果 <code>isEqual:</code> 方法判断两个对象相等，那么其 <code>hash</code> 方法必须返回同一个值，但是如果两个对象的 <code>hash</code> 方法返回同一个值，<code>isEqual:</code> 方法未必会认为二者相等。</p><p>假如有如下类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ACLStudent : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSUInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>对于这样的自定义对象，可以像 <code>NSString</code> 的 <code>- (BOOL)isEqualToString:(NSString *)aString</code> 方法一样，创建一个属于该类的特定等同性方法。同时需要注意该类对象的使用场景，例如这里，我们在判定两个类对象是否相等时，不需要对象中的所有字段都判定相等，只需要其 <code>studentId</code> 相等就可判定两个对象表示的是同一个学生对象。方法实现像下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqualToStudent:(ACLStudent *)student &#123;</span><br><span class="line">    if (self == student) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.studentId == student.studentId) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议同时实现其 <code>isEqual:</code> 方法，像下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([self class] == [object class]) &#123;</span><br><span class="line">        return [self isEqualToStudent:object];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [super isEqual:object];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先比较其指针值，假如指针值相等，则对象相等，然后判断传入对象的类型，如果是类的类型，则调用类特定的等同性方法，否则交由父类来判断。</p><p>同时不要忘记覆写 <code>- (NSUInteger)hash</code> 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    return self.studentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在覆写类的 <code>hash</code> 方法时，要注意其有较高的执行效率，又能使生成的哈希码至少位于一定的范围内，不至于频繁的重复。编写 <code>hash</code> 方法时，可用当前的对象做实验，以便在减少哈希码碰撞频度与降低其运算复杂度之间取舍。</p><blockquote><p>假如类的 <code>hash</code> 方法计算值过于频繁的重复，在 <code>collection</code> 中使用这种对象将会产生性能问题，因为 <code>collection</code> 在检索哈希表时，会用对象的哈希码做索引。假如某个 <code>collection</code> 是用 <code>set</code> 实现的，那么 <code>set</code> 可能会根据哈希码把对象分装到不同的数组中。在向 <code>set</code> 中添加新对象时，要根据哈希码找到与之相关的那个数组，依次检查其中的各个元素，看数组中已有的对象是否和将要添加的对象相等。如果相等，那就说明要添加的对象已经在 <code>set</code> 中了。由此可知，如果令每个对象的都返回相同的哈希码，那么在 <code>set</code> 中已有 1000000 个对象的情况下，若是继续向其中添加对象，则需要将这 1000000 个对象全部扫描一遍。</p></blockquote><p>例如下面两种实现方法, 方法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSString *stringToHash = [NSString stringWithFormat:@&quot;%@:%@:%@&quot;, @(self.studentId), self.firstName, self.lastName];</span><br><span class="line">    return [stringToHash hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    NSUInteger firstNameHash = [self.firstName hash];</span><br><span class="line">    NSUInteger lastNameHash = [self.lastName hash];</span><br><span class="line">    return firstNameHash ^ lastNameHash ^ self.studentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2 比 方法1 更好，减少了创建字符串的开销，同时其哈希值不至于频繁重复。</p><p>注意，我们把对象放入 <code>collection</code> 之后，就不应再改变其哈希码了。前面讲过，<code>collection</code> 会把各个对象按照其哈希码分装到不同的”箱子数组”中。如果某个对象在放入”箱子”之后哈希码又变了，那么其现在所处的箱子对它来说是”错误”的。要解决这个问题，需要确保哈希码不是根据对象的“可变部分”(mutable portion)计算出来的，或者保证放入 <code>collection</code> 之后就不再改变对象的内容了。</p><p>本文来自 <code>&lt;&lt;Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法&gt;&gt;</code></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;==&lt;/code&gt; 比较 iOS 中的对象时，比较的是对象的指针。例如有如下比较时:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *str = @&amp;quot;origin1&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *strCopy = [str copy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str1 = [NSString stringWithFormat:@&amp;quot;origin%@&amp;quot;, @1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalA = (str == strCopy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalB = (str == str1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalC = [str isEqualToString:str1];  /**&amp;lt; equalC is YES */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL equalD = [str isEqual:str1]; /**&amp;lt; equalD is YES */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS理解NSCopying协议</title>
    <link href="http://liumh.com/2015/12/12/ios-understand-copy/"/>
    <id>http://liumh.com/2015/12/12/ios-understand-copy/</id>
    <published>2015-12-12T14:04:30.000Z</published>
    <updated>2021-04-18T03:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何让自定义对象支持 copy 操作？是重写 copy 方法么？当然不是，而是需要让自定义类实现 NSCopying 协议，该协议只有一个方法:</p><span id="more"></span><p><code>- (id)copyWithZone:(nullable NSZone *)zone;</code></p><p>以前开发程序时，会把内存分成不同的”区”，而对象会创建在某个区里。现在不用了，每个程序只有一个”默认区”(default zone)，实现该方法时，不必担心其中的 zone 参数。例如，我们要让自定义的 <code>ACLStudent</code> 类支持拷贝功能，则可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@interface ACLStudent : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line">@end</span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">ACLStudent.m</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    ACLStudent *copy = [[[self class] allocWithZone:zone] initWithStudentId:_studentId firstName:_firstName lastName:_lastName];</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上例中 <code>copyWithZone:</code> 方法使用了全能初始化方法(designated initializer)来执行拷贝对象的所有初始化工作。这里需要注意，对于未能在全能初始化方法中设置好的变量，需要在 <code>copyWithZone:</code> 方法中做特殊处理。例如，如果在 <code>ACLStudent</code> 类中增加一个变量，来存储当前学生所选选修课的科目，完整代码变成如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@class ACLCourse;</span><br><span class="line">@interface ACLStudent : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">- (void)addElective:(ACLCourse *)course;</span><br><span class="line"></span><br><span class="line">- (void)removeElective:(ACLCourse *)course;</span><br><span class="line">@end</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent &#123;</span><br><span class="line">    NSMutableSet *_electives;  /**&lt; 选修科目 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">        </span><br><span class="line">        _electives = [NSMutableSet new];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addElective:(ACLCourse *)course &#123;</span><br><span class="line">    [_electives addObject:course];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeElective:(ACLCourse *)course &#123;</span><br><span class="line">    [_electives removeObject:course];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    ACLStudent *copy = [[[self class] allocWithZone:zone] initWithStudentId:_studentId firstName:_firstName lastName:_lastName];</span><br><span class="line">    copy-&gt;_electives = [[NSMutableSet alloc] initWithSet:_electives copyItems:YES];</span><br><span class="line">    </span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>注意全能初始化方法和 <code>copyWithZone:</code> 方法实现的变化, 这里我们对 <code>_electives</code> 对象执行的是深拷贝。</p><p>假如我们想让自定义对象支持 <code>mutableCopy</code> 操作，那又应该怎么操作呢?这需要自定义对象遵循 <code>NSMutableCopying</code> 协议, 该协议也只有一个方法:</p><p><code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code></p><p>其与 copy 相似，也是使用默认的 zone 参数来调用 <code>mutableCopyWithZone:</code>。</p><p>如果类分为可变版本和不可变版本，那么就应该实现 <code>NSMutableCopying</code>, 且在可变类中覆写 <code>copyWithZone:</code> 方法时，应该返回一份不可变的版本。无论当前实例是否可变，若需获取其可变版本的拷贝，均应调用 <code>mutableCopy</code> 方法，若需不可变的拷贝，则总应该调用 <code>copy</code> 方法。例如对于不可变的 NSArray 和可变的 NSMutableArray，以下关系总是成立:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure><hr><p>如何对 <code>NSArray</code> 执行深拷贝呢？苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html">Copying Collections</a> 提供了以下两种方法。</p><p>方法1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES];</span><br></pre></td></tr></table></figure><p>这种方式执行拷贝时，<code>someArray</code> 中的可变对象是执行深拷贝，而对于不可变对象，仍然执行的是浅拷贝。</p><p>方法2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];</span><br></pre></td></tr></table></figure><p>这种方式实现的是真正意义上的深拷贝，<code>oldArray</code> 中所有元素都是深拷贝。         </p><p>那么 <code>copy</code> 和 <code>mutableCopy</code> 返回的对象是执行的深拷贝还是浅拷贝呢？这篇博客 [copy与mutableCopy][] 对系统对象执行 <code>copy</code> 和 <code>mutableCopy</code> 时到底执行的深拷贝还是浅拷贝进行了讨论。其中系统对象分为了两类:</p><ul><li>系统的非容器类对象，如 <code>NSString</code>、<code>NSMutableString</code>、<code>NSNumber</code> 等。</li><li>系统的容器类对象，如 <code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code> 等。</li></ul><p>现把结论摘抄如下:</p><ol><li>对于系统的非容器类对象，如果对一不可变对象(如 <code>NSString</code>)复制，<code>copy</code> 是指针复制(浅拷贝)和 <code>mutableCopy</code> 就是对象复制(深拷贝); 如果是对可变对象(如 <code>NSMutableString</code>)复制，<code>copy</code> 和 <code>mutableCopy</code> 都是深拷贝，但是 <code>copy</code> 返回的对象是不可变的。</li><li>对于系统的容器类对象，对不可变对象(如 <code>NSArray</code>)进行复制，<code>copy</code> 是指针复制(浅拷贝)， <code>mutableCopy</code> 是对象复制(深拷贝), 但是不管是 <code>copy</code> 还是 <code>mutableCopy</code>, 且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。</li><li>对于系统的容器类对象，对可变对象(如 <code>NSMutableArray</code>)进行复制时，<code>copy</code> 和 <code>mutableCopy</code> 都是对象复制(深拷贝)，但是不管是 <code>copy</code> 还是 <code>mutableCopy</code>，且不论容器内对象是可变还是不可变，返回的容器内对象都是指针复制(浅拷贝)。</li></ol><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何让自定义对象支持 copy 操作？是重写 copy 方法么？当然不是，而是需要让自定义类实现 NSCopying 协议，该协议只有一个方法:&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS修改声明为readonly的属性值</title>
    <link href="http://liumh.com/2015/12/08/ios-change-readonly-property/"/>
    <id>http://liumh.com/2015/12/08/ios-change-readonly-property/</id>
    <published>2015-12-08T14:03:24.000Z</published>
    <updated>2021-04-18T03:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论的是，对于类中声明为 readonly 的属性值，我们就不可以修改其值了么？如何可以，那么如何修改呢？</p><p>为了便于说明，定义一个 <code>ACLStudent</code> 的类:</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACLStudent.h</span><br><span class="line"></span><br><span class="line">@interface ACLStudent : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSInteger studentId;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line">ACLStudent.m</span><br><span class="line"></span><br><span class="line">@implementation ACLStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithStudentId:(NSInteger)studentId firstName:(NSString *)firstName lastName:(NSString *)lastName &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _studentId = studentId;</span><br><span class="line">        _firstName = [firstName copy];</span><br><span class="line">        _lastName = [lastName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来定义一个 <code>ACLStudent</code> 类的对象:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACLStudent *student = [[ACLStudent alloc] initWithStudentId:1 firstName:@&quot;Carya&quot; lastName:@&quot;Liu&quot;];</span><br><span class="line">NSLog(@&quot;student firstName: %@&quot;, student.firstName);</span><br></pre></td></tr></table></figure><p>现在我们考虑的就是如何修改 <code>student</code> 对象的 <code>firstName</code> 属性值为<code>@&quot;Qiu&quot;</code>。</p><p>如果直接调用 <code>firstName</code> 的 setter 方法，<code>student.firstName = @&quot;Qiu&quot;</code>, 那么就直接报错，提示不能够给声明为 readonly 的属性赋值。那么使用 KVC 呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[student setValue:@&quot;Qiu&quot; forKey:NSStringFromSelector(@selector(firstName))];</span><br><span class="line">NSLog(@&quot;student firstName after changed: %@&quot;, student.firstName);</span><br></pre></td></tr></table></figure><p>运行，发现属性值被成功修改。哈哈，那么现在来看看 KVC 为什么能够修改该属性值呢？看看文档 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/SearchImplementation.html">Accessor Search Implementation Details</a>。</p><p>当使用  <code>setValue:forKey:</code> 来设置对象的属性时，会以下面的优先顺序来寻找对应的 <code>key</code>：</p><ol><li>消息接收对象会查找是否存在满足 <code>set&lt;Key&gt;:</code> 格式的存取方法。</li><li>如果不存在满足条件的存取方法，且消息接收对象的类方法 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回 YES，那么该对象会以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找是否存在对应的key。</li><li>如果存在对应的存取方法或者找到对应的实例变量，那么就会改变该 key 所对应的值 value。必要的话，value 所对应的值会从对象中解析出来，如 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/DataTypes.html#//apple_ref/doc/uid/20002171-184696">Representing Non-Object Values</a> 所描述的那样。</li><li>如果没有找到对应的存取方法或者实例变量，那么该消息对象的 <code>setValue:forUndefinedKey:</code> 将会调用。</li></ol><p>对于上述第2点说明一下，如果我们不想让 <code>setValue:forKey:</code> 方法改变对象的属性值，那么重写其类方法 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回 NO (该方法默认返回 YES，即在不存在满足条件的存取方法时，允许直接访问属性对应的实例变量)；在搜索实例变量时，会首先检查带下划线的实例变量，然后检查不带下划线的实例变量。</p><p>对于上述第3点举例说明，如果修改 <code>student</code> 对象的属性 <code>NSInteger studentId</code>, 注意其是 <code>NSInteger</code> 类型，我们在调用 <code>setValue:forKey:</code> 方法时可以像这样</p><p><code>[student setValue:@(20) forKey:NSStringFromSelector(@selector(studentId))];</code></p><p>传入一个 <code>NSNumber</code> 对象也可以，Objective-C 会处理好一切。</p><p>对于上面的示例，使用 <code>setValue:forKey:</code> 实际修改的是 student 实例中 <code>_firstName</code> 实例变量的值。不要忘记，我们在声明一个 <code>firstName</code> 的属性时，编译器会为我们自动合成一个 <code>_firstName</code> 的实例变量。</p><p>总结: </p><ul><li>当我们声明一个 readonly 的属性，外部可能会通过 KVC 修改该属性值。</li><li>为了避免 KVC 修改属性值，须将定义属性所在类的类方法 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 重写，使其返回 NO.</li></ul><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讨论的是，对于类中声明为 readonly 的属性值，我们就不可以修改其值了么？如何可以，那么如何修改呢？&lt;/p&gt;
&lt;p&gt;为了便于说明，定义一个 &lt;code&gt;ACLStudent&lt;/code&gt; 的类:&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="KVC" scheme="http://liumh.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>iOS中这样写注释</title>
    <link href="http://liumh.com/2015/12/07/ios-how-to-documentation/"/>
    <id>http://liumh.com/2015/12/07/ios-how-to-documentation/</id>
    <published>2015-12-07T13:58:31.000Z</published>
    <updated>2021-04-18T03:47:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录的是如何更好的编写注释。好的注释，可以让使用者能够像使用官方文档一样，使用 <code>option + 单击</code> 就可查看其使用说明。</p><span id="more"></span><p>对于枚举类型，可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 定义的HTTP请求类型 */</span><br><span class="line">typedef NS_ENUM(NSUInteger, ACLApiManagerRequestType) &#123;</span><br><span class="line">    ACLApiManagerRequestTypeGet,   /**&lt; Get请求 */</span><br><span class="line">    ACLApiManagerRequestTypePost,  /**&lt; Post请求 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请自行注意注释使用的符号, 注释枚举值和枚举类型时使用的符号也有差别。</p><p>对于属性，可以像如下这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, readonly) NSString *errorMessage;  /**&lt; 错误信息说明 */</span><br></pre></td></tr></table></figure><p>对于方法的注释，强烈建议安装喵神的插件<a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a>。然后在方法上部连续键入<code>///</code>触发插入注释，然后删除 placeholder 的地方，填入实际的注释说明，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  &lt;#Description#&gt;</span><br><span class="line"> *</span><br><span class="line"> *  @param manager &lt;#manager description#&gt;</span><br><span class="line"> *  @param data    &lt;#data description#&gt;</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line"> - (BOOL)manager:(ACLAPIBaseManager *)manager isCorrectWithParamsData:(NSDictionary *)data;</span><br></pre></td></tr></table></figure><p>但是对于没有参数的方法，或者我们觉得方法的命名自解释已经很清楚了，则可以像如下注释:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** API 请求除 base url 之外的 url部分 */</span><br><span class="line">- (NSString *)methodName;</span><br></pre></td></tr></table></figure><p>使用 <code>|</code> 来引用注释中的变量名及符号名而不是使用引号。</p><p>这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号 <code>count</code> ：</p><p><code>// Sometimes we need |count| to be less than zero.</code></p><p>参考: </p><p><a href="http://nshipster.com/documentation/">Documentation</a></p><hr><p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录的是如何更好的编写注释。好的注释，可以让使用者能够像使用官方文档一样，使用 &lt;code&gt;option + 单击&lt;/code&gt; 就可查看其使用说明。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动打包并发布脚本</title>
    <link href="http://liumh.com/2015/11/25/ios-auto-archive-ipa/"/>
    <id>http://liumh.com/2015/11/25/ios-auto-archive-ipa/</id>
    <published>2015-11-25T13:38:11.000Z</published>
    <updated>2024-10-20T06:21:41.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文最终实现的是使用脚本打 Ad-hoc 包，并发布测试，当然稍微修改一下脚本参数就可以打其他类型的 ipa 包了。另外该脚本还实现了将生成的 ipa 包上传至蒲公英进行测试分发。</p><span id="more"></span><ol><li><a href="#overview-about-xcodebuild">xcodebuild 简介</a></li><li><a href="#build-and-sign-ipa">使用xcodebuild和xcrun打包签名</a></li><li><a href="#script-build">将打包过程脚本化</a></li></ol><h2 id="xcodebuild-简介"><a href="#xcodebuild-简介" class="headerlink" title="xcodebuild 简介"></a>xcodebuild 简介</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文最终实现的是使用脚本打 Ad-hoc 包，并发布测试，当然稍微修改一下脚本参数就可以打其他类型的 ipa 包了。另外该脚本还实现了将生成的 ipa 包上传至蒲公英进行测试分发。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈iOS中的命名规范</title>
    <link href="http://liumh.com/2015/11/19/ios-talk-naming-guide/"/>
    <id>http://liumh.com/2015/11/19/ios-talk-naming-guide/</id>
    <published>2015-11-19T14:59:16.000Z</published>
    <updated>2021-04-18T03:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文谈谈 iOS 开发中的命名规范，主要涉及常量命名、枚举命名、类及其方法命名，以及分类及其方法命名。如果你找的是官网的编码规范，请移步: [Coding Guidelines for Cocoa][]。当然本文会讲一些官网没有的东西。</p><span id="more"></span><ul><li><a href="#name-const">常量命名</a></li><li><a href="#name-enum">用枚举表示状态、选项、状态码</a></li><li><a href="#name-class">类及其方法命名</a></li><li><a href="#name-category">分类及其方法命名</a></li></ul><h1 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文谈谈 iOS 开发中的命名规范，主要涉及常量命名、枚举命名、类及其方法命名，以及分类及其方法命名。如果你找的是官网的编码规范，请移步: [Coding Guidelines for Cocoa][]。当然本文会讲一些官网没有的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS屏幕适配</title>
    <link href="http://liumh.com/2015/10/21/ios-image-related-matching/"/>
    <id>http://liumh.com/2015/10/21/ios-image-related-matching/</id>
    <published>2015-10-21T14:16:35.000Z</published>
    <updated>2021-04-18T03:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，屏幕适配也是项很重要的工作，本文记录了一些在屏幕适配的过程中与图片相关的工作。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先，理解几个概念: Points, Rendered Pixels, Physical Pixels, Physical Device。</p><ul><li>Points: 是iOS开发中引入的抽象单位，称作点。开发过程中所有基于坐标系的绘制都是以 point 作为单位，在iPhone 2G,3G,3GS的年代，point 和屏幕上的像素是完全一一对应的，即 320 * 480 (points), 也是 320 * 480 (pixels)</li><li>Rendered Pixels: 渲染像素， 以 point 为单位的绘制最终都会渲染成 pixels，这个过程被称为光栅化。基于 point 的坐标系乘以比例因子可以得到基于像素的坐标系，高比例因子会使更多的细节展示，目前的比例因子会是 1x，2x，3x</li><li>Physical Pixels: 物理像素，就是设备屏幕实际的像素</li><li>Physical Device: 设备屏幕的物理长度，使用英寸作为单位。比如iPhone 4屏幕是3.5英寸，iPhone 5 是4英寸，iphone 6是4.7英寸，这里的数字是指手机屏幕对角线的物理长度。实际上会是Physical Pixels的像素值(而不是Rendered Pixels的像素值)会渲染到该屏幕上, 屏幕会有 PPI(pixels-per-inch) 的特性，PPI 的值告诉你每英寸会有多少像素渲染。</li></ul><span id="more"></span><p>那么，iOS 开发中，上述单位会有什么对应关系呢？列表回答:</p><table><thead><tr><th align="center">机型</th><th align="center">屏幕宽高(point)</th><th align="center">渲染像素(pixel)</th><th align="center">物理像素(pixel)</th><th align="center">屏幕对角线长度(英寸)</th><th align="center">屏幕模式</th></tr></thead><tbody><tr><td align="center">iPhone 2G, 3G, 3GS</td><td align="center">320 * 480</td><td align="center">320 * 480</td><td align="center">320 * 480</td><td align="center">3.5(163PPI)</td><td align="center">1x</td></tr><tr><td align="center">iPhone 4, 4s</td><td align="center">320 * 480</td><td align="center">640 * 960</td><td align="center">640 * 960</td><td align="center">3.5 (326PPI)</td><td align="center">2x</td></tr><tr><td align="center">iPhone 5, 5s</td><td align="center">320 * 568</td><td align="center">640 * 1136</td><td align="center">640 * 1136</td><td align="center">4 (326PPI)</td><td align="center">2x</td></tr><tr><td align="center">iPhone 6, 6s</td><td align="center">375 * 667</td><td align="center">750 * 1334</td><td align="center">750 * 1334</td><td align="center">4.7 (326PPI)</td><td align="center">2x</td></tr><tr><td align="center">iPhone 6 Plus, 6s Plus</td><td align="center">414 * 736</td><td align="center">1242 * 2208</td><td align="center">1080 * 1920</td><td align="center">5.5 (401PPI)</td><td align="center">3x</td></tr></tbody></table><p>关于上述关系 PaintCode 绘制图形进行了详细说明，可以移步查看 <a href="http://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">The Ultimate Guide To iPhone Resolutions</a>.</p><p>由上可以看出，所谓的屏幕模式，描述的就是屏幕中一个点有多少个 Rendered Pixels 渲染，对于2倍屏(又称 Retina 显示屏)，会有 2 * 2 &#x3D; 4 个像素的面积渲染，对于3倍屏(又称 Retina HD 显示屏)，会有 3 * 3 &#x3D; 9 个像素的面积渲染。</p><p>关于 Points 和 Pixels 的描述，参考官方文档: <a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html#//apple_ref/doc/uid/TP40010156-CH14-SW7">Points Versus Pixels</a>.</p><p>iOS 开发中，所有控件的坐标以及控件大小都是以点为单位的，假如我在屏幕上需要展示一张 20 * 20 (单位：point)大小的图片，那么设计师应该怎么给我图呢？这里就会用到屏幕模式的概念，如果屏幕是 2x，那么就需要提供 40 * 40 (单位: pixel)大小的图片，如果屏幕是 3x，那么就提供 60 * 60 大小的图片，且图片的命名需要遵守以下规范:</p><ul><li>Standard: <code>&lt;ImageName&gt;&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li><li>High resolution: <code>&lt;ImageName&gt;@2x&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li><li>High HD resolution: <code>&lt;ImageName&gt;@3x&lt;device_modifier&gt;.&lt;filename_extension&gt;</code></li></ul><p>其中</p><ul><li>ImageName: 图片名字，根据场景命名</li><li>device_modifier: 可选，可以是 <code>~ipad</code> 或者 <code>~iphone</code>, 当需要为 iPad 和 iPhone 分别指定一套图时需要加上此字段</li><li>filename_extension: 图片后缀名，iOS中使用 png 图片</li></ul><p>例如:</p><ul><li><p>MyImage.png - 1x 显示屏自动加载的图片版本</p></li><li><p><a href="mailto:&#x4d;&#121;&#x49;&#109;&#97;&#103;&#x65;&#64;&#50;&#120;&#46;&#x70;&#110;&#x67;">&#x4d;&#121;&#x49;&#109;&#97;&#103;&#x65;&#64;&#50;&#120;&#46;&#x70;&#110;&#x67;</a> - 2x 显示屏自动加载的图片版本</p></li><li><p><a href="mailto:&#x4d;&#x79;&#73;&#109;&#x61;&#x67;&#101;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#103;">&#x4d;&#x79;&#73;&#109;&#x61;&#x67;&#101;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#103;</a> - 3x 显示屏自动加载的图片版本</p></li><li><p>MyImage@2x~iphone.png - 2x iPhone 和 iPod touch 显示屏自动加载的图片版本</p></li><li><p>MyImage@3x~iphone.png - 3x iPhone and iPod 显示屏自动加载的图片版本</p></li></ul><p>2x屏幕的设备会自动加载 <a href="mailto:&#x78;&#120;&#x78;&#64;&#x32;&#x78;&#x2e;&#x70;&#x6e;&#x67;">&#x78;&#120;&#x78;&#64;&#x32;&#x78;&#x2e;&#x70;&#x6e;&#x67;</a> 命名的图片资源，3x屏幕的设备会自动加载 <a href="mailto:&#x78;&#x78;&#x78;&#x40;&#x33;&#120;&#x2e;&#x70;&#110;&#x67;">&#x78;&#x78;&#x78;&#x40;&#x33;&#120;&#x2e;&#x70;&#110;&#x67;</a> 的图片, 现在基本没有 1x屏幕的设备了，可以不用提供这个分辨率的图片了。</p><h3 id="研发工作流程"><a href="#研发工作流程" class="headerlink" title="研发工作流程"></a>研发工作流程</h3><p>现在iPhone的屏幕尺寸也不再单一，那么现在以怎样的流程来进行iOS的研发更合适呢？这个问题知乎上<a href="http://www.zhihu.com/question/25308946">这个问题</a>讨论很完善了，这里把<a href="http://www.zhihu.com/question/25308946/answer/32240185">手机淘宝设计师pigtwo的回答</a>部分转来如下:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/iOS_Adaptive.png" alt="手机淘宝团队适配协作模式"><span class="caption">手机淘宝团队适配协作模式</span></div><div style="clear:both;"></div><p>第一步，视觉设计阶段，设计师按宽度750px（iPhone 6）做设计稿，除图片外所有设计元素用矢量路径来做。设计定稿后在750px的设计稿上做标注，输出标注图。同时等比放大1.5倍生成宽度1125px的设计稿，在1125px的稿子里切图。</p><p>第二步，输出两个交付物给开发工程师：一个是程序用到的@3x切图资源，另一个是宽度750px的设计标注图。</p><p>第三步，开发工程师拿到750px标注图和@3x切图资源，完成iPhone 6（375pt）的界面开发。此阶段不能用固定宽度的方式开发界面，得用自动布局（auto layout），方便后续适配到其它尺寸。</p><p>第四步，适配调试阶段，基于iPhone 6的界面效果，分别向上向下调试iPhone 6 plus（414pt）和iPhone 5S及以下（320pt）的界面效果。由此完成大中小三屏适配。</p><p>为什么选择iPhone 6作为基准尺寸？当面对大中小三种屏幕需要适配的时候，很容易想到先做好一种屏幕，再去适配剩下两种屏幕。第一个决定是到底以哪种屏幕作为设计和开发的基准尺寸。我们选择中间尺寸的iPhone 6（750px&#x2F;375pt）作为基准，基于几个原因：</p><ol><li>从中间尺寸向上和向下适配的时候界面调整的幅度最小。375pt下的设计效果适配到414pt和320pt偏差不会太大。假设以414pt为基准做出很优雅的设计，到320pt可能元素之间比例就不是那么回事了，比如图片和文字之间视觉比例可能失调。</li><li>iPhone 6 plus有两种显示模式，标准模式分辨率为1242x2208，放大模式分辨率为1125x2001（即iPhone 6的1.5倍）。可见官方系统里iPhone 6和iPhone 6 plus分辨率之间就存在1.5倍的倍率关系。很多情况下这两种尺寸可以用1.5倍直接等比适配。</li><li>1242x2208这个奇葩的数值是苹果官方都不愿意公开宣传的一个分辨率，不便于记忆和计算栅格。640x1136虽然是广泛应用的一个分辨率，但是大屏时代依然以小尺寸为设计基准显然不合时宜，设计师会停留在小屏的视角做设计。所以，iPhone6的750x1334是最适合基准尺寸。</li></ol><p>只交付一套设计稿，默认用什么规则来适配？</p><p>前文提到适配策略是先选择iPhone 6作为基准设计尺寸，然后通过一套适配规则自动适配到另外两种尺寸。这套适配规则总结起来就一句话：文字流式，控件弹性，图片等比缩放。</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/iOS_Adaptive_layout.png" alt=""></div><div style="clear:both;"></div><p>控件弹性指的是，navigation、cell、bar 等适配过程中垂直方向上高度不变；水平方向宽度变化时，通过调整元素间距或元素右对齐的方式实现自适应。这样屏幕越大，在垂直方向上可以显示更多内容，发挥大屏幕的优势。</p><h3 id="图片的Resize处理"><a href="#图片的Resize处理" class="headerlink" title="图片的Resize处理"></a>图片的Resize处理</h3><p><code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets</code> 可以使用此方法生成一个新的图片，其参数 capInsets 是个结构体，可用 <code>UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)</code> 定义，由 top，left，bottom，right 参数定义的区域在拉伸时会保持不变，其中 top、left、bottom、right 的单位都是 point ，以实例说明该方法的使用吧。</p><p>实例1，从下图左边的原图，水平拉伸想得到右边的图片:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_stretches.png" alt="图片 Stretches"><span class="caption">图片 Stretches</span></div><div style="clear:both;"></div><p>保持图片左边(包括下三角处)在图片的水平拉伸处理中保持原样不变，通过代码设置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *img = [UIImage imageNamed:@&quot;popup&quot;];</span><br><span class="line">img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(0, 13, 0, 55) resizingMode:UIImageResizingModeStretch];</span><br><span class="line">self.resizableImgView.image = img;</span><br></pre></td></tr></table></figure><p>其中 CapInsets 的 left 值为 13 point，right 值为 55 point，这个值的确定需要根据具体图片其保持不变的区域来确定，目前，也可以通过 Xcode xcassets 的 Slicing 功能完成，如下图所示:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_stretches_slicing.png" alt="Xcode 中使用 Slicing 功能拉伸处理图片"><span class="caption">Xcode 中使用 Slicing 功能拉伸处理图片</span></div><div style="clear:both;"></div><p>其中红色框 Slices 处可以控制该图片是水平拉伸(Horizontal)，垂直拉伸(Vertical)或者水平垂直方向同时(Horizontal and Vertical)拉伸, 其值 Left 26，Right 110 单位是 pixels，我们通过API <code>resizableImageWithCapInsets</code> 设置时，需要联合红色框 Scale 处的值转换为单位为 point 的值，红色框 Center 处的值控制图片变换的方式，这里 Stretches 表示将 width 为 4 pixels 的图片区域进行拉伸，还有另一种方式 Tiles，表示将设置的区域进行平铺，这种方式稍后以实例2来说明。红色框 Slices 和 Center 处的数值可以直接改变输入框中的数值改变，也可以拖动左侧图片中的竖直虚线设置，可以自己试试。</p><p>实例2，从下图左边的原图，将图片指定区域平铺想得到右边的图片:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_tiles.png" alt="图片 Tiles"><span class="caption">图片 Tiles</span></div><div style="clear:both;"></div><p>将图片中五角星的图样进行平铺，通过代码设置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImage *img = [UIImage imageNamed:@&quot;about&quot;];</span><br><span class="line">img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(0, 11.5, 0, 11) resizingMode:UIImageResizingModeTile];</span><br><span class="line">self.resizableImgView.image = img;</span><br></pre></td></tr></table></figure><p>请注意，这里 <code>resizingMode</code> 的值设置成 <code>UIImageResizingModeTile</code>，表示图片的处理方式。由于这里只是水平平铺，所以其 top 和 bottom 都是 0，left 和 right 的值都是根据需要平铺的区域来设定。同样，这也可以通过 Xcode xcassets 的 Slices 来完成。如下图所示:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_tiles_slicing.png" alt="Xcode 中使用 Slicing 功能平铺处理图片"><span class="caption">Xcode 中使用 Slicing 功能平铺处理图片</span></div><div style="clear:both;"></div><p>从上述可以看出，善于 Xcode 可以减少代码量，以更快完成开发任务。</p><h3 id="启动图设置"><a href="#启动图设置" class="headerlink" title="启动图设置"></a>启动图设置</h3><p>如果你认为启动图同屏幕适配没有半毛钱关系，那就错了，例如，如果你把 Launch Screen File 处清空，使用iPhone5s模拟器启动运行程序，你会看到下图:</p><div class="figure left" style="width:;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/img/image-related/img_Adaptive_launchimage.png" alt=""></div><div style="clear:both;"></div><p>红线框处是项目的设置，右边是 iPhone5s 的运行结果，屏幕上下都留有黑条，这是因为没有设置对应的启动图所致，只要在 Assets.xcassets 的 LaunchImage 处添加对应的启动图就可以了。</p><p>不过，现在 Xcode7 新建项目时，项目中就自动创建了 LaunchScreen.storyboard 的启动画面文件了，不过若要适配 iOS7.1 及 iOS7.1 以下的低版本，还是需要设置启动图片的。</p><p>文中如果有错误之处请指正，或者你有任何问题请留言。</p><hr><p>如果觉得本文对你有帮助，就请用微信打赏我吧^_^</p><div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS开发中，屏幕适配也是项很重要的工作，本文记录了一些在屏幕适配的过程中与图片相关的工作。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;首先，理解几个概念: Points, Rendered Pixels, Physical Pixels, Physical Device。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Points: 是iOS开发中引入的抽象单位，称作点。开发过程中所有基于坐标系的绘制都是以 point 作为单位，在iPhone 2G,3G,3GS的年代，point 和屏幕上的像素是完全一一对应的，即 320 * 480 (points), 也是 320 * 480 (pixels)&lt;/li&gt;
&lt;li&gt;Rendered Pixels: 渲染像素， 以 point 为单位的绘制最终都会渲染成 pixels，这个过程被称为光栅化。基于 point 的坐标系乘以比例因子可以得到基于像素的坐标系，高比例因子会使更多的细节展示，目前的比例因子会是 1x，2x，3x&lt;/li&gt;
&lt;li&gt;Physical Pixels: 物理像素，就是设备屏幕实际的像素&lt;/li&gt;
&lt;li&gt;Physical Device: 设备屏幕的物理长度，使用英寸作为单位。比如iPhone 4屏幕是3.5英寸，iPhone 5 是4英寸，iphone 6是4.7英寸，这里的数字是指手机屏幕对角线的物理长度。实际上会是Physical Pixels的像素值(而不是Rendered Pixels的像素值)会渲染到该屏幕上, 屏幕会有 PPI(pixels-per-inch) 的特性，PPI 的值告诉你每英寸会有多少像素渲染。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="AutoLayout" scheme="http://liumh.com/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 百分比布局</title>
    <link href="http://liumh.com/2015/09/27/ios-autolayout-multiplier/"/>
    <id>http://liumh.com/2015/09/27/ios-autolayout-multiplier/</id>
    <published>2015-09-27T00:55:16.000Z</published>
    <updated>2015-10-20T13:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录如何在 UIStoryboard 或者 xib 中进行百分比布局，包括</p><ul><li>View.Width 占其 Superview.Width 的百分比</li><li>View.Leading 与 Superview.Leading 间距占 Superview.Width 的百分比</li><li>View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比</li><li>View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比</li><li>限定View的宽高比</li><li>以 Superview.Width 宽度的某一百分比为 View 之间的间隔</li></ul><span id="more"></span><p>在 <a href="/2015/08/11/ios-autolayout-priority/" title="iOS NSLayoutConstraint priority">iOS NSLayoutConstraint priority</a> 一文中提到过 multiplier, 上述提到的百分比布局都是基于 multiplier 实现的，下面来一一查看其实现。</p><h4 id="View-Width-占其-Superview-Width-的百分比"><a href="#View-Width-占其-Superview-Width-的百分比" class="headerlink" title="View.Width 占其 Superview.Width 的百分比"></a>View.Width 占其 Superview.Width 的百分比</h4><p>该功能实现很简单，以一个居中的按钮 Button 为例，首先将按钮相对于父容器添加 <code>Equal Width</code> 的 constraint，然后将它的 multiplier 设成 0.2，这样就可实现 Button1 的宽度为父容器宽度的 0.2 倍。操作步骤如下:</p><p><img src="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/widthpercent.gif" alt="View宽度占父视图宽度百分比"></p><h4 id="View-Leading-与-Superview-Leading-间距占-Superview-Width-的百分比"><a href="#View-Leading-与-Superview-Leading-间距占-Superview-Width-的百分比" class="headerlink" title="View.Leading 与 Superview.Leading 间距占 Superview.Width 的百分比"></a>View.Leading 与 Superview.Leading 间距占 Superview.Width 的百分比</h4><p>该功能实现其实是使 View.Leading 相对于 Superview.Trailing 布局，然后再调整 multiplier 参数实现，如下操作步骤实现了将 Button 的左边距离父视图左边界的距离站父视图宽度的0.2倍，如下:</p><p><img src="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/leadingpercent.gif" alt="View.Leading与Superview.Leading间距占Superview.Width的百分比"></p><h4 id="View-Trailing-与-Superview-Trailing-间距占-Superview-Width-的百分比"><a href="#View-Trailing-与-Superview-Trailing-间距占-Superview-Width-的百分比" class="headerlink" title="View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比"></a>View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比</h4><p>该需求实现是使 View.Trailing 相对于 Superview.Trailing 布局，然后再调整 multiplier 参数，需要注意的是使用 <code>Reverse First And Second Item</code> 调整如下表达式中 item1 和 item2 在等式中两边的位置。</p><p><code>item1.attribute1 = multiplier × item2.attribute2 + constant</code> </p><p>以下步骤实现 Button 的 Trailing 距离父视图右边距为父视图宽度的0.2倍，需要注意的是，此时的 multiplier 是 (1-0.2&#x3D;0.8)，在修改 Button 约束值时，可以从顶部导航中看到约束表达式的变化:</p><p><img src="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/trailingpercent.gif" alt="View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比"></p><h4 id="View-Leading-与-Superview-CenterX-间距占父视图-Superview-Width-的百分比"><a href="#View-Leading-与-Superview-CenterX-间距占父视图-Superview-Width-的百分比" class="headerlink" title="View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比"></a>View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比</h4><p>有时间需要将 UI 组件相对于父视图的中线进行布局，比如将 View.Leading 与父视图中线的距离设定为父视图宽度20%, 即相对于父视图 CenterX 的 multiplier 值为 1.4</p><p><img src="http://7jpr4u.com1.z0.glb.clouddn.com/git/autolayout/centerpercent.gif" alt="View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比"> </p><h4 id="限定View的宽高比"><a href="#限定View的宽高比" class="headerlink" title="限定View的宽高比"></a>限定View的宽高比</h4><p>有时候我们需要保持视图的宽高比不变进行缩放，此时可以设定其 Aspect Ratio 保持其在进行缩放时宽高比固定。</p><h4 id="以-Superview-Width-宽度的某一百分比为-View-之间的间隔"><a href="#以-Superview-Width-宽度的某一百分比为-View-之间的间隔" class="headerlink" title="以 Superview.Width 宽度的某一百分比为 View 之间的间隔"></a>以 Superview.Width 宽度的某一百分比为 View 之间的间隔</h4><p>要实现这个需求就没有之前那么简单了，这需要添加一个间距视图，设置每个视图与相邻间距视图的边缘间距约束，然后给所有的间距视图添加相对于其父视图的等宽约束，设置合适的比例即可。这里借用 <a href="http://www.cocoachina.com/ios/20141020/9978.html">为iPhone 6设计自适应布局</a> 文中一图:</p><p><img src="http://cdn.cocimg.com/cms/uploads/allimg/141020/4196_141020155715_1.jpg" alt="以 Superview.Width 宽度的某一百分比为 View 之间的间隔"></p><p>关于文中所涉及到的方法，可在 <a href="https://github.com/carya/AutoLayoutMultiplier">AutoLayoutMultiplier</a> 工程中查看。</p><p>参考: </p><ul><li><a href="http://www.cocoachina.com/ios/20141020/9978.html">为iPhone 6设计自适应布局</a></li><li><a href="http://maogm.com/blog/percentage-width-in-autolayout.html">Autolayout 中的百分比宽度</a></li></ul><hr><p>如果觉得本文对你有帮助，就请用微信打赏我吧^_^</p><div class="figure " style="width:117;"><img class="fig-img" src="http://7jpr4u.com1.z0.glb.clouddn.com/weixinpay/weixin_3_5.png" style="width:117;height:174;"alt=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录如何在 UIStoryboard 或者 xib 中进行百分比布局，包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View.Width 占其 Superview.Width 的百分比&lt;/li&gt;
&lt;li&gt;View.Leading 与 Superview.Leading 间距占 Superview.Width 的百分比&lt;/li&gt;
&lt;li&gt;View.Trailing 与 Superview.Trailing 间距占 Superview.Width 的百分比&lt;/li&gt;
&lt;li&gt;View.Leading 与 Superview.CenterX 间距占父视图 Superview.Width 的百分比&lt;/li&gt;
&lt;li&gt;限定View的宽高比&lt;/li&gt;
&lt;li&gt;以 Superview.Width 宽度的某一百分比为 View 之间的间隔&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="AutoLayout" scheme="http://liumh.com/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>GCD 深入理解：第二部分</title>
    <link href="http://liumh.com/2015/09/07/grand-central-dispatch-in-depth-part-2/"/>
    <id>http://liumh.com/2015/09/07/grand-central-dispatch-in-depth-part-2/</id>
    <published>2015-09-07T02:20:22.000Z</published>
    <updated>2015-09-07T02:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自: <a href="https://github.com/nixzhu/dev-blog">https://github.com/nixzhu/dev-blog</a> </p><hr><p>本文翻译自 <a href="http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2">http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2</a></p><p>原作者：<a href="http://www.raywenderlich.com/u/Lolgrep"><em>Derek Selander</em></a></p><p>译者：<a href="http://weibo.com/riven0951"><em>Riven</em></a>、<a href="https://twitter.com/nixzhu"><em>nixzhu</em></a></p><p>前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX 整理校对并翻译后半部分。</p><span id="more"></span><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>欢迎来到GCD深入理解系列教程的第二部分（也是最后一部分）。</p><p>在本系列的<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">第一部分</a>中，你已经学到超过你想像的关于并发、线程以及GCD 如何工作的知识。通过在初始化时利用 <code>dispatch_once</code>，你创建了一个线程安全的 <code>PhotoManager</code> 单例，而且你通过使用 <code>dispatch_barrier_async</code> 和 <code>dispatch_sync</code> 的组合使得对 <code>Photos</code> 数组的读取和写入都变得线程安全了。</p><p>除了上面这些，你还通过利用 <code>dispatch_after</code> 来延迟显示提示信息，以及利用 <code>dispatch_async</code> 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p><p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip">下载第一部分最终的代码</a>。</p><p>那就让我们来更深入地探索 GCD 吧！</p><h2 id="纠正过早弹出的提示"><a href="#纠正过早弹出的提示" class="headerlink" title="纠正过早弹出的提示"></a>纠正过早弹出的提示</h2><p>你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 <code>UIAlertView</code> 会在图片下载完成之前就弹出，如下如所示：</p><p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM-308x500.png" alt="Premature Completion Block"></p><p>问题的症结在 PhotoManagers 的 <code>downloadPhotoWithCompletionBlock:</code> 里，它目前的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line"> </span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (completionBlock) &#123;</span><br><span class="line">        completionBlock(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法的最后你调用了 <code>completionBlock</code> ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p><p><code>Photo</code> 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 <code>downloadPhotoWithCompletionBlock:</code> 在其末尾调用 <code>completionBlock</code> 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p><p>然而，<code>-[Photo initWithURL:withCompletionBlock:]</code> 是异步执行的，会立即返回——所以这种方式行不通。</p><p>因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，<code>downloadPhotoWithCompletionBlock:</code> 才能调用它自己的 <code>completionBlock</code> 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p><p>或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p><p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。</p><h3 id="Dispatch-Groups（调度组）"><a href="#Dispatch-Groups（调度组）" class="headerlink" title="Dispatch Groups（调度组）"></a>Dispatch Groups（调度组）</h3><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 <code>dispatch_group_t</code> 的实例来记下这些不同的任务。</p><p>当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。</p><p>第一种是 <code>dispatch_group_wait</code> ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p><p>打开 PhotoManager.m，用下列实现替换 <code>downloadPhotosWithCompletionBlock:</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1</span><br><span class="line"> </span><br><span class="line">        __block NSError *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); // 2</span><br><span class="line"> </span><br><span class="line">        for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSURL *url;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            dispatch_group_enter(downloadGroup); // 3</span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                      if (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); // 4</span><br><span class="line">                                  &#125;];</span><br><span class="line"> </span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; // 6</span><br><span class="line">            if (completionBlock) &#123; // 7</span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照注释的顺序，你会看到：</p><ol><li>因为你在使用的是同步的 <code>dispatch_group_wait</code> ，它会阻塞当前线程，所以你要用 <code>dispatch_async</code> 将整个方法放入后台队列以避免阻塞主线程。</li><li>创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。</li><li><code>dispatch_group_enter</code> 手动通知 Dispatch Group 任务已经开始。你必须保证 <code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 成对出现，否则你可能会遇到诡异的崩溃问题。</li><li>手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。</li><li><code>dispatch_group_wait</code> 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 <code>DISPATCH_TIME_FOREVER</code> 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。</li><li>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 <code>completionBlock</code> 回调。这会将工作放到主线程上，并在稍后执行。</li><li>最后，检查 <code>completionBlock</code> 是否为 nil，如果不是，那就运行它。</li></ol><p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。</p><blockquote><p>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。</p></blockquote><p>如果你是在模拟器里运行应用，你可以使用 <a href="http://nshipster.com/network-link-conditioner/">来自 GitHub 的 Network Link Conditioner</a> 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p><p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p><p>在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ：</p><ul><li>自定义串行队列：它很适合当一组任务完成时发出通知。</li><li>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。</li><li>并发队列：它也很适合 Dispatch Group 和完成时通知。</li></ul><h3 id="Dispatch-Group，第二种方式"><a href="#Dispatch-Group，第二种方式" class="headerlink" title="Dispatch Group，第二种方式"></a>Dispatch Group，第二种方式</h3><p>上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……</p><p>在 PhotoManager.m 中找到 <code>downloadPhotosWithCompletionBlock:</code> 方法，用下面的实现替换它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); // 2</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); // 3</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; // 4</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释新的异步方法如何工作：</p><ol><li>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 <code>async</code> 调用中。</li><li>同样的 <code>enter</code> 方法，没做任何修改。</li><li>同样的 <code>leave</code> 方法，也没做任何修改。</li><li><code>dispatch_group_notify</code> 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 <code>completionBlock</code> 便会运行。你还指定了运行 <code>completionBlock</code> 的队列，此处，主队列就是你所需要的。</li></ol><p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p><h2 id="太多并发带来的风险"><a href="#太多并发带来的风险" class="headerlink" title="太多并发带来的风险"></a>太多并发带来的风险</h2><p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？</p><p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Thread_All_The_Code_Meme.jpg" alt="Thread_All_The_Code_Meme"></p><p>看看 PhotoManager 中的 <code>downloadPhotosWithCompletionBlock</code> 方法。你可能已经注意到这里的 <code>for</code> 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 <code>for</code> 循环并发运行，以提高其速度。</p><p><code>dispatch_apply</code> 刚好可用于这个任务。</p><p><code>dispatch_apply</code> 表现得就像一个 <code>for</code> 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 <code>for</code> 循环一样，它只会在所有工作都完成后才会返回。</p><p>当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为<code>跨越式（striding）</code>的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p><blockquote><p>译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！</p></blockquote><p>那何时才适合用 <code>dispatch_apply</code> 呢？</p><ul><li>自定义串行队列：串行队列会完全抵消 <code>dispatch_apply</code> 的功能；你还不如直接使用普通的 <code>for</code> 循环。</li><li>主队列（串行）：与上面一样，在串行队列上不适合使用 <code>dispatch_apply</code> 。还是用普通的 <code>for</code> 循环吧。</li><li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li></ul><p>回到 <code>downloadPhotosWithCompletionBlock:</code> 并用下列实现替换它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line">    dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) &#123;</span><br><span class="line"> </span><br><span class="line">        NSURL *url;</span><br><span class="line">        switch (i) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                url = [NSURL URLWithString:kSuccessKidURLString];</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                url = [NSURL URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</span><br><span class="line">                                  if (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup);</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的循环现在是并行运行的了；在上面的代码中，在调用 <code>dispatch_apply</code> 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。</p><p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p><p>编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？</p><p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p><p>实际上，在这个例子里并不值得。下面是原因：</p><ul><li>你创建并行运行线程而付出的开销，很可能比直接使用  <code>for</code> 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 <code>dispatch_apply</code>。</li><li>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">如何在 Xcode 中使用 Instruments</a> 可以学到更多相关知识。</li><li>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</li></ul><p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p><h2 id="GCD-的其他趣味"><a href="#GCD-的其他趣味" class="headerlink" title="GCD 的其他趣味"></a>GCD 的其他趣味</h2><p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p><h3 id="阻塞——正确的方式"><a href="#阻塞——正确的方式" class="headerlink" title="阻塞——正确的方式"></a>阻塞——正确的方式</h3><p>这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p><p>Xcode 里的测试在 <code>XCTestCase</code> 的子类上执行，并运行任何方法签名以 <code>test</code> 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p><p>当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p><p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p><blockquote><p>注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p></blockquote><p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Gandalf_Semaphore.png" alt="Gandalf_Semaphore"></p><p>导航到 GooglyPuffTests.m 并查看 <code>downloadImageURLWithString:</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __block BOOL isFinishedDownloading = NO;</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 isFinishedDownloading = YES;</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    while (!isFinishedDownloading) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 <code>isFinishedDownloading</code> 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。</p><p>通过在 Xcode 中点击  Product &#x2F; Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ⌘+U 来运行你的测试。</p><p>在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 <a href="http://en.wikipedia.org/wiki/Spinlock">自旋锁</a> 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。</p><blockquote><p>译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p></blockquote><p>你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p><blockquote><p>译者注：作者反复提到网速太快，而我们还需要对付 GFW，简直泪流满面！</p></blockquote><p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p><p>如果你想学到更多关于信号量的知识，看看这个链接<a href="http://greenteapress.com/semaphores/">它更细致地讨论了信号量理论</a>。如果你是学术型，那可以看一个软件开发中经典的<a href="http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家进餐问题</a>，它需要使用信号量来解决。</p><p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。</p><p>让我们来使用信号量吧！</p><p>打开 GooglyPuffTests.m 并用下列实现替换 <code>downloadImageURLWithString:</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadImageURLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    // 1</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"> </span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(UIImage *image, NSError *error) &#123;</span><br><span class="line">                                 if (error) &#123;</span><br><span class="line">                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"> </span><br><span class="line">                                 // 2</span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    if (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        XCTFail(@&quot;%@ timed out&quot;, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来说明你代码中的信号量是如何工作的：</p><ol><li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li><li>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li><li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</li></ol><p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。</p><p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！</p><p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p><h3 id="使用-Dispatch-Source"><a href="#使用-Dispatch-Source" class="headerlink" title="使用 Dispatch Source"></a>使用 Dispatch Source</h3><p>GCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p><p>第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 <code>dispatch_source_create</code> 如何工作。下面是创建一个源的函数原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t dispatch_source_create(</span><br><span class="line">   dispatch_source_type_t type,</span><br><span class="line">   uintptr_t handle,</span><br><span class="line">   unsigned long mask,</span><br><span class="line">   dispatch_queue_t queue);</span><br></pre></td></tr></table></figure><p>第一个参数是 <code>dispatch_source_type_t</code> 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 <a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants">Xcode 文档</a> 得到哪些选项可用于每个 <code>dispatch_source_type_t</code> 参数。</p><p>下面你将监控 <code>DISPATCH_SOURCE_TYPE_SIGNAL</code> 。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL%22">文档所显示的</a>：</p><p>一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。</p><p>这些 Unix 信号组成的列表可在头文件  <a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h">signal.h</a> 中找到。在其顶部有一堆 <code>#define</code> 语句。你将监控此信号列表中的 <code>SIGSTOP</code> 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。</p><p>去往 PhotoCollectionViewController.m 并添加如下代码到 <code>viewDidLoad</code> 的顶部，就在 <code>[super viewDidLoad]</code> 下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line"> </span><br><span class="line">  // 1</span><br><span class="line">  #if DEBUG</span><br><span class="line">      // 2</span><br><span class="line">      dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">      // 3</span><br><span class="line">      static dispatch_source_t source = nil;</span><br><span class="line"> </span><br><span class="line">      // 4</span><br><span class="line">      __typeof(self) __weak weakSelf = self;</span><br><span class="line"> </span><br><span class="line">      // 5</span><br><span class="line">      static dispatch_once_t onceToken;</span><br><span class="line">      dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">          // 6</span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue);</span><br><span class="line"> </span><br><span class="line">          // 7</span><br><span class="line">          if (source)</span><br><span class="line">          &#123;</span><br><span class="line">              // 8</span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  // 9</span><br><span class="line">                  NSLog(@&quot;Hi, I am: %@&quot;, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); // 10</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  #endif</span><br><span class="line"> </span><br><span class="line">  // The other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：</p><ol><li>最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。 :] </li><li>Just to mix things up，你创建了一个 <code>dispatch_queue_t</code> 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。</li><li>你需要 <code>source</code> 在方法范围之外也可被访问，所以你使用了一个 static 变量。</li><li>使用 <code>weakSelf</code> 以确保不会出现保留环（Retain Cycle）。这对 <code>PhotoCollectionViewController</code> 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。</li><li>使用 <code>dispatch_once</code> 确保只会执行一次 Dispatch Source 的设置。</li><li>初始化 <code>source</code> 变量。你指明了你对信号监控感兴趣并提供了 <code>SIGSTOP</code> 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。</li><li>如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。</li><li>当你收到你所监控的信号时，<code>dispatch_source_set_event_handler</code> 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。</li><li>一个基本的 <code>NSLog</code> 语句，它将对象打印到控制台。</li><li>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</li></ol><p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am:</span><br></pre></td></tr></table></figure><p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p><p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p><blockquote><p>译者注：好像挺有用！</p></blockquote><p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。</p><p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/What_Meme.jpg" alt="What_Meme"></p><p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！</p><p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/I_See_What_You_Did_Meme.png" alt="I_See_What_You_Did_Meme"></p><p>将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 <code>NSLog</code> 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！</p><blockquote><p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p></blockquote><p>在调试器里，键入命令：<code>po [[weakSelf navigationItem] setPrompt:@&quot;WOOT!&quot;]</code></p><p>然后恢复应用的执行。你会看到如下内容：</p><p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console-650x500.png" alt="Dispatch_Sources_Xcode_Breakpoint_Console"></p><p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI-308x500.png" alt="Dispatch_Sources_Debugger_Updating_UI"></p><p>使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p><blockquote><p>译者注：发挥这一点，是可以做出一些调试库的吧？</p></blockquote><h2 id="之后又该往何处去？"><a href="#之后又该往何处去？" class="headerlink" title="之后又该往何处去？"></a>之后又该往何处去？</h2><p>你可以<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff-Final.zip">在此下载最终的项目</a>。</p><p>我讨厌再次提及此主题，但你真的要看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">如何使用 Instruments</a> 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。</p><p>同样请看看 <a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues">如何使用 NSOperations 和 NSOperationQueues</a> 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p><p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。</p><p>祝你好运，玩得开心！有任何问题或反馈请在下方的讨论区贴出！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载自: &lt;a href=&quot;https://github.com/nixzhu/dev-blog&quot;&gt;https://github.com/nixzhu/dev-blog&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&quot;&gt;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者：&lt;a href=&quot;http://www.raywenderlich.com/u/Lolgrep&quot;&gt;&lt;em&gt;Derek Selander&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;http://weibo.com/riven0951&quot;&gt;&lt;em&gt;Riven&lt;/em&gt;&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/nixzhu&quot;&gt;&lt;em&gt;nixzhu&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX 整理校对并翻译后半部分。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://liumh.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="iOS" scheme="http://liumh.com/tags/iOS/"/>
    
    <category term="GCD" scheme="http://liumh.com/tags/GCD/"/>
    
  </entry>
  
</feed>
