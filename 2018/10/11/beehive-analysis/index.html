
<!DOCTYPE html>
<html lang="en,zh-CN,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CaryaLiu&#39;s blog">
    <title>阿里组件化框架BeeHive解析 - CaryaLiu&#39;s blog</title>
    <meta name="author" content="CaryaLiu">
    
        <meta name="keywords" content="设计模式,组件化">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CaryaLiu","sameAs":[],"image":"header.png"},"articleBody":"本文是基于BeeHive版本1.6.0进行分析。\r\nBeeHive核心思想涉及两个部分：\r\n\r\n各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。\r\nApp生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。\r\n\r\nCore+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。\r\n\r\n本文会按照以下顺序进行介绍：\r\n\r\nBeeHive概览\r\nBeeHive模块生命周期事件\r\n\r\n系统事件\r\n通用事件\r\n业务自定义事件\r\n\r\nBeeHive模块注册\r\n\r\nAnnotation方式注册\r\n读取本地Plist方式注册\r\nLoad方法注册\r\n\r\nBeeHive模块间调用\r\n\r\nAnnotation方式注册\r\n读取本地Plist方式注册\r\nAPI注册\r\n\r\n上下文环境Context\r\n\r\nBeeHive概览\r\nBeeHive的架构图如下所示：\r\n\r\nBeeHive架构图\r\n图中的BHContext，包含BeeHive的配置文件，提供全局统一上下文信息。\r\n图中的BHCore包含：\r\n\r\nBeeHive，提供组件库对外接口\r\nBHModuleManager和BHModuleProtocol，注册和创建Module逻辑\r\nBHServiceManager和BHServiceProtocol，注册和创建Service逻辑\r\nBHRouter\r\n\r\nModule、Service注册和调用逻辑只和核心模块相关，Module之间没有直接的关联关系。\r\n对于Module和Service的注册，BeeHive提供了三种不同的形式：静态plist，动态注册，annotation。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。\r\n\r\nModule注册\r\n图中包含了主要的BeeHive启动过程以及Module注册的时序逻辑。Module的事件分发源于BHAppDelegate中的triggerEvent。\r\n加载Module：\r\n\r\nBeeHive.plist中配置的module和service是在 AppDelegate中调用\r\n[[BeeHive shareInstance] setContext:[BHContext shareInstance]];\r\n时加载。\r\nModule的实现中 +load内部调用\r\n[BeeHive registerDynamicModule:[self class]];\r\n动态加载。\r\nModule的实现中使用注解： @BeeHiveMod(XXModule)\r\n\r\nBHAppDelegate中除了回调系统的事件，还将App生命周期进行扩展，增加ModuleSetup，ModuleInit，ModuleSplash，此外开发人员还可以自行扩展。\r\n\r\nBeeHive事件扩展\r\n扩展周期过程中，同时加入Module分析量化功能，每个模块Init的耗时均可计算出来，为性能优化做到数据上的支持。一个App的业务增多过程中，通过分析定位Module的Init耗时可以确定需要优化的Module。\r\nModule遵循BHModuleProtocol后，能够捕获App状态的回调，并拥有App生命周期内的全局上下文，通过context可获取配置参数，模块资源以及服务资源。\r\n以BeeHive作为底层框架的App，除了解耦带来的便利，开发人员在开发新App过程中涉及相同功能的Module，无需重复造轮子，直接移植Module，开发一个App如同拼装积木，能组合需要的功能业务。\r\n12345678910111213141516BHModuleManager.m://BHModuleInfos: [&#123;moduleClass:String, ModuleLevel:NSNumber, modulePriority:String&#125;]//BHModules: [id&lt;BHModuleProtocol&gt;]@interface BHModuleManager()@property(nonatomic, strong) NSMutableArray *BHModuleDynamicClasses;@property(nonatomic, strong) NSMutableArray&lt;NSDictionary *&gt; *BHModuleInfos;@property(nonatomic, strong) NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *BHModules;@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *&gt; *BHModulesByEvent;@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSString *&gt; *BHSelectorByEvent;@end\r\nBHModuleInfos和BHModulesByEvent中id&lt;BHModuleProtocol&gt;均按照moduleInstances的moduleLevel和modulePriority进行了排序。\r\n\r\n注册静态plist service\r\n上图中包含注册静态plist中service的相关逻辑，App启动时通过BeeHive的setContext:来触发plist中service的注册。service的注册并没有创建对应的service实例，只是在BHServiceManager中建立Service协议和实现该协议的类之间的映射关系。\r\n\r\n动态注册service\r\n上图中是动态注册service的逻辑，这是在App启动事件分发时触发。Module根据需求动态注册某个服务，通常，注册service的代码在module的modInit:或者modSetup:中。\r\n\r\n创建service实例\r\n业务组件可以通过createService:直接调用服务。Service的调用和实现，核心是BHServiceManager。可以单独创建Services\r\nInterface\r\nPod，统一放置要用的Services，这样的业务依赖就从网状式变成中心式，业务方只需依赖Services一个。\r\nService可以按需加载，BeeHive逻辑是将基础服务注册在plist中，业务型服务允许Service不先注册，直到业务需要时才被动态注册。\r\nService支持两种不同模式：\r\n\r\n单例：\r\n对于全局统一且无状态服务，建议使用这种创建形式，这样有利于Service的统一管理以及减少不必要内存消耗。\r\n多实例：\r\n每次调用服务都重新创建新的服务，对于涉及状态以及状态变化的服务最适合使用多实例方式。\r\n\r\n在多线程环境下遇到了Service读写问题，已通过Lock来已避免Array\r\ncrash问题。 不过Service还存在如下问题：\r\n\r\nService依赖关系,导致底层依赖的Service没有被创建时就被调用。\r\n规划Service、Module创建顺序，使得App达到秒开，优化性能体验。\r\n\r\n前者依赖问题计划通过调度机制来解决，后者还需要将AppDelegate更多业务剥离以及实践才可。\r\nBeeHive使用createService:和createService:withServiceName:来创建实现了协议的对象，并且缓存该对象。\r\nBeeHive模块生命周期事件\r\nBeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。\r\n事件分为三种类型：\r\n\r\n系统事件\r\n通用事件\r\n业务自定义事件\r\n\r\n在BHModuleManager的头文件中，Event的类型定义如下：\r\n1234567891011121314151617181920212223242526272829typedef NS_ENUM(NSInteger, BHModuleEventType)&#123;    BHMSetupEvent = 0,    BHMInitEvent,    BHMTearDownEvent,    BHMSplashEvent,    BHMQuickActionEvent,    BHMWillResignActiveEvent,    BHMDidEnterBackgroundEvent,    BHMWillEnterForegroundEvent,    BHMDidBecomeActiveEvent,    BHMWillTerminateEvent,    BHMUnmountEvent,    BHMOpenURLEvent,    BHMDidReceiveMemoryWarningEvent,    BHMDidFailToRegisterForRemoteNotificationsEvent,    BHMDidRegisterForRemoteNotificationsEvent,    BHMDidReceiveRemoteNotificationEvent,    BHMDidReceiveLocalNotificationEvent,    BHMWillPresentNotificationEvent,    BHMDidReceiveNotificationResponseEvent,    BHMWillContinueUserActivityEvent,    BHMContinueUserActivityEvent,    BHMDidFailToContinueUserActivityEvent,    BHMDidUpdateUserActivityEvent,    BHMHandleWatchKitExtensionRequestEvent,    BHMDidCustomEvent = 1000    &#125;;\r\n系统事件\r\n\r\nBeeHive系统事件\r\n系统事件通常是Application生命周期事件，例如WillResignActiveEvent,\r\nDidEnterBackgroundEvent, WillEnterForegroundEvent,\r\nDidBecomeActiveEvent, WillTerminateEvent。\r\n一般做法是使用BHAppDelegate来接管系统事件，如下所示：\r\n1234567891011121314151617181920212223//TestAppDelegate.h#import &quot;BeeHive.h&quot;@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;//TestAppDelegate.m- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;        [BHContext shareInstance].application = application;    [BHContext shareInstance].launchOptions = launchOptions;    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;        [BeeHive shareInstance].enableException = YES;    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];        [super application:application didFinishLaunchingWithOptions:launchOptions];    ...    return YES;&#125;\r\n在BHAppDelegate的实现文件中，实现了一系列的系统调用事件。如下所示：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMSetupEvent];    [[BHModuleManager sharedManager] triggerEvent:BHMInitEvent];        dispatch_async(dispatch_get_main_queue(), ^&#123;        [[BHModuleManager sharedManager] triggerEvent:BHMSplashEvent];    &#125;);#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000    if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 10.0f) &#123;        [UNUserNotificationCenter currentNotificationCenter].delegate = self;    &#125;#endif    #ifdef DEBUG    [[BHTimeProfiler sharedTimeProfiler] saveTimeProfileDataIntoFile:@&quot;BeeHiveTimeProfiler&quot;];#endif        return YES;&#125;#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400 -(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler&#123;    [[BeeHive shareInstance].context.touchShortcutItem setShortcutItem: shortcutItem];    [[BeeHive shareInstance].context.touchShortcutItem setScompletionHandler: completionHandler];    [[BHModuleManager sharedManager] triggerEvent:BHMQuickActionEvent];&#125;#endif- (void)applicationWillResignActive:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMWillResignActiveEvent];&#125;- (void)applicationDidEnterBackground:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMDidEnterBackgroundEvent];&#125;- (void)applicationWillEnterForeground:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMWillEnterForegroundEvent];&#125;- (void)applicationDidBecomeActive:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMDidBecomeActiveEvent];&#125;- (void)applicationWillTerminate:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMWillTerminateEvent];&#125;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;    [[BeeHive shareInstance].context.openURLItem setOpenURL:url];    [[BeeHive shareInstance].context.openURLItem setSourceApplication:sourceApplication];    [[BeeHive shareInstance].context.openURLItem setAnnotation:annotation];    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];    return YES;&#125;#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123;      [[BeeHive shareInstance].context.openURLItem setOpenURL:url];    [[BeeHive shareInstance].context.openURLItem setOptions:options];    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];    return YES;&#125;#endif- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application&#123;    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveMemoryWarningEvent];&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error&#123;    [[BeeHive shareInstance].context.notificationsItem setNotificationsError:error];    [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToRegisterForRemoteNotificationsEvent];&#125;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;    [[BeeHive shareInstance].context.notificationsItem setDeviceToken: deviceToken];    [[BHModuleManager sharedManager] triggerEvent:BHMDidRegisterForRemoteNotificationsEvent];&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123;    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123;    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];    [[BeeHive shareInstance].context.notificationsItem setNotificationResultHander: completionHandler];    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];&#125;- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#123;    [[BeeHive shareInstance].context.notificationsItem setLocalNotification: notification];    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveLocalNotificationEvent];&#125;#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80000- (void)application:(UIApplication *)application didUpdateUserActivity:(NSUserActivity *)userActivity&#123;    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];        [[BHModuleManager sharedManager] triggerEvent:BHMDidUpdateUserActivityEvent];    &#125;&#125;- (void)application:(UIApplication *)application didFailToContinueUserActivityWithType:(NSString *)userActivityType error:(NSError *)error&#123;    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];        [[BeeHive shareInstance].context.userActivityItem setUserActivityError: error];        [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToContinueUserActivityEvent];    &#125;&#125;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];        [[BeeHive shareInstance].context.userActivityItem setRestorationHandler: restorationHandler];        [[BHModuleManager sharedManager] triggerEvent:BHMContinueUserActivityEvent];    &#125;    return YES;&#125;- (BOOL)application:(UIApplication *)application willContinueUserActivityWithType:(NSString *)userActivityType&#123;    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];        [[BHModuleManager sharedManager] triggerEvent:BHMWillContinueUserActivityEvent];    &#125;    return YES;&#125;- (void)application:(UIApplication *)application handleWatchKitExtensionRequest:(nullable NSDictionary *)userInfo reply:(void(^)(NSDictionary * __nullable replyInfo))reply &#123;    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;        [BeeHive shareInstance].context.watchItem.userInfo = userInfo;        [BeeHive shareInstance].context.watchItem.replyHandler = reply;        [[BHModuleManager sharedManager] triggerEvent:BHMHandleWatchKitExtensionRequestEvent];    &#125;&#125;#endif#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler &#123;    [[BeeHive shareInstance].context.notificationsItem setNotification: notification];    [[BeeHive shareInstance].context.notificationsItem setNotificationPresentationOptionsHandler: completionHandler];    [[BeeHive shareInstance].context.notificationsItem setCenter:center];    [[BHModuleManager sharedManager] triggerEvent:BHMWillPresentNotificationEvent];&#125;;- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler &#123;    [[BeeHive shareInstance].context.notificationsItem setNotificationResponse: response];    [[BeeHive shareInstance].context.notificationsItem setNotificationCompletionHandler:completionHandler];    [[BeeHive shareInstance].context.notificationsItem setCenter:center];    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveNotificationResponseEvent];&#125;;#endif@end\r\n这样所有的系统事件都可以通过BHModuleManager的triggerEvent:来处理。\r\n在上述事件中，BHMInitEvent和BHMTearDownEvent事件需要做特殊处理。\r\n先看看BHMInitEvent的处理。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)handleModulesInitEventForTarget:(id&lt;BHModuleProtocol&gt;)target                        withCustomParam:(NSDictionary *)customParam&#123;    BHContext *context = [BHContext shareInstance].copy;    context.customParam = customParam;    context.customEvent = BHMInitEvent;        NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;    if (target) &#123;        moduleInstances = @[target];    &#125; else &#123;        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMInitEvent)];    &#125;        [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;        __weak typeof(&amp;*self) wself = self;        void ( ^ bk )(void);        bk = ^()&#123;            __strong typeof(&amp;*self) sself = wself;            if (sself) &#123;                if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123;                    [moduleInstance modInit:context];                &#125;            &#125;        &#125;;        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- modInit:&quot;, [moduleInstance class]]];                if ([moduleInstance respondsToSelector:@selector(async)]) &#123;            BOOL async = [moduleInstance async];                        if (async) &#123;                dispatch_async(dispatch_get_main_queue(), ^&#123;                    bk();                &#125;);                            &#125; else &#123;                bk();            &#125;        &#125; else &#123;            bk();        &#125;    &#125;];&#125;\r\nBHMInitEvent事件是触发各个module启动时的初始化逻辑。这里从self.BHModulesByEvent中取出BHMInitEvent事件对应的module数组，遍历其中的每个module实例，向其发送modInit:消息。这里会考虑是否异步执行module的初始化。如果moduleInstance重写了async方法，那么就会根据该方法的返回值来决定是否异步执行module的初始化。\r\nmodInit:方法由各个module实例各自实现，可以在其中注册一个外部模块可以访问的Service接口。\r\n12345-(void)modInit:(BHContext *)context&#123;    //注册模块的接口服务    [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];&#125;\r\n再看看BHMTearDownEvent事件。这个事件中可以处理module的清理工作。\r\n12345678910111213141516171819202122- (void)handleModulesTearDownEventForTarget:(id&lt;BHModuleProtocol&gt;)target                            withCustomParam:(NSDictionary *)customParam&#123;    BHContext *context = [BHContext shareInstance].copy;    context.customParam = customParam;    context.customEvent = BHMTearDownEvent;        NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;    if (target) &#123;        moduleInstances = @[target];    &#125; else &#123;        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMTearDownEvent)];    &#125;    //Reverse Order to unload    for (int i = (int)moduleInstances.count - 1; i &gt;= 0; i--) &#123;        id&lt;BHModuleProtocol&gt; moduleInstance = [moduleInstances objectAtIndex:i];        if (moduleInstance &amp;&amp; [moduleInstance respondsToSelector:@selector(modTearDown:)]) &#123;            [moduleInstance modTearDown:context];        &#125;    &#125;&#125;\r\n由于module具有优先级，且self.BHModulesByEvent结构中，每种事件类型对应的modules数组中的module元素都已经按照优先级从高到低排列，因此逆序对modules数组中的module元素调用modTearDown:方法。\r\n通用事件\r\n在系统事件的基础之上，扩展了应用的通用事件，例如modSetup、modInit等，可以用于编码实现各插件模块的设置与初始化。\r\n扩展的通用事件如下：\r\n\r\nBeeHive通用事件\r\n所有的事件都可以通过调用BHModuleManager的triggerEvent:来处理。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566- (void)triggerEvent:(NSInteger)eventType&#123;    [self triggerEvent:eventType withCustomParam:nil];    &#125;- (void)triggerEvent:(NSInteger)eventType     withCustomParam:(NSDictionary *)customParam &#123;    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];&#125;- (void)handleModuleEvent:(NSInteger)eventType                forTarget:(id&lt;BHModuleProtocol&gt;)target          withCustomParam:(NSDictionary *)customParam&#123;    switch (eventType) &#123;        case BHMInitEvent:            //special            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];            break;        case BHMTearDownEvent:            //special            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];            break;        default: &#123;            NSString *selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];        &#125;            break;    &#125;&#125;- (void)handleModuleEvent:(NSInteger)eventType                forTarget:(id&lt;BHModuleProtocol&gt;)target           withSeletorStr:(NSString *)selectorStr           andCustomParam:(NSDictionary *)customParam&#123;    BHContext *context = [BHContext shareInstance].copy;    context.customParam = customParam;    context.customEvent = eventType;    if (!selectorStr.length) &#123;        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];    &#125;    SEL seletor = NSSelectorFromString(selectorStr);    if (!seletor) &#123;        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];        seletor = NSSelectorFromString(selectorStr);    &#125;    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;    if (target) &#123;        moduleInstances = @[target];    &#125; else &#123;        moduleInstances = [self.BHModulesByEvent objectForKey:@(eventType)];    &#125;    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;        if ([moduleInstance respondsToSelector:seletor]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;            [moduleInstance performSelector:seletor withObject:context];#pragma clang diagnostic pop                        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];                    &#125;    &#125;];&#125;\r\n从上面的代码可以看出，事件类型分发是在方法handleModuleEvent:forTarget:withCustomParam:中进行。如之前所述，需要对BHMInitEvent和BHMTearDownEvent做特殊处理。同时，触发各个module(从self.BHModulesByEvent中获取)中的响应事件方法通过performSelector:withObject:来调用。\r\n注意这里的module都是遵循BHModuleProtocol协议的。\r\n通用事件中，可以在modSetup中设置环境变量,通过context.env可以判断我们的应用环境状态来决定我们如何配置我们的应用。如下所示：\r\n123456789101112-(void)modSetup:(BHContext *)context&#123;    switch (context.env) &#123;        case BHEnvironmentDev:        //....初始化开发环境        break;        case BHEnvironmentProd:        //....初始化生产环境        default:        break;    &#125;&#125;\r\n业务自定义事件\r\n如果觉得系统事件、通用事件不足以满足需要，我们还将事件封装简化成BHAppdelgate，你可以通过继承\r\nBHAppdelegate来扩展自己的事件。通过以下方式来注册自定义事件：\r\n12345678- (void)registerCustomEvent:(NSInteger)eventType   withModuleInstance:(id)moduleInstance       andSelectorStr:(NSString *)selectorStr &#123;    if (eventType &lt; 1000) &#123;        return;    &#125;    [self registerEvent:eventType withModuleInstance:moduleInstance andSelectorStr:selectorStr];&#125;\r\n触发带参数的事件响应：\r\n1234- (void)triggerEvent:(NSInteger)eventType     withCustomParam:(NSDictionary *)customParam &#123;    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];&#125;\r\nBeeHive模块注册\r\n使用注解的方式注册Module和Service时，Module和Service的注册发生在加载镜像文件时期。\r\nplist方式注册Module和Service，是在AppDelegate中设置BeeHive的Context时加载注册。\r\nModule动态注册是在+load方法中，也是在加载镜像时注册。Service的动态注册可以Module的modInit:或者modSetup:中，或者使用时注册。\r\n模块注册有三种方式：Annotation方式注册、读取本地plist方式注册、Load方法注册。所谓注册，就是将Module类告知BHModuleManager来管理。由此可见，在BeeHive中是通过BHModuleManager来管理各个模块的，BHModuleManager中只会管理已经被注册过的模块。\r\nAnnotation方式注册\r\n通过BeeHiveMod宏进行Annotation标记。\r\n1@BeeHiveMod(ShopModule)\r\nBeeHiveMod宏定义如下：\r\n12#define BeeHiveMod(name) \\class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = &quot;&quot;#name&quot;&quot;;\r\nBeeHiveDATA也是一个宏：\r\n1#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))\r\n在预编译结束后，BeeHiveMode宏最终会完全展开成下面的样子：\r\n1@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;\r\n这里需要注意双引号的总对数。\r\n关于__attribute的用法，可参考我的另一篇attribute\r\n__attribute第一个参数used,它的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。\r\n有时候我们需要指定一个特殊的段，来存放我们想要的数据。这里我们就把数据存在__DATA数据段里面的\"BeehiveMods\"section中。\r\nAttributes的修饰关键字section (\"section-name”)可以达到此要求。\r\n上述代码中:\r\n1@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;\r\n去掉__attribute的属性，相当于：\r\n1@class BeeHive; char * kShopModule_mod = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;\r\n只不过是将kShopModule_mod变量存储在了__DATA段的BeehiveMods\r\nsection中。\r\n这样，所有的Module类名的字符串都会放置在__DATA段BeehiveMods\r\nsection中，那么如何取出这些字符串呢？\r\n这里先介绍一下__attribute__((constructor))：\r\nconstructor：顾名思义，构造器加上这个属性的函数会在可执行文件（或\r\nshared library）load时被调用，可以理解为在 main() 函数调用前执行：\r\n123456789101112131415__attribute__((constructor))static void beforeMain(void) &#123;    NSLog(@&quot;beforeMain&quot;);&#125;__attribute__((destructor))static void afterMain(void) &#123;    NSLog(@&quot;afterMain&quot;);&#125;int main(int argc, const char * argv[]) &#123;    NSLog(@&quot;main&quot;);    return 0;&#125;// Console:// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;\r\n_dyld_register_func_for_add_image:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:\r\n12345678910/* * The following functions allow you to install callbacks which will be called    * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image() * the callback func is called for every existing image.  Later, it is called as each new image * is loaded and bound (but initializers not yet run).  The callback registered with * _dyld_register_func_for_remove_image() is called after any terminators in an image are run * and before the image is un-memory-mapped. */extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))\r\n对于每一个已经存在的镜像，当它被动态链接时，都会执行回调void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)，传入文件的mach_header以及一个虚拟内存地址\r\nintptr_t。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344__attribute__((constructor))void initProphet() &#123;    _dyld_register_func_for_add_image(dyld_callback);&#125;static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)&#123;    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);    for (NSString *modName in mods) &#123;        Class cls;        if (modName) &#123;            cls = NSClassFromString(modName);                        if (cls) &#123;                [[BHModuleManager sharedManager] registerDynamicModule:cls];            &#125;        &#125;    &#125;&#125;NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)&#123;    NSMutableArray *configs = [NSMutableArray array];    unsigned long size = 0;#ifndef __LP64__    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);#else    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);#endif        unsigned long counter = size/sizeof(void*);    for(int idx = 0; idx &lt; counter; ++idx)&#123;        char *string = (char*)memory[idx];        NSString *str = [NSString stringWithUTF8String:string];        if(!str)continue;                BHLog(@&quot;config = %@&quot;, str);        if(str) [configs addObject:str];    &#125;        return configs;&#125;\r\nmach_header是定义在usr/include/mach-o/loader.h中的数据结构：\r\n1234567891011121314/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123;     uint32_t    magic;        /* mach magic number identifier */     cpu_type_t    cputype;    /* cpu specifier */     cpu_subtype_t    cpusubtype;    /* machine specifier */     uint32_t    filetype;    /* type of file */     uint32_t    ncmds;        /* number of load commands */     uint32_t    sizeofcmds;    /* the size of all the load commands */     uint32_t    flags;        /* flags */     uint32_t    reserved;    /* reserved */&#125;;\r\n通过调用BHReadConfiguration函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。\r\n然后将Module交由到BHModuleManager管理：\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495- (void)registerDynamicModule:(Class)moduleClass&#123;    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];&#125;- (void)registerDynamicModule:(Class)moduleClass       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent&#123;    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];&#125;- (void)addModuleFromObject:(id)object     shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent&#123;    Class class;    NSString *moduleName = nil;        if (object) &#123;        class = object;        moduleName = NSStringFromClass(class);    &#125; else &#123;        return ;    &#125;        /** 检测是否已存在Module类 */    __block BOOL flag = YES;    [self.BHModules enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;        if ([obj isKindOfClass:class]) &#123;            flag = NO;            *stop = YES;        &#125;    &#125;];    if (!flag) &#123;  /**&lt; 如果已存在，则返回，不做处理 */        return;    &#125;        if ([class conformsToProtocol:@protocol(BHModuleProtocol)]) &#123;        NSMutableDictionary *moduleInfo = [NSMutableDictionary dictionary];                /** basicModuleLevel 这个方法如果不实现，Level是Normal: 1 */        BOOL responseBasicLevel = [class instancesRespondToSelector:@selector(basicModuleLevel)];        int levelInt = 1;                if (responseBasicLevel) &#123;            /** basicModuleLevel 这个方法如果实现，Level是Basic: 0 */            levelInt = 0;        &#125;                [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey];        if (moduleName) &#123;            [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey];        &#125;        [self.BHModuleInfos addObject:moduleInfo];                /** 初始化module实例 */        id&lt;BHModuleProtocol&gt; moduleInstance = [[class alloc] init];        [self.BHModules addObject:moduleInstance];        [moduleInfo setObject:@(YES) forKey:kModuleInfoHasInstantiatedKey];        /** 将module按照优先级排序 */        [self.BHModules sortUsingComparator:^NSComparisonResult(id&lt;BHModuleProtocol&gt; moduleInstance1, id&lt;BHModuleProtocol&gt; moduleInstance2) &#123;            NSNumber *module1Level = @(BHModuleNormal);            NSNumber *module2Level = @(BHModuleNormal);            if ([moduleInstance1 respondsToSelector:@selector(basicModuleLevel)]) &#123;                module1Level = @(BHModuleBasic);            &#125;            if ([moduleInstance2 respondsToSelector:@selector(basicModuleLevel)]) &#123;                module2Level = @(BHModuleBasic);            &#125;            if (module1Level.integerValue != module2Level.integerValue) &#123;                return module1Level.integerValue &gt; module2Level.integerValue;            &#125; else &#123;                NSInteger module1Priority = 0;                NSInteger module2Priority = 0;                if ([moduleInstance1 respondsToSelector:@selector(modulePriority)]) &#123;                    module1Priority = [moduleInstance1 modulePriority];                &#125;                if ([moduleInstance2 respondsToSelector:@selector(modulePriority)]) &#123;                    module2Priority = [moduleInstance2 modulePriority];                &#125;                return module1Priority &lt; module2Priority;            &#125;        &#125;];        /** 给module注册事件 */        [self registerEventsByModuleInstance:moduleInstance];                if (shouldTriggerInitEvent) &#123;            [self handleModuleEvent:BHMSetupEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];            [self handleModulesInitEventForTarget:moduleInstance withCustomParam:nil];            dispatch_async(dispatch_get_main_queue(), ^&#123;                [self handleModuleEvent:BHMSplashEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];            &#125;);        &#125;    &#125;&#125;\r\n所有需要注册的Module必须遵循BHModuleProtocol协议，否则不会被存储。\r\n读取本地Plist方式注册\r\n首先需要设置本地Plist文件的读取路径：\r\n1[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist\r\nBeeHive的所有配置都可以通过BHContext进行传递。\r\nPlist文件的字段如下：\r\n123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;     &lt;key&gt;URLGlobalScheme&lt;/key&gt;     &lt;string&gt;com.alibaba.beehive&lt;/string&gt;     &lt;key&gt;moduleClasses&lt;/key&gt;     &lt;array&gt;         &lt;dict&gt;             &lt;key&gt;moduleClass&lt;/key&gt;             &lt;string&gt;HomeModule&lt;/string&gt;             &lt;key&gt;moduleLevel&lt;/key&gt;             &lt;integer&gt;1&lt;/integer&gt;             &lt;key&gt;modulePriority&lt;/key&gt;             &lt;string&gt;600&lt;/string&gt;         &lt;/dict&gt;         &lt;dict&gt;             &lt;key&gt;moduleClass&lt;/key&gt;             &lt;string&gt;TMTradeAdapter&lt;/string&gt;             &lt;key&gt;moduleLevel&lt;/key&gt;             &lt;integer&gt;1&lt;/integer&gt;             &lt;key&gt;modulePriority&lt;/key&gt;             &lt;string&gt;599&lt;/string&gt;         &lt;/dict&gt;     &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;\r\n在AppDelegate中\r\n[[BeeHive shareInstance] setContext:[BHContext shareInstance]];\r\n设置BHContext时就会注册plist中的module。\r\n123456789101112131415161718192021- (void)loadLocalModules&#123;        NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;        return;    &#125;        NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath];        NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey];    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy;    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];    &#125;];    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;            [self.BHModuleInfos addObject:obj];        &#125;    &#125;];&#125;\r\n将Plist中的module加入到BHModuleInfos中。\r\nLoad方法注册\r\n12345678910111213141516// BeeHive+ (void)load&#123;    [BeeHive registerDynamicModule:[self class]];&#125;+ (void)registerDynamicModule:(Class)moduleClass&#123;    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];&#125;// BHModuleManager- (void)registerDynamicModule:(Class)moduleClass&#123;    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];&#125;\r\nLoad方法最终是调用BHModuleManager中的registerDynamicModule:方法来处理，该方法已在上一节中说明。\r\n+load的方式可以使用BH_EXPORT_MODULE宏来替代完成。\r\n123#define BH_EXPORT_MODULE(isAsync) \\+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \\-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;\r\n在BH_EXPORT_MODULE宏中传入了参数isAsync，代表是否异步加载Module模块。如果是YES，则表示需要异步加载，NO则表示同步加载。\r\n回过头来看看AppDelegate中setContext方法中的操作：\r\n123456789101112131415161718// AppDelegate[[BeeHive shareInstance] setContext:[BHContext shareInstance]];// BeeHive-(void)setContext:(BHContext *)context &#123;    _context = context;        static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        [self loadStaticServices];        [self loadStaticModules];    &#125;);&#125;- (void)loadStaticModules &#123;    [[BHModuleManager sharedManager] loadLocalModules];    [[BHModuleManager sharedManager] registedAllModules];&#125;\r\n重点关注一下registedAllModules方法 ：\r\n1234567891011121314151617181920212223242526272829303132333435- (void)registedAllModules &#123;    /** 按照优先级从大到小顺序排列 */    [self.BHModuleInfos sortUsingComparator:^NSComparisonResult(NSDictionary *module1, NSDictionary *module2) &#123;        NSNumber *module1Level = (NSNumber *)[module1 objectForKey:kModuleInfoLevelKey];        NSNumber *module2Level =  (NSNumber *)[module2 objectForKey:kModuleInfoLevelKey];        if (module1Level.integerValue != module2Level.integerValue) &#123;            return module1Level.integerValue &gt; module2Level.integerValue;        &#125; else &#123;            NSNumber *module1Priority = (NSNumber *)[module1 objectForKey:kModuleInfoPriorityKey];            NSNumber *module2Priority = (NSNumber *)[module2 objectForKey:kModuleInfoPriorityKey];            return module1Priority.integerValue &lt; module2Priority.integerValue;        &#125;    &#125;];        NSMutableArray *tmpArray = [NSMutableArray array];        //module init：初始化所有的module    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary *module, NSUInteger idx, BOOL * _Nonnull stop) &#123;                NSString *classStr = [module objectForKey:kModuleInfoNameKey];                Class moduleClass = NSClassFromString(classStr);        BOOL hasInstantiated = ((NSNumber *)[module objectForKey:kModuleInfoHasInstantiatedKey]).boolValue;        if (NSStringFromClass(moduleClass) &amp;&amp; !hasInstantiated) &#123;            id&lt;BHModuleProtocol&gt; moduleInstance = [[moduleClass alloc] init];            [tmpArray addObject:moduleInstance];        &#125;            &#125;];    //    [self.BHModules removeAllObjects];    [self.BHModules addObjectsFromArray:tmpArray];    //给module对象注册系统事件    [self registerAllSystemEvents];&#125;\r\n在经历registedAllModules方法之后，所有注册的module都生成了对应的实例对象。\r\n注意：\r\n\r\n所有的Module的对象都要是遵守BHModuleProtocol协议的。\r\nModule不能在任何其他地方alloc创建出来，即使创建一个新的Module实例出来，它也并不在BHModuleManager的管理下，无法接收BHModuleManager分发的系统事件。\r\n\r\nBeeHive模块间调用\r\n通过处理Event编写各个业务模块可以实现插件化编程，各业务模块之间没有任何依赖，core与module之间通过event交互，实现了插件隔离。但有时候我们需要模块间的相互调用某些功能来协同完成功能。目前模块间的调用使用基于接口的实现Service访问方式（Java\r\nspring框架实现）。基于接口Service访问的优点是可以编译时检查发现接口的变更，从而及时修正接口问题。缺点是需要依赖接口定义的头文件，通过模块增加得越多，维护接口定义的也有一定工作量。\r\n模块间调用的协议都是通过BHServiceManager来维护的。\r\nBeeHive提供了三种方式来注册协议，这里和module的注册方式相同：Annotation方式注册、读取本地plist方式注册、API注册。\r\nAnnotation方式注册\r\n使用@BeeHiveService进行Annotation标记。BeeHiveService的宏定义如下：\r\n1234#define BeeHiveService(servicename,impl) \\class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \\&quot;&quot;#servicename&quot;\\&quot; : \\&quot;&quot;#impl&quot;\\&quot;&#125;&quot;;#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))\r\n在示例中，@BeeHiveService(HomeServiceProtocol,BHViewController)在预编译结束后会完全展开成如下所示：\r\n1@class BeeHive; char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot;&quot;))) = &quot;&#123; \\&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\\&quot; : \\&quot;&quot;&quot;BHViewController&quot;&quot;\\&quot;&#125;”;\r\n这里类比注册module时的Annotation解析，也是把数据存在特殊的段内，具体的原理可以参考注册module的分析。\r\n同理，通过调用函数BHReadConfiguration读取之前注册到特殊段BeehiveServices中的数据，这里是如下所示的json字符串，{协议字符串:实现该协议的class类名字符串}，如下所示:\r\n&#123;\"HomeServiceProtocol\":\"BHViewController”&#125;\r\n读取到数据后，进行service的注册：\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)&#123;    //register module...        //register services    NSArray&lt;NSString *&gt; *services = BHReadConfiguration(BeehiveServiceSectName,mhp);    for (NSString *map in services) &#123;        NSData *jsonData =  [map dataUsingEncoding:NSUTF8StringEncoding];        NSError *error = nil;        id json = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];        if (!error) &#123;            if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [json allKeys].count) &#123;                                NSString *protocol = [json allKeys][0];                NSString *clsName  = [json allValues][0];                                if (protocol &amp;&amp; clsName) &#123;                    [[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];                &#125;                            &#125;        &#125;    &#125;&#125;- (void)registerService:(Protocol *)service implClass:(Class)implClass&#123;    NSParameterAssert(service != nil);    NSParameterAssert(implClass != nil);        if (![implClass conformsToProtocol:service]) &#123;        if (self.enableException) &#123;            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];        &#125;        return;    &#125;        //协议是否已经注册    if ([self checkValidService:service]) &#123;        if (self.enableException) &#123;            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];        &#125;        return;    &#125;        NSString *key = NSStringFromProtocol(service);    NSString *value = NSStringFromClass(implClass);        if (key.length &gt; 0 &amp;&amp; value.length &gt; 0) &#123;        [self.lock lock];        [self.allServicesDict addEntriesFromDictionary:@&#123;key:value&#125;];        [self.lock unlock];    &#125;&#125;\r\n在注册协议前会有两个检查registerService:implClass::\r\n\r\n检查implClass是否遵循了service\r\n检查service协议是否已经注册\r\n\r\n如果两个条件有一个没有检查通过，则会抛出异常。\r\n如果条件通过，则会在allServicesDict中加入键值对，{NSStringFromProtocol(service):NSStringFromClass(implClass)}\r\n读取本地Plist方式注册\r\n读取本地的plist文件之前，需要先设置plist文件路径。\r\n12//AppDelegate.m[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService”;\r\nBeeHive的配置都可以通过BHContext进行传递。\r\nplist中的数据格式如下：\r\n123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;array&gt;    &lt;dict&gt;        &lt;key&gt;service&lt;/key&gt;        &lt;string&gt;UserTrackServiceProtocol&lt;/string&gt;        &lt;key&gt;impl&lt;/key&gt;        &lt;string&gt;BHUserTrackViewController&lt;/string&gt;    &lt;/dict&gt;&lt;/array&gt;&lt;/plist&gt;\r\n注册plist中service的时机同注册plist管理的module类似：\r\n123456789101112131415161718192021222324252627282930313233343536373839// AppDelegate.m- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;            [BHContext shareInstance].application = application;    [BHContext shareInstance].launchOptions = launchOptions;    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;        [BeeHive shareInstance].enableException = YES;    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];        [super application:application didFinishLaunchingWithOptions:launchOptions];    ...        return YES;&#125;// BeeHive.m-(void)setContext:(BHContext *)context&#123;    _context = context;        static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        [self loadStaticServices];        [self loadStaticModules];    &#125;);&#125;-(void)loadStaticServices&#123;    [BHServiceManager sharedManager].enableException = self.enableException;        [[BHServiceManager sharedManager] registerLocalServices];    &#125;\r\n注册service的具体实现如下：\r\n123456789101112131415161718192021- (void)registerLocalServices&#123;    NSString *serviceConfigName = [BHContext shareInstance].serviceConfigName;        NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];    if (!plistPath) &#123;        return;    &#125;        NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath];        [self.lock lock];    for (NSDictionary *dict in serviceList) &#123;        NSString *protocolKey = [dict objectForKey:@&quot;service&quot;];        NSString *protocolImplClass = [dict objectForKey:@&quot;impl&quot;];        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];        &#125;    &#125;    [self.lock unlock];&#125;\r\n注册完成之后，allServicesDict中的值如下：\r\n1&#123;@&quot;HomeServiceProtocol&quot; : @&quot;BHViewController&quot;, @&quot;UserTrackServiceProtocol&quot; : @&quot;BHUserTrackViewController&quot;&#125;\r\n注意：NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@\"plist”];\r\n这段代码，如果主工程Podfile中未使用了use_frameworks!，则可以正常获取到plist，如果使用了use_frameworks!，则得使用其他方式获取，具体的方案请google。\r\nAPI注册\r\nAPI注册service使用的api是BeeHive的接口- (void)registerService:(Protocol *)proto service:(Class)serviceClass,\r\n该接口内部实现也是调用BHServiceManager的registerService:implClass:接口。\r\n1234// BeeHive.m- (void)registerService:(Protocol *)proto service:(Class)serviceClass &#123;    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];&#125;\r\n例如：[[BeeHive shareInstance] registerService:@protocol(TradeServiceProtocol) service:[BHTradeViewController class]];,\r\n该代码可以放置在module的\r\nmodInit:方法内部或者modSetup:方法内部，具体可以查看使用文档或者demo。\r\n注意：BHMSetupEvent和BHMInitEvent事件都会在项目的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions函数内部触发。\r\nBHServiceManager中的allServicesDict包含了所有方式注册的service。\r\n与module注册相比，service的注册没有对实现协议的对象进行初始化。只是将协议和实现协议的对象之间的这种关联关系存储和维护，而在module的注册过程中，对所有注册的module进行实例的初始化。\r\n因此，在BHServiceManager的公共接口中，有一组createService:接口用于访问实现协议的对象。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (id)createService:(Protocol *)service&#123;    return [self createService:service withServiceName:nil];&#125;- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;    return [self createService:service withServiceName:serviceName shouldCache:YES];&#125;- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;    if (!serviceName.length) &#123;        serviceName = NSStringFromProtocol(service);    &#125;    id implInstance = nil;        if (![self checkValidService:service]) &#123;        if (self.enableException) &#123;            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];        &#125;            &#125;        NSString *serviceStr = serviceName;    if (shouldCache) &#123;        id protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];        if (protocolImpl) &#123;            return protocolImpl;        &#125;    &#125;        Class implClass = [self serviceImplClass:service];    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;        if ([[implClass class] singleton]) &#123;            if ([[implClass class] respondsToSelector:@selector(shareInstance)])                implInstance = [[implClass class] shareInstance];            else                implInstance = [[implClass alloc] init];            if (shouldCache) &#123;                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];                return implInstance;            &#125; else &#123;                return implInstance;            &#125;        &#125;    &#125;    return [[implClass alloc] init];&#125;\r\n从上面的实现中可以看出：\r\n\r\nservice对象存在单例和多实例的区别。\r\n如果BHServiceProtocol协议对象实现了singleton返回YES，且shouldCache入参值是YES，则通过createService:获取的对象为单例对象，如果singleton方法返回的是NO，则每次调用createService:都会创建一个新的对象。\r\n这里的单例存在线程安全问题。如果开发者将BHServiceProtocol协议对象实现了singleton返回YES，且shareInstance方法的实现是返回单例对象，则不管shouldCache的入参值是YES还是NO，createService:都会是同一个实例。但是，如果开发者将shareInstance方法的实现只是返回对象(非单例)，即使singleton返回YES，shouldCache入参值是YES，也可能存在多个实例的情况。\r\n\r\n上下文环境Context\r\nBeeHive中使用BHContext初始化设置应用的项目信息，并在各模块间共享整个应用程序的信息。例如：\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;    [BHContext shareInstance].env ＝ BHEnvironmentDev; //定义应用的运行开发环境    [BHContext shareInstance].application = application;    [BHContext shareInstance].launchOptions = launchOptions;    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/CustomModulePlist&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist    [BHContext shareInstance].serviceConfigName =  @&quot;BeeHive.bundle/CustomServicePlist&quot;;//可选，默认为BeeHive.bundle/BHService.plist    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];    [super application:application didFinishLaunchingWithOptions:launchOptions];...    return YES;&#125;//BHContext.h@interface BHContext : NSObject &lt;NSCopying&gt;//global env@property(nonatomic, assign) BHEnvironmentType env;//global config@property(nonatomic, strong) BHConfig *config;//application appkey@property(nonatomic, strong) NSString *appkey;//customEvent&gt;=1000@property(nonatomic, assign) NSInteger customEvent;@property(nonatomic, strong) UIApplication *application;@property(nonatomic, strong) NSDictionary *launchOptions;@property(nonatomic, strong) NSString *moduleConfigName;@property(nonatomic, strong) NSString *serviceConfigName;//3D-Touch model#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400@property (nonatomic, strong) BHShortcutItem *touchShortcutItem;#endif//OpenURL model@property (nonatomic, strong) BHOpenURLItem *openURLItem;//Notifications Remote or Local@property (nonatomic, strong) BHNotificationsItem *notificationsItem;//user Activity Model@property (nonatomic, strong) BHUserActivityItem *userActivityItem;//watch Model@property (nonatomic, strong) BHWatchItem *watchItem;//custom param@property (nonatomic, copy) NSDictionary *customParam;@end\r\n\r\n应用的运行开发环境\r\n应用启动信息：application，launchOptions\r\nmodule和service的plist配置信息\r\n缓存的service\r\n3D-Touch, OpenURL moduel, Remote Or Local Notifications, User\r\nActivity Model等\r\n\r\n最后，附一张BeeHive主要类的的类图关系。\r\n\r\nBeeHive类图\r\n\r\n目前已转行教育行业，欢迎加微信交流：CaryaLiu\r\n","dateCreated":"2018-10-11T11:14:46+08:00","dateModified":"2024-10-21T22:51:44+08:00","datePublished":"2018-10-11T11:14:46+08:00","description":"本文是基于BeeHive版本1.6.0进行分析。\r\nBeeHive核心思想涉及两个部分：\r\n\r\n各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。\r\nApp生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。\r\n\r\nCore+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。","headline":"阿里组件化框架BeeHive解析","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://liumh.com/2018/10/11/beehive-analysis/"},"publisher":{"@type":"Organization","name":"CaryaLiu","sameAs":[],"image":"header.png","logo":{"@type":"ImageObject","url":"header.png"}},"url":"http://liumh.com/2018/10/11/beehive-analysis/","keywords":"iOS, 设计模式"}</script>
    <meta name="description" content="本文是基于BeeHive版本1.6.0进行分析。 BeeHive核心思想涉及两个部分：  各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。 App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。  Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。">
<meta property="og:type" content="blog">
<meta property="og:title" content="阿里组件化框架BeeHive解析">
<meta property="og:url" content="http://liumh.com/2018/10/11/beehive-analysis/index.html">
<meta property="og:site_name" content="CaryaLiu&#39;s blog">
<meta property="og:description" content="本文是基于BeeHive版本1.6.0进行分析。 BeeHive核心思想涉及两个部分：  各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。 App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。  Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-arch.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-register-module.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-event-extension.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-register-local-service.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-dynamic-register-service.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-create-service.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-system-event.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-event-extension.png">
<meta property="og:image" content="http://liumh.com/img/beehive-analysis/beehive-class.png">
<meta property="article:published_time" content="2018-10-11T03:14:46.000Z">
<meta property="article:modified_time" content="2024-10-21T14:51:44.370Z">
<meta property="article:author" content="CaryaLiu">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://liumh.com/img/beehive-analysis/beehive-arch.png">
    
    
        
    
    
        <meta property="og:image" content="http://liumh.com/assets/images/header.png"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-zpenvh5cbgb1vzzlq3akzblrroxrej3zx0naeyxu1vn9s3kx3bsq9s1rbqce.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CaryaLiu&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">CaryaLiu</h4>
                
                    <h5 class="sidebar-profile-bio"><p><span class="citation"
data-cites="Chengdu">@Chengdu</span>，WeChat：CaryaLiu</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            阿里组件化框架BeeHive解析
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-10-11T11:14:46+08:00">
	
		    Oct 11, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>本文是基于BeeHive版本1.6.0进行分析。</p>
<p>BeeHive核心思想涉及两个部分：</p>
<ol type="1">
<li>各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖。</li>
<li>App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。</li>
</ol>
<p>Core+Plugin的形式可以让一个应用主流程部分得到集中管理，不同模块以plugin形式存在，便于横向的扩展和移植。</p>
<span id="more"></span>
<p>本文会按照以下顺序进行介绍：</p>
<ul>
<li><a href="#beehive-overview">BeeHive概览</a></li>
<li><a href="#beehive-lifecycle-event">BeeHive模块生命周期事件</a>
<ul>
<li><a href="#beehive-system-event">系统事件</a></li>
<li><a href="#beehive-event-extension">通用事件</a></li>
<li><a href="#beehive-custom-event">业务自定义事件</a></li>
</ul></li>
<li><a href="#beehive-register-module">BeeHive模块注册</a>
<ul>
<li><a href="#annotation-register-module">Annotation方式注册</a></li>
<li><a href="#plist-register-module">读取本地Plist方式注册</a></li>
<li><a href="#load-register-module">Load方法注册</a></li>
</ul></li>
<li><a href="#beehive-register-service">BeeHive模块间调用</a>
<ul>
<li><a href="#annotation-register-service">Annotation方式注册</a></li>
<li><a href="#plist-register-service">读取本地Plist方式注册</a></li>
<li><a href="#api-register-service">API注册</a></li>
</ul></li>
<li><a href="#beehive-context">上下文环境Context</a></li>
</ul>
<h1 id="beehive概览">BeeHive概览</h1>
<p>BeeHive的架构图如下所示：</p>
<!--![BeeHive架构图](/img/beehive-analysis/beehive-arch.png)-->
<div class="figure " style="width:684;"><img class="fig-img" src="/img/beehive-analysis/beehive-arch.png" style="width:684;height:379;"alt="BeeHive架构图"><span class="caption">BeeHive架构图</span></div>
<p>图中的BHContext，包含BeeHive的配置文件，提供全局统一上下文信息。</p>
<p>图中的BHCore包含：</p>
<ul>
<li>BeeHive，提供组件库对外接口</li>
<li>BHModuleManager和BHModuleProtocol，注册和创建Module逻辑</li>
<li>BHServiceManager和BHServiceProtocol，注册和创建Service逻辑</li>
<li>BHRouter</li>
</ul>
<p>Module、Service注册和调用逻辑只和核心模块相关，Module之间没有直接的关联关系。</p>
<p>对于Module和Service的注册，BeeHive提供了三种不同的形式：静态plist，动态注册，annotation。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p>
<!--![Module注册](/img/beehive-analysis/beehive-register-module.png)-->
<div class="figure " style="width:682;"><img class="fig-img" src="/img/beehive-analysis/beehive-register-module.png" style="width:682;height:564;"alt="Module注册"><span class="caption">Module注册</span></div>
<p>图中包含了主要的BeeHive启动过程以及Module注册的时序逻辑。Module的事件分发源于BHAppDelegate中的<em>triggerEvent</em>。</p>
<p>加载Module：</p>
<ol type="1">
<li>BeeHive.plist中配置的module和service是在 AppDelegate中调用
<code>[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</code>
时加载。</li>
<li>Module的实现中 <code>+load</code>内部调用
<code>[BeeHive registerDynamicModule:[self class]];</code>
动态加载。</li>
<li>Module的实现中使用注解： <code>@BeeHiveMod(XXModule)</code></li>
</ol>
<p>BHAppDelegate中除了回调系统的事件，还将App生命周期进行扩展，增加<em>ModuleSetup</em>，<em>ModuleInit</em>，<em>ModuleSplash</em>，此外开发人员还可以自行扩展。</p>
<!--![BeeHive事件扩展](/img/beehive-analysis/beehive-event-extension.png)-->
<div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-event-extension.png" alt="BeeHive事件扩展"><span class="caption">BeeHive事件扩展</span></div>
<p>扩展周期过程中，同时加入Module分析量化功能，每个模块Init的耗时均可计算出来，为性能优化做到数据上的支持。一个App的业务增多过程中，通过分析定位Module的Init耗时可以确定需要优化的Module。</p>
<p>Module遵循<em>BHModuleProtocol</em>后，能够捕获App状态的回调，并拥有App生命周期内的全局上下文，通过context可获取配置参数，模块资源以及服务资源。</p>
<p>以BeeHive作为底层框架的App，除了解耦带来的便利，开发人员在开发新App过程中涉及相同功能的Module，无需重复造轮子，直接移植Module，开发一个App如同拼装积木，能组合需要的功能业务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BHModuleManager.m:</span><br><span class="line"></span><br><span class="line">//BHModuleInfos: [&#123;moduleClass:String, ModuleLevel:NSNumber, modulePriority:String&#125;]</span><br><span class="line">//BHModules: [id&lt;BHModuleProtocol&gt;]</span><br><span class="line"></span><br><span class="line">@interface BHModuleManager()</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableArray *BHModuleDynamicClasses;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableArray&lt;NSDictionary *&gt; *BHModuleInfos;</span><br><span class="line">@property(nonatomic, strong) NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *BHModules;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSMutableArray&lt;id&lt;BHModuleProtocol&gt;&gt; *&gt; *BHModulesByEvent;</span><br><span class="line">@property(nonatomic, strong) NSMutableDictionary&lt;NSNumber *, NSString *&gt; *BHSelectorByEvent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><em>BHModuleInfos</em>和<em>BHModulesByEvent</em>中<code>id&lt;BHModuleProtocol&gt;</code>均按照<em>moduleInstances</em>的<em>moduleLevel</em>和<em>modulePriority</em>进行了排序。</p>
<!--![注册静态plist service](/img/beehive-analysis/beehive-register-local-service.png)-->
<div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-register-local-service.png" alt="注册静态plist service"><span class="caption">注册静态plist service</span></div>
<p>上图中包含注册静态plist中service的相关逻辑，App启动时通过BeeHive的<code>setContext:</code>来触发plist中service的注册。service的注册并没有创建对应的service实例，只是在BHServiceManager中建立<em>Service协议</em>和<em>实现该协议的类</em>之间的映射关系。</p>
<!--![动态注册service](/img/beehive-analysis/beehive-dynamic-register-service.png)-->
<div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-dynamic-register-service.png" alt="动态注册service"><span class="caption">动态注册service</span></div>
<p>上图中是动态注册service的逻辑，这是在App启动事件分发时触发。Module根据需求动态注册某个服务，通常，注册service的代码在module的<code>modInit:</code>或者<code>modSetup:</code>中。</p>
<!--![创建service实例](/img/beehive-analysis/beehive-create-service.png)-->
<div class="figure " style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-create-service.png" alt="创建service实例"><span class="caption">创建service实例</span></div>
<p>业务组件可以通过<code>createService:</code>直接调用服务。Service的调用和实现，核心是BHServiceManager。可以单独创建Services
Interface
Pod，统一放置要用的Services，这样的业务依赖就从网状式变成中心式，业务方只需依赖Services一个。</p>
<p>Service可以按需加载，BeeHive逻辑是将基础服务注册在plist中，业务型服务允许Service不先注册，直到业务需要时才被动态注册。</p>
<p>Service支持两种不同模式：</p>
<ul>
<li>单例：
对于全局统一且无状态服务，建议使用这种创建形式，这样有利于Service的统一管理以及减少不必要内存消耗。</li>
<li>多实例：
每次调用服务都重新创建新的服务，对于涉及状态以及状态变化的服务最适合使用多实例方式。</li>
</ul>
<p>在多线程环境下遇到了Service读写问题，已通过Lock来已避免Array
crash问题。 不过Service还存在如下问题：</p>
<ul>
<li>Service依赖关系,导致底层依赖的Service没有被创建时就被调用。</li>
<li>规划Service、Module创建顺序，使得App达到秒开，优化性能体验。</li>
</ul>
<p>前者依赖问题计划通过调度机制来解决，后者还需要将AppDelegate更多业务剥离以及实践才可。</p>
<p>BeeHive使用<code>createService:</code>和<code>createService:withServiceName:</code>来创建实现了协议的对象，并且缓存该对象。</p>
<h1 id="beehive模块生命周期事件">BeeHive模块生命周期事件</h1>
<p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p>
<p>事件分为三种类型：</p>
<ul>
<li>系统事件</li>
<li>通用事件</li>
<li>业务自定义事件</li>
</ul>
<p>在BHModuleManager的头文件中，Event的类型定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    BHMSetupEvent = 0,</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent = 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="系统事件">系统事件</h2>
<!--![BeeHive系统事件](/img/beehive-analysis/beehive-system-event.png)-->
<div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-system-event.png" alt="BeeHive系统事件"><span class="caption">BeeHive系统事件</span></div>
<p>系统事件通常是Application生命周期事件，例如<em>WillResignActiveEvent</em>,
<em>DidEnterBackgroundEvent</em>, <em>WillEnterForegroundEvent</em>,
<em>DidBecomeActiveEvent</em>, <em>WillTerminateEvent</em>。</p>
<p>一般做法是使用BHAppDelegate来接管系统事件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//TestAppDelegate.h</span><br><span class="line">#import &quot;BeeHive.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br><span class="line"></span><br><span class="line">//TestAppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br><span class="line">    </span><br><span class="line">    [BeeHive shareInstance].enableException = YES;</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BHAppDelegate的实现文件中，实现了一系列的系统调用事件。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMSetupEvent];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMInitEvent];</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMSplashEvent];</span><br><span class="line">    &#125;);</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span><br><span class="line">    if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 10.0f) &#123;</span><br><span class="line">        [UNUserNotificationCenter currentNotificationCenter].delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] saveTimeProfileDataIntoFile:@&quot;BeeHiveTimeProfiler&quot;];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400 </span><br><span class="line"></span><br><span class="line">-(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.touchShortcutItem setShortcutItem: shortcutItem];</span><br><span class="line">    [[BeeHive shareInstance].context.touchShortcutItem setScompletionHandler: completionHandler];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMQuickActionEvent];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillResignActiveEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidEnterBackgroundEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillEnterForegroundEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidBecomeActiveEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillTerminateEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOpenURL:url];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setSourceApplication:sourceApplication];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setAnnotation:annotation];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80400</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOpenURL:url];</span><br><span class="line">    [[BeeHive shareInstance].context.openURLItem setOptions:options];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMOpenURLEvent];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveMemoryWarningEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationsError:error];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToRegisterForRemoteNotificationsEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setDeviceToken: deviceToken];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidRegisterForRemoteNotificationsEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setUserInfo: userInfo];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationResultHander: completionHandler];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveRemoteNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification</span><br><span class="line">&#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setLocalNotification: notification];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveLocalNotificationEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80000</span><br><span class="line">- (void)application:(UIApplication *)application didUpdateUserActivity:(NSUserActivity *)userActivity</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMDidUpdateUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didFailToContinueUserActivityWithType:(NSString *)userActivityType error:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityError: error];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMDidFailToContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivity: userActivity];</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setRestorationHandler: restorationHandler];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application willContinueUserActivityWithType:(NSString *)userActivityType</span><br><span class="line">&#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [[BeeHive shareInstance].context.userActivityItem setUserActivityType: userActivityType];</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMWillContinueUserActivityEvent];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)application:(UIApplication *)application handleWatchKitExtensionRequest:(nullable NSDictionary *)userInfo reply:(void(^)(NSDictionary * __nullable replyInfo))reply &#123;</span><br><span class="line">    if([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0f)&#123;</span><br><span class="line">        [BeeHive shareInstance].context.watchItem.userInfo = userInfo;</span><br><span class="line">        [BeeHive shareInstance].context.watchItem.replyHandler = reply;</span><br><span class="line">        [[BHModuleManager sharedManager] triggerEvent:BHMHandleWatchKitExtensionRequestEvent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler &#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotification: notification];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationPresentationOptionsHandler: completionHandler];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setCenter:center];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMWillPresentNotificationEvent];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler &#123;</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationResponse: response];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setNotificationCompletionHandler:completionHandler];</span><br><span class="line">    [[BeeHive shareInstance].context.notificationsItem setCenter:center];</span><br><span class="line">    [[BHModuleManager sharedManager] triggerEvent:BHMDidReceiveNotificationResponseEvent];</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样所有的系统事件都可以通过BHModuleManager的<code>triggerEvent:</code>来处理。</p>
<p>在上述事件中，<em>BHMInitEvent</em>和<em>BHMTearDownEvent</em>事件需要做特殊处理。</p>
<p>先看看<em>BHMInitEvent</em>的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesInitEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                        withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = BHMInitEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMInitEvent)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        __weak typeof(&amp;*self) wself = self;</span><br><span class="line">        void ( ^ bk )(void);</span><br><span class="line">        bk = ^()&#123;</span><br><span class="line">            __strong typeof(&amp;*self) sself = wself;</span><br><span class="line">            if (sself) &#123;</span><br><span class="line">                if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123;</span><br><span class="line">                    [moduleInstance modInit:context];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- modInit:&quot;, [moduleInstance class]]];</span><br><span class="line">        </span><br><span class="line">        if ([moduleInstance respondsToSelector:@selector(async)]) &#123;</span><br><span class="line">            BOOL async = [moduleInstance async];</span><br><span class="line">            </span><br><span class="line">            if (async) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    bk();</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>BHMInitEvent</em>事件是触发各个module启动时的初始化逻辑。这里从<code>self.BHModulesByEvent</code>中取出<em>BHMInitEvent</em>事件对应的module数组，遍历其中的每个module实例，向其发送<code>modInit:</code>消息。这里会考虑是否异步执行module的初始化。如果moduleInstance重写了<code>async</code>方法，那么就会根据该方法的返回值来决定是否异步执行module的初始化。</p>
<p><code>modInit:</code>方法由各个module实例各自实现，可以在其中注册一个外部模块可以访问的<code>Service</code>接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)modInit:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    //注册模块的接口服务</span><br><span class="line">    [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看<em>BHMTearDownEvent</em>事件。这个事件中可以处理module的清理工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesTearDownEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                            withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = BHMTearDownEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(BHMTearDownEvent)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Reverse Order to unload</span><br><span class="line">    for (int i = (int)moduleInstances.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance = [moduleInstances objectAtIndex:i];</span><br><span class="line">        if (moduleInstance &amp;&amp; [moduleInstance respondsToSelector:@selector(modTearDown:)]) &#123;</span><br><span class="line">            [moduleInstance modTearDown:context];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于module具有优先级，且<code>self.BHModulesByEvent</code>结构中，每种事件类型对应的modules数组中的module元素都已经按照优先级从高到低排列，因此逆序对modules数组中的module元素调用<code>modTearDown:</code>方法。</p>
<h2 id="通用事件">通用事件</h2>
<p>在系统事件的基础之上，扩展了应用的通用事件，例如<em>modSetup</em>、<em>modInit</em>等，可以用于编码实现各插件模块的设置与初始化。</p>
<p>扩展的通用事件如下：</p>
<!--![BeeHive通用事件](/img/beehive-analysis/beehive-event-extension.png)-->
<div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-event-extension.png" alt="BeeHive通用事件"><span class="caption">BeeHive通用事件</span></div>
<p>所有的事件都可以通过调用BHModuleManager的<code>triggerEvent:</code>来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，事件类型分发是在方法<code>handleModuleEvent:forTarget:withCustomParam:</code>中进行。如之前所述，需要对<em>BHMInitEvent</em>和<em>BHMTearDownEvent</em>做特殊处理。同时，触发各个module(从<code>self.BHModulesByEvent</code>中获取)中的响应事件方法通过<code>performSelector:withObject:</code>来调用。</p>
<p>注意这里的module都是遵循<em>BHModuleProtocol</em>协议的。</p>
<p>通用事件中，可以在<em>modSetup</em>中设置环境变量,通过<em>context.env</em>可以判断我们的应用环境状态来决定我们如何配置我们的应用。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)modSetup:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    switch (context.env) &#123;</span><br><span class="line">        case BHEnvironmentDev:</span><br><span class="line">        //....初始化开发环境</span><br><span class="line">        break;</span><br><span class="line">        case BHEnvironmentProd:</span><br><span class="line">        //....初始化生产环境</span><br><span class="line">        default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="业务自定义事件">业务自定义事件</h2>
<p>如果觉得系统事件、通用事件不足以满足需要，我们还将事件封装简化成BHAppdelgate，你可以通过继承
BHAppdelegate来扩展自己的事件。通过以下方式来注册自定义事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerCustomEvent:(NSInteger)eventType</span><br><span class="line">   withModuleInstance:(id)moduleInstance</span><br><span class="line">       andSelectorStr:(NSString *)selectorStr &#123;</span><br><span class="line">    if (eventType &lt; 1000) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self registerEvent:eventType withModuleInstance:moduleInstance andSelectorStr:selectorStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发带参数的事件响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="beehive模块注册">BeeHive模块注册</h1>
<p>使用注解的方式注册Module和Service时，Module和Service的注册发生在加载镜像文件时期。</p>
<p>plist方式注册Module和Service，是在AppDelegate中设置BeeHive的Context时加载注册。</p>
<p>Module动态注册是在+load方法中，也是在加载镜像时注册。Service的动态注册可以Module的<code>modInit:</code>或者<code>modSetup:</code>中，或者使用时注册。</p>
<p>模块注册有三种方式：Annotation方式注册、读取本地plist方式注册、Load方法注册。所谓注册，就是将Module类告知BHModuleManager来管理。由此可见，在BeeHive中是通过BHModuleManager来管理各个模块的，BHModuleManager中只会管理已经被注册过的模块。</p>
<h2 id="annotation方式注册">Annotation方式注册</h2>
<p>通过BeeHiveMod宏进行Annotation标记。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BeeHiveMod(ShopModule)</span><br></pre></td></tr></table></figure>
<p>BeeHiveMod宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = &quot;&quot;#name&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>BeeHiveDATA也是一个宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))</span><br></pre></td></tr></table></figure>
<p>在预编译结束后，BeeHiveMode宏最终会完全展开成下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意双引号的总对数。</p>
<p>关于__attribute的用法，可参考我的另一篇<a
href="http://liumh.com/2018/08/18/ios-attribute-section/"><strong>attribute</strong></a></p>
<p>__attribute第一个参数<em>used</em>,它的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。</p>
<p>有时候我们需要指定一个特殊的段，来存放我们想要的数据。这里我们就把数据存在__DATA数据段里面的"BeehiveMods"section中。
Attributes的修饰关键字<code>section ("section-name”)</code>可以达到此要求。</p>
<p>上述代码中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>去掉__attribute的属性，相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>只不过是将<em>kShopModule_mod</em>变量存储在了__DATA段的<em>BeehiveMods</em>
section中。</p>
<p>这样，所有的Module类名的字符串都会放置在__DATA段<em>BeehiveMods</em>
section中，那么如何取出这些字符串呢？</p>
<p>这里先介绍一下<code>__attribute__((constructor))</code>：</p>
<p><em>constructor</em>：顾名思义，构造器加上这个属性的函数会在可执行文件（或
shared library）load时被调用，可以理解为在 main() 函数调用前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;main&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;</span><br></pre></td></tr></table></figure>
<p><code>_dyld_register_func_for_add_image</code>:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following functions allow you to install callbacks which will be called   </span><br><span class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line"> * and before the image is un-memory-mapped.</span><br><span class="line"> */</span><br><span class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) </span><br><span class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))</span><br></pre></td></tr></table></figure>
<p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调<code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的mach_header以及一个虚拟内存地址
intptr_t。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls = NSClassFromString(modName);</span><br><span class="line">            </span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mach_header是定义在<code>usr/include/mach-o/loader.h</code>中的数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">     uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">     cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">     cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">     uint32_t    filetype;    /* type of file */</span><br><span class="line">     uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">     uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">     uint32_t    flags;        /* flags */</span><br><span class="line">     uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过调用<em>BHReadConfiguration</em>函数，我们就可以拿到之前注册到<em>BeehiveMods</em>特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p>
<p>然后将Module交由到BHModuleManager管理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addModuleFromObject:(id)object</span><br><span class="line">     shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    Class class;</span><br><span class="line">    NSString *moduleName = nil;</span><br><span class="line">    </span><br><span class="line">    if (object) &#123;</span><br><span class="line">        class = object;</span><br><span class="line">        moduleName = NSStringFromClass(class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 检测是否已存在Module类 */</span><br><span class="line">    __block BOOL flag = YES;</span><br><span class="line">    [self.BHModules enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([obj isKindOfClass:class]) &#123;</span><br><span class="line">            flag = NO;</span><br><span class="line">            *stop = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    if (!flag) &#123;  /**&lt; 如果已存在，则返回，不做处理 */</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([class conformsToProtocol:@protocol(BHModuleProtocol)]) &#123;</span><br><span class="line">        NSMutableDictionary *moduleInfo = [NSMutableDictionary dictionary];</span><br><span class="line">        </span><br><span class="line">        /** basicModuleLevel 这个方法如果不实现，Level是Normal: 1 */</span><br><span class="line">        BOOL responseBasicLevel = [class instancesRespondToSelector:@selector(basicModuleLevel)];</span><br><span class="line">        int levelInt = 1;</span><br><span class="line">        </span><br><span class="line">        if (responseBasicLevel) &#123;</span><br><span class="line">            /** basicModuleLevel 这个方法如果实现，Level是Basic: 0 */</span><br><span class="line">            levelInt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey];</span><br><span class="line">        if (moduleName) &#123;</span><br><span class="line">            [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey];</span><br><span class="line">        &#125;</span><br><span class="line">        [self.BHModuleInfos addObject:moduleInfo];</span><br><span class="line">        </span><br><span class="line">        /** 初始化module实例 */</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance = [[class alloc] init];</span><br><span class="line">        [self.BHModules addObject:moduleInstance];</span><br><span class="line">        [moduleInfo setObject:@(YES) forKey:kModuleInfoHasInstantiatedKey];</span><br><span class="line"></span><br><span class="line">        /** 将module按照优先级排序 */</span><br><span class="line">        [self.BHModules sortUsingComparator:^NSComparisonResult(id&lt;BHModuleProtocol&gt; moduleInstance1, id&lt;BHModuleProtocol&gt; moduleInstance2) &#123;</span><br><span class="line">            NSNumber *module1Level = @(BHModuleNormal);</span><br><span class="line">            NSNumber *module2Level = @(BHModuleNormal);</span><br><span class="line">            if ([moduleInstance1 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module1Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if ([moduleInstance2 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module2Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">                return module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSInteger module1Priority = 0;</span><br><span class="line">                NSInteger module2Priority = 0;</span><br><span class="line">                if ([moduleInstance1 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module1Priority = [moduleInstance1 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                if ([moduleInstance2 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module2Priority = [moduleInstance2 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                return module1Priority &lt; module2Priority;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        /** 给module注册事件 */</span><br><span class="line">        [self registerEventsByModuleInstance:moduleInstance];</span><br><span class="line">        </span><br><span class="line">        if (shouldTriggerInitEvent) &#123;</span><br><span class="line">            [self handleModuleEvent:BHMSetupEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            [self handleModulesInitEventForTarget:moduleInstance withCustomParam:nil];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [self handleModuleEvent:BHMSplashEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有需要注册的Module必须遵循<em>BHModuleProtocol</em>协议，否则不会被存储。</p>
<h2 id="读取本地plist方式注册">读取本地Plist方式注册</h2>
<p>首先需要设置本地Plist文件的读取路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br></pre></td></tr></table></figure>
<p>BeeHive的所有配置都可以通过BHContext进行传递。</p>
<p>Plist文件的字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">     &lt;key&gt;URLGlobalScheme&lt;/key&gt;</span><br><span class="line">     &lt;string&gt;com.alibaba.beehive&lt;/string&gt;</span><br><span class="line">     &lt;key&gt;moduleClasses&lt;/key&gt;</span><br><span class="line">     &lt;array&gt;</span><br><span class="line">         &lt;dict&gt;</span><br><span class="line">             &lt;key&gt;moduleClass&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;HomeModule&lt;/string&gt;</span><br><span class="line">             &lt;key&gt;moduleLevel&lt;/key&gt;</span><br><span class="line">             &lt;integer&gt;1&lt;/integer&gt;</span><br><span class="line">             &lt;key&gt;modulePriority&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;600&lt;/string&gt;</span><br><span class="line">         &lt;/dict&gt;</span><br><span class="line">         &lt;dict&gt;</span><br><span class="line">             &lt;key&gt;moduleClass&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;TMTradeAdapter&lt;/string&gt;</span><br><span class="line">             &lt;key&gt;moduleLevel&lt;/key&gt;</span><br><span class="line">             &lt;integer&gt;1&lt;/integer&gt;</span><br><span class="line">             &lt;key&gt;modulePriority&lt;/key&gt;</span><br><span class="line">             &lt;string&gt;599&lt;/string&gt;</span><br><span class="line">         &lt;/dict&gt;</span><br><span class="line">     &lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p>在AppDelegate中
<code>[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</code>
设置BHContext时就会注册plist中的module。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy;</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Plist中的module加入到<em>BHModuleInfos</em>中。</p>
<h2 id="load方法注册">Load方法注册</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// BeeHive</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BHModuleManager</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Load方法最终是调用BHModuleManager中的<code>registerDynamicModule:</code>方法来处理，该方法已在上一节中说明。</p>
<p>+load的方式可以使用<em>BH_EXPORT_MODULE</em>宏来替代完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure>
<p>在<em>BH_EXPORT_MODULE</em>宏中传入了参数<em>isAsync</em>，代表是否异步加载Module模块。如果是YES，则表示需要异步加载，NO则表示同步加载。</p>
<p>回过头来看看AppDelegate中setContext方法中的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate</span><br><span class="line">[[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line"></span><br><span class="line">// BeeHive</span><br><span class="line">-(void)setContext:(BHContext *)context &#123;</span><br><span class="line">    _context = context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)loadStaticModules &#123;</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注一下registedAllModules方法 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)registedAllModules &#123;</span><br><span class="line">    /** 按照优先级从大到小顺序排列 */</span><br><span class="line">    [self.BHModuleInfos sortUsingComparator:^NSComparisonResult(NSDictionary *module1, NSDictionary *module2) &#123;</span><br><span class="line">        NSNumber *module1Level = (NSNumber *)[module1 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        NSNumber *module2Level =  (NSNumber *)[module2 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        if (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">            return module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSNumber *module1Priority = (NSNumber *)[module1 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            NSNumber *module2Priority = (NSNumber *)[module2 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            return module1Priority.integerValue &lt; module2Priority.integerValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *tmpArray = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    //module init：初始化所有的module</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary *module, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *classStr = [module objectForKey:kModuleInfoNameKey];</span><br><span class="line">        </span><br><span class="line">        Class moduleClass = NSClassFromString(classStr);</span><br><span class="line">        BOOL hasInstantiated = ((NSNumber *)[module objectForKey:kModuleInfoHasInstantiatedKey]).boolValue;</span><br><span class="line">        if (NSStringFromClass(moduleClass) &amp;&amp; !hasInstantiated) &#123;</span><br><span class="line">            id&lt;BHModuleProtocol&gt; moduleInstance = [[moduleClass alloc] init];</span><br><span class="line">            [tmpArray addObject:moduleInstance];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">//    [self.BHModules removeAllObjects];</span><br><span class="line">    [self.BHModules addObjectsFromArray:tmpArray];</span><br><span class="line">    //给module对象注册系统事件</span><br><span class="line">    [self registerAllSystemEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在经历registedAllModules方法之后，所有注册的module都生成了对应的实例对象。</p>
<p>注意：</p>
<ol type="1">
<li>所有的Module的对象都要是遵守<em>BHModuleProtocol</em>协议的。</li>
<li>Module不能在任何其他地方alloc创建出来，即使创建一个新的Module实例出来，它也并不在BHModuleManager的管理下，无法接收BHModuleManager分发的系统事件。</li>
</ol>
<h1 id="beehive模块间调用">BeeHive模块间调用</h1>
<p>通过处理Event编写各个业务模块可以实现插件化编程，各业务模块之间没有任何依赖，core与module之间通过event交互，实现了插件隔离。但有时候我们需要模块间的相互调用某些功能来协同完成功能。目前模块间的调用使用基于接口的实现Service访问方式（Java
spring框架实现）。基于接口Service访问的优点是可以编译时检查发现接口的变更，从而及时修正接口问题。缺点是需要依赖接口定义的头文件，通过模块增加得越多，维护接口定义的也有一定工作量。</p>
<p>模块间调用的协议都是通过BHServiceManager来维护的。</p>
<p>BeeHive提供了三种方式来注册协议，这里和module的注册方式相同：Annotation方式注册、读取本地plist方式注册、API注册。</p>
<h2 id="annotation方式注册-1">Annotation方式注册</h2>
<p>使用<code>@BeeHiveService</code>进行Annotation标记。BeeHiveService的宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot;&quot;)))</span><br></pre></td></tr></table></figure>
<p>在示例中，<code>@BeeHiveService(HomeServiceProtocol,BHViewController)</code>在预编译结束后会完全展开成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot;&quot;))) = &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;”;</span><br></pre></td></tr></table></figure>
<p>这里类比注册module时的Annotation解析，也是把数据存在特殊的段内，具体的原理可以参考注册module的分析。</p>
<p>同理，通过调用函数<code>BHReadConfiguration</code>读取之前注册到特殊段<em>BeehiveServices</em>中的数据，这里是如下所示的json字符串，<em>{协议字符串:实现该协议的class类名字符串}</em>，如下所示:</p>
<p><code>&#123;"HomeServiceProtocol":"BHViewController”&#125;</code></p>
<p>读取到数据后，进行service的注册：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    //register module</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    //register services</span><br><span class="line">    NSArray&lt;NSString *&gt; *services = BHReadConfiguration(BeehiveServiceSectName,mhp);</span><br><span class="line">    for (NSString *map in services) &#123;</span><br><span class="line">        NSData *jsonData =  [map dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        id json = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [json allKeys].count) &#123;</span><br><span class="line">                </span><br><span class="line">                NSString *protocol = [json allKeys][0];</span><br><span class="line">                NSString *clsName  = [json allValues][0];</span><br><span class="line">                </span><br><span class="line">                if (protocol &amp;&amp; clsName) &#123;</span><br><span class="line">                    [[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)registerService:(Protocol *)service implClass:(Class)implClass</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(service != nil);</span><br><span class="line">    NSParameterAssert(implClass != nil);</span><br><span class="line">    </span><br><span class="line">    if (![implClass conformsToProtocol:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //协议是否已经注册</span><br><span class="line">    if ([self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *key = NSStringFromProtocol(service);</span><br><span class="line">    NSString *value = NSStringFromClass(implClass);</span><br><span class="line">    </span><br><span class="line">    if (key.length &gt; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        [self.lock lock];</span><br><span class="line">        [self.allServicesDict addEntriesFromDictionary:@&#123;key:value&#125;];</span><br><span class="line">        [self.lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注册协议前会有两个检查<code>registerService:implClass:</code>:</p>
<ul>
<li>检查implClass是否遵循了service</li>
<li>检查service协议是否已经注册</li>
</ul>
<p>如果两个条件有一个没有检查通过，则会抛出异常。</p>
<p>如果条件通过，则会在<em>allServicesDict</em>中加入键值对，<em>{NSStringFromProtocol(service):NSStringFromClass(implClass)}</em></p>
<h2 id="读取本地plist方式注册-1">读取本地Plist方式注册</h2>
<p>读取本地的plist文件之前，需要先设置plist文件路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AppDelegate.m</span><br><span class="line">[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService”;</span><br></pre></td></tr></table></figure>
<p>BeeHive的配置都可以通过BHContext进行传递。</p>
<p>plist中的数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;service&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UserTrackServiceProtocol&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;impl&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;BHUserTrackViewController&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p>注册plist中service的时机同注册plist管理的module类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br><span class="line">    </span><br><span class="line">    [BeeHive shareInstance].enableException = YES;</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line">    [[BHTimeProfiler sharedTimeProfiler] recordEventTime:@&quot;BeeHive::super start launch&quot;];</span><br><span class="line">    </span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BeeHive.m</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context = context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException = self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册service的具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName = [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    </span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey = [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass = [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册完成之后，<em>allServicesDict</em>中的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;@&quot;HomeServiceProtocol&quot; : @&quot;BHViewController&quot;, @&quot;UserTrackServiceProtocol&quot; : @&quot;BHUserTrackViewController&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@"plist”];</code>
这段代码，如果主工程Podfile中未使用了<code>use_frameworks!</code>，则可以正常获取到plist，如果使用了<code>use_frameworks!</code>，则得使用其他方式获取，具体的方案请google。</p>
<h2 id="api注册">API注册</h2>
<p>API注册service使用的api是BeeHive的接口<code>- (void)registerService:(Protocol *)proto service:(Class)serviceClass</code>,
该接口内部实现也是调用<code>BHServiceManager</code>的<code>registerService:implClass:</code>接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// BeeHive.m</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class)serviceClass &#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：<code>[[BeeHive shareInstance] registerService:@protocol(TradeServiceProtocol) service:[BHTradeViewController class]];</code>,
该代码可以放置在module的
<code>modInit:</code>方法内部或者<code>modSetup:</code>方法内部，具体可以查看使用文档或者demo。</p>
<p>注意：<em>BHMSetupEvent</em>和<em>BHMInitEvent</em>事件都会在项目的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>函数内部触发。</p>
<p>BHServiceManager中的<em>allServicesDict</em>包含了所有方式注册的service。</p>
<p>与module注册相比，service的注册没有对实现协议的对象进行初始化。只是将协议和实现协议的对象之间的这种关联关系存储和维护，而在module的注册过程中，对所有注册的module进行实例的初始化。</p>
<p>因此，在BHServiceManager的公共接口中，有一组<code>createService:</code>接口用于访问实现协议的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName = NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance = nil;</span><br><span class="line">    </span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr = serviceName;</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class implClass = [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                implInstance = [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                implInstance = [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的实现中可以看出：</p>
<ul>
<li>service对象存在单例和多实例的区别。</li>
<li>如果<em>BHServiceProtocol</em>协议对象实现了<code>singleton</code>返回YES，且<em>shouldCache</em>入参值是YES，则通过<code>createService:</code>获取的对象为单例对象，如果<code>singleton</code>方法返回的是NO，则每次调用<code>createService:</code>都会创建一个新的对象。</li>
<li>这里的单例存在线程安全问题。如果开发者将<em>BHServiceProtocol</em>协议对象实现了<code>singleton</code>返回YES，且<code>shareInstance</code>方法的实现是返回单例对象，则不管<em>shouldCache</em>的入参值是YES还是NO，<code>createService:</code>都会是同一个实例。但是，如果开发者将<code>shareInstance</code>方法的实现只是返回对象(非单例)，即使<code>singleton</code>返回YES，<em>shouldCache</em>入参值是YES，也可能存在多个实例的情况。</li>
</ul>
<h1 id="上下文环境context">上下文环境Context</h1>
<p>BeeHive中使用BHContext初始化设置应用的项目信息，并在各模块间共享整个应用程序的信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [BHContext shareInstance].env ＝ BHEnvironmentDev; //定义应用的运行开发环境</span><br><span class="line">    [BHContext shareInstance].application = application;</span><br><span class="line">    [BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">    [BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/CustomModulePlist&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">    [BHContext shareInstance].serviceConfigName =  @&quot;BeeHive.bundle/CustomServicePlist&quot;;//可选，默认为BeeHive.bundle/BHService.plist</span><br><span class="line">    [[BeeHive shareInstance] setContext:[BHContext shareInstance]];</span><br><span class="line"></span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BHContext.h</span><br><span class="line"></span><br><span class="line">@interface BHContext : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">//global env</span><br><span class="line">@property(nonatomic, assign) BHEnvironmentType env;</span><br><span class="line"></span><br><span class="line">//global config</span><br><span class="line">@property(nonatomic, strong) BHConfig *config;</span><br><span class="line"></span><br><span class="line">//application appkey</span><br><span class="line">@property(nonatomic, strong) NSString *appkey;</span><br><span class="line">//customEvent&gt;=1000</span><br><span class="line">@property(nonatomic, assign) NSInteger customEvent;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) UIApplication *application;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSDictionary *launchOptions;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *moduleConfigName;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong) NSString *serviceConfigName;</span><br><span class="line"></span><br><span class="line">//3D-Touch model</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80400</span><br><span class="line">@property (nonatomic, strong) BHShortcutItem *touchShortcutItem;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//OpenURL model</span><br><span class="line">@property (nonatomic, strong) BHOpenURLItem *openURLItem;</span><br><span class="line"></span><br><span class="line">//Notifications Remote or Local</span><br><span class="line">@property (nonatomic, strong) BHNotificationsItem *notificationsItem;</span><br><span class="line"></span><br><span class="line">//user Activity Model</span><br><span class="line">@property (nonatomic, strong) BHUserActivityItem *userActivityItem;</span><br><span class="line"></span><br><span class="line">//watch Model</span><br><span class="line">@property (nonatomic, strong) BHWatchItem *watchItem;</span><br><span class="line"></span><br><span class="line">//custom param</span><br><span class="line">@property (nonatomic, copy) NSDictionary *customParam;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>应用的运行开发环境</li>
<li>应用启动信息：application，launchOptions</li>
<li>module和service的plist配置信息</li>
<li>缓存的service</li>
<li>3D-Touch, OpenURL moduel, Remote Or Local Notifications, User
Activity Model等</li>
</ul>
<p>最后，附一张BeeHive主要类的的类图关系。</p>
<!--![BeeHive类图](/img/beehive-analysis/beehive-class.png)-->
<div class="figure center" style="width:;"><img class="fig-img" src="/img/beehive-analysis/beehive-class.png" alt="BeeHive类图"><span class="caption">BeeHive类图</span></div>
<hr />
<p>目前已转行教育行业，欢迎加微信交流：CaryaLiu</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/iOS/" rel="tag">iOS</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/08/06/design-principles-srp-md/"
                    data-tooltip="设计模式之单一职责原则"
                    aria-label="PREVIOUS: 设计模式之单一职责原则"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/09/18/design-pattern-strategy/"
                    data-tooltip="iOS策略设计模式实践"
                    aria-label="NEXT: iOS策略设计模式实践"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CaryaLiu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/08/06/design-principles-srp-md/"
                    data-tooltip="设计模式之单一职责原则"
                    aria-label="PREVIOUS: 设计模式之单一职责原则"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/09/18/design-pattern-strategy/"
                    data-tooltip="iOS策略设计模式实践"
                    aria-label="NEXT: iOS策略设计模式实践"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">CaryaLiu</h4>
        
            <div id="about-card-bio"><p><span class="citation"
data-cites="Chengdu">@Chengdu</span>，WeChat：CaryaLiu</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Teacher</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Chengdu
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-cs5ywvosncuchmfbylvxzu6rf0pcfv37ilsjrqcvnjbcjeqx9g2hzm1ygmp1.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
