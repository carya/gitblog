
<!DOCTYPE html>
<html lang="en,zh-CN,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="CaryaLiu&#39;s blog">
    <title>__attribute__ - CaryaLiu&#39;s blog</title>
    <meta name="author" content="CaryaLiu">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CaryaLiu","sameAs":[],"image":"header.png"},"articleBody":"__attribute__是在C, C++, Objective-C语言中使用的编译指令，一般以__attribute__(xxx)的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。\n\n\n\n\nAttribute语法关于Attribute的语法描述见官方文档Attribute Syntax\n\n\nAn attribute specifier is of the form __attribute__ ((attribute-list)). An attribute list is a possibly empty comma-separated sequence of attributes, where each attribute is one of the following:\n\n\n\nEmpty. Empty attributes are ignored.\nAn attribute name (which may be an identifier such as unused, or a reserved word such as const).\nAn attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:\n\nAn identifier. For example, mode attributes use this form.\nAn identifier followed by a comma and a non-empty comma-separated list of expressions. For example, format attributes use this form.\nA possibly empty comma-separated list of expressions. For example, format_arg attributes use this form with the list being a single integer constant expression, and alias attributes use this form with the list being a single string constant.\n\n\n\n\nusedused的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。具体的描述可以看gun的官方文档。\n\n\nused\n\n\nThis attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.\n\n\nWhen applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.\nsection通常情况下，编译器会将对象放置于DATA段的data或者bss节中。但是，有时我们需要将数据放置于特殊的节中，此时section可以达到目的。例如，BeeHive中就把module注册数据存在__DATA数据段里面的”BeehiveMods”section中。\nsection通常用于修饰全局变量。以下是gnu官网对section属性的说明。\n\n\nsection (“section-name”)\n\n\nNormally, the compiler places the objects it generates in sections like data and bss. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The section attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:\n\n\n12345678910111213struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;int init_data __attribute__ ((section (&quot;INITDATA&quot;)));main() &#123;  /* Initialize stack pointer */  init_sp (stack + sizeof (stack));  /* Initialize initialized data */  memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);  /* Turn on the serial ports */  init_duart (&amp;a);  init_duart (&amp;b);&#125;\n\nUse the section attribute with global variables and not local variables, as shown in the example.\n\nYou may use the section attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the common (or bss) section and can be multiply “defined”. Using the section attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the -fno-common flag or the nocommon attribute.\n\n\nSome file formats do not support arbitrary sections so the section attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.\n__attribute__的更多使用示例可参考FBTweak\n\n编译器提供了我们一种__attribute__((section(&quot;xxx段，xxx节&quot;)的方式让我们将一个指定的数据储存到我们需要的节当中。\n\n在BeeHive框架中：\n1@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;\n\n通过使用__attribute__((section(&quot;name&quot;)))来指明哪个段。数据则用__attribute__((used))来标记，防止链接器会优化删除未被使用的段。\n编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)格式主要是\n\nWindows下的PE(Portable Executable)\nLinux的ELF(Executable Linkable Format)\nmacOS&#x2F;iOS系统上的Mach-O（Mach Object File Format）\n\n程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，data和*.bss*节属于数据段。\n\nMach-O内存布局\n\nMach-O的组成结构如上图所示包括了Header、Load commands、Data（包含Segement的具体数据），我们平时了解到的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。\n\n一个现代编译器的主要工作流程如下：\n\n源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（Linker）→ 可执行文件（executables）， 最后打包好的文件就可以给计算机去判读运行了。\n编译后各个section存储的内容如下：\n\n\n\nSegment and Section Name\nContents\n\n\n\n__TEXT,__text\nExecutable machine code. The compiler places only executable code in this section; no tables or data of any sort are stored here.\n\n\n__TEXT,__cstring\nConstant C strings. A C string is a sequence of non-null bytes that ends with a null byte (‘\\0’). The static linker coalesces constant C string values, removing duplicates, when building the final product.\n\n\n__TEXT,__picsymbol_stub\nPosition -independent indirect symbol stubs. See “Indirect Addressing” for more information.\n\n\n__TEXT,__symbol_stub\nIndirect symbol stubs. See “Indirect Addressing” for more information.\n\n\n__TEXT,__const\nInitialized constant variables. The compiler places all data declared const in this section.\n\n\n__TEXT,__literal4\n4-byte literal values. The compiler places single-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.\n\n\n__TEXT,__literal8\n8-byte literal values. The compiler places double-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.\n\n\n__DATA,__data\nInitialized mutable variables, such as writable C strings and data arrays.\n\n\n__DATA,__la_symbol_ptr\nLazy symbol pointers, which are indirect references to functions imported from a different file. See “Indirect Addressing” for more information.\n\n\n__DATA,__nl_symbol_ptr\nNon-lazy symbol pointers, which are indirect references to data items imported from a different file. See “Indirect Addressing” for more information.\n\n\n__DATA,__dyld\nInformation used by the static linker.\n\n\n__DATA,__const\nUnintialized constant variables.\n\n\n__DATA,__mod_init_func\nModule initialization functions. The C++ compiler places static constructors here.\n\n\n__DATA,__mod_term_func\nModule termination functions.\n\n\n__DATA,__bss\nData for uninitialized static variables (for example, static int i;).\n\n\n__DATA,__common\nUninitialized imported symbol definitions (for example, int i;) located in the global scope (outside of a function declaration).\n\n\n从上面的表格可以看出：\n\n__TEXT,__text：可执行的机器码(代码段)\n__TEXT,__const：已初始化的常量，编译器会将所有声明为const的数据放置在该section；\n__DATA,__data：已初始化的可变全局变量；\n__DATA,__bss：未初始化的全局静态变量和局部静态变量，例如 static int i;\n__DATA,__common：未初始化的全局变量；\n\n全局变量是放在全局内存中的，用static修饰的局部变量也是会放在放全局内存的，它的作用域是局部的，但生命期是全局的。\n全局强调的是它的生命期，而不是它的作用域，所以有时可能把两者的概念互换。一般来说，在一起定义的两个全局变量，在内存的中位置是相邻的。这是一个简单的常识，但有时挺有用，如果一个全局变量被破坏了，不防先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。\nconstructor上一节只是讲到如何将数据存入特殊的section中，那么如何把存入的数据读取出来呢？\n这里先介绍一下__attribute__((constructor))。\nconstructor：顾名思义，构造器加上这个属性的函数会在可执行文件（或 shared library）load时被调用，可以理解为在 main() 函数调用前执行：\n123456789101112131415__attribute__((constructor))static void beforeMain(void) &#123;    NSLog(@&quot;beforeMain&quot;);&#125;__attribute__((destructor))static void afterMain(void) &#123;    NSLog(@&quot;afterMain&quot;);&#125;int main(int argc, const char * argv[]) &#123;    NSLog(@&quot;main&quot;);    return 0;&#125;// Console:// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;\n\nconstructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机：\n\n所有Class都已经加载完成\nmain 函数还未执行\n无需像 +load 还得挂载在一个Class中\n\n读取section中的值现在来了解如何将存储在特殊section中的数据读出。\n在BeeHive源码中有下面一段代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344__attribute__((constructor))void initProphet() &#123;    _dyld_register_func_for_add_image(dyld_callback);&#125;static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)&#123;    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);    for (NSString *modName in mods) &#123;        Class cls;        if (modName) &#123;            cls = NSClassFromString(modName);                        if (cls) &#123;                [[BHModuleManager sharedManager] registerDynamicModule:cls];            &#125;        &#125;    &#125;&#125;NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)&#123;    NSMutableArray *configs = [NSMutableArray array];    unsigned long size = 0;#ifndef __LP64__    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);#else    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);#endif        unsigned long counter = size/sizeof(void*);    for(int idx = 0; idx &lt; counter; ++idx)&#123;        char *string = (char*)memory[idx];        NSString *str = [NSString stringWithUTF8String:string];        if(!str)continue;                BHLog(@&quot;config = %@&quot;, str);        if(str) [configs addObject:str];    &#125;        return configs;&#125;\n\n其中void initProphet()使用了__attribute__((constructor))修饰，其执行时机已在上一节提到。该函数的实现体里使用了_dyld_register_func_for_add_image函数，现在看看该函数的作用。\n_dyld_register_func_for_add_image:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:\n12345678910/* * The following functions allow you to install callbacks which will be called    * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image() * the callback func is called for every existing image.  Later, it is called as each new image * is loaded and bound (but initializers not yet run).  The callback registered with * _dyld_register_func_for_remove_image() is called after any terminators in an image are run * and before the image is un-memory-mapped. */extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))\n\n对于每一个已经存在的镜像，当它被动态链接时，都会执行回调void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)，传入文件的mach_header以及一个虚拟内存地址 intptr_t。\nmach_header是定义在usr/include/mach-o/loader.h中的数据结构：\n1234567891011121314/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123;     uint32_t    magic;        /* mach magic number identifier */     cpu_type_t    cputype;    /* cpu specifier */     cpu_subtype_t    cpusubtype;    /* machine specifier */     uint32_t    filetype;    /* type of file */     uint32_t    ncmds;        /* number of load commands */     uint32_t    sizeofcmds;    /* the size of all the load commands */     uint32_t    flags;        /* flags */     uint32_t    reserved;    /* reserved */&#125;;\n\n通过调用BHReadConfiguration函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。\n参考：\n\nClang Attributes 黑魔法小记\nAttribute Syntax\nOverview of the Mach-O Executable Format\nPARSING MACH-O FILES\n\n\n如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^\n\n","dateCreated":"2018-08-18T22:43:39+08:00","dateModified":"2021-04-18T11:40:43+08:00","datePublished":"2018-08-18T22:43:39+08:00","description":"__attribute__是在C, C++, Objective-C语言中使用的编译指令，一般以__attribute__(xxx)的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。","headline":"__attribute__","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://liumh.com/2018/08/18/ios-attribute-section/"},"publisher":{"@type":"Organization","name":"CaryaLiu","sameAs":[],"image":"header.png","logo":{"@type":"ImageObject","url":"header.png"}},"url":"http://liumh.com/2018/08/18/ios-attribute-section/"}</script>
    <meta name="description" content="__attribute__是在C, C++, Objective-C语言中使用的编译指令，一般以__attribute__(xxx)的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。">
<meta property="og:type" content="blog">
<meta property="og:title" content="__attribute__">
<meta property="og:url" content="http://liumh.com/2018/08/18/ios-attribute-section/index.html">
<meta property="og:site_name" content="CaryaLiu&#39;s blog">
<meta property="og:description" content="__attribute__是在C, C++, Objective-C语言中使用的编译指令，一般以__attribute__(xxx)的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://liumh.com/img/ios-attribute-section/Mach-O.png">
<meta property="og:image" content="http://liumh.com/img/wechat_appreciate_qrcode.jpeg">
<meta property="article:published_time" content="2018-08-18T14:43:39.000Z">
<meta property="article:modified_time" content="2021-04-18T03:40:43.000Z">
<meta property="article:author" content="CaryaLiu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://liumh.com/img/ios-attribute-section/Mach-O.png">
    
    
        
    
    
        <meta property="og:image" content="http://liumh.com/assets/images/header.png"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-m6nivvurtlevuhwfo3cagj3wjhzynetfsx9hangffcjz4rld46wsu1znmnqb.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            CaryaLiu&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">CaryaLiu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>@Chengdu</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            __attribute__
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-18T22:43:39+08:00">
	
		    Aug 18, 2018
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><code>__attribute__</code>是在C, C++, Objective-C语言中使用的编译指令，一般以<code>__attribute__(xxx)</code>的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。</p>
<span id="more"></span>

<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Attribute%E8%AF%AD%E6%B3%95"><span class="toc-text">Attribute语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#used"><span class="toc-text">used</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#section"><span class="toc-text">section</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#constructor-NaN"><span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96section%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-text">读取section中的值</span></a></li></ol>

<h1 id="Attribute语法"><a href="#Attribute语法" class="headerlink" title="Attribute语法"></a>Attribute语法</h1><p>关于Attribute的语法描述见官方文档<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">Attribute Syntax</a></p>
<blockquote>
</blockquote>
<p>An attribute specifier is of the form <code>__attribute__ ((attribute-list))</code>. An attribute list is a possibly empty comma-separated sequence of attributes, where each attribute is one of the following:</p>
<blockquote>
</blockquote>
<ul>
<li>Empty. Empty attributes are ignored.</li>
<li>An attribute name (which may be an identifier such as <em>unused</em>, or a reserved word such as <em>const</em>).</li>
<li>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:<blockquote>
<ul>
<li>An identifier. For example, <em>mode</em> attributes use this form.</li>
<li>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, <em>format</em> attributes use this form.</li>
<li>A possibly empty comma-separated list of expressions. For example, <em>format_arg</em> attributes use this form with the list being a single integer constant expression, and <em>alias</em> attributes use this form with the list being a single string constant.</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="used"><a href="#used" class="headerlink" title="used"></a>used</h1><p><em>used</em>的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。具体的描述可以看<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes">gun的官方文档</a>。</p>
<blockquote>
</blockquote>
<p><em>used</em></p>
<blockquote>
</blockquote>
<p>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</p>
<blockquote>
</blockquote>
<p>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</p>
<h1 id="section"><a href="#section" class="headerlink" title="section"></a>section</h1><p>通常情况下，编译器会将对象放置于DATA段的<em>data</em>或者<em>bss</em>节中。但是，有时我们需要将数据放置于特殊的节中，此时<em>section</em>可以达到目的。例如，BeeHive中就把module注册数据存在__DATA数据段里面的”BeehiveMods”section中。</p>
<p><em>section</em>通常用于修饰全局变量。以下是gnu官网对<em>section</em>属性的说明。</p>
<blockquote>
</blockquote>
<p><em>section (“section-name”)</em></p>
<blockquote>
</blockquote>
<p>Normally, the compiler places the objects it generates in sections like <em>data</em> and <em>bss</em>. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The <em>section</em> attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:</p>
<blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct duart a __attribute__ ((section (&quot;DUART_A&quot;))) = &#123; 0 &#125;;</span><br><span class="line">struct duart b __attribute__ ((section (&quot;DUART_B&quot;))) = &#123; 0 &#125;;</span><br><span class="line">char stack[10000] __attribute__ ((section (&quot;STACK&quot;))) = &#123; 0 &#125;;</span><br><span class="line">int init_data __attribute__ ((section (&quot;INITDATA&quot;)));</span><br><span class="line">main() &#123;</span><br><span class="line">  /* Initialize stack pointer */</span><br><span class="line">  init_sp (stack + sizeof (stack));</span><br><span class="line">  /* Initialize initialized data */</span><br><span class="line">  memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</span><br><span class="line">  /* Turn on the serial ports */</span><br><span class="line">  init_duart (&amp;a);</span><br><span class="line">  init_duart (&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use the <em>section</em> attribute with <em>global</em> variables and not <em>local</em> variables, as shown in the example.</p>
</blockquote>
<p>You may use the <em>section</em> attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the <em>common</em> (or <em>bss</em>) section and can be multiply “defined”. Using the <em>section</em> attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the <em>-fno-common</em> flag or the <em>nocommon</em> attribute.</p>
<blockquote>
</blockquote>
<p>Some file formats do not support arbitrary sections so the <em>section</em> attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</p>
<p><code>__attribute__</code>的更多使用示例可参考<a target="_blank" rel="noopener" href="https://github.com/facebook/Tweaks">FBTweak</a></p>
<blockquote>
<p>编译器提供了我们一种<code>__attribute__((section(&quot;xxx段，xxx节&quot;)</code>的方式让我们将一个指定的数据储存到我们需要的节当中。</p>
</blockquote>
<p>在<a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">BeeHive框架</a>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>__attribute__((section(&quot;name&quot;)))</code>来指明哪个段。数据则用<code>__attribute__((used))</code>来标记，防止链接器会优化删除未被使用的段。</p>
<p>编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)格式主要是</p>
<ul>
<li>Windows下的PE(Portable Executable)</li>
<li>Linux的ELF(Executable Linkable Format)</li>
<li>macOS&#x2F;iOS系统上的Mach-O（Mach Object File Format）</li>
</ul>
<p>程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，<em>data</em>和*.bss*节属于数据段。</p>
<!--![Mach-O内存布局](/img/ios-attribute-section/Mach-O.png)-->
<div class="figure center" style="width:431;"><img class="fig-img" src="/img/ios-attribute-section/Mach-O.png" style="width:431;height:496;"alt="Mach-O内存布局"><span class="caption">Mach-O内存布局</span></div>

<p>Mach-O的组成结构如上图所示包括了Header、Load commands、Data（包含Segement的具体数据），我们平时了解到的可执行文件、库文件、Dsym文件、动态库、动态连接器都是这种格式的。</p>
<blockquote>
<p>一个现代<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>的主要工作流程如下：</p>
</blockquote>
<p>源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（Linker）→ 可执行文件（executables）， 最后打包好的文件就可以给计算机去判读运行了。</p>
<p>编译后各个section存储的内容如下：</p>
<table>
<thead>
<tr>
<th>Segment and Section Name</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td>__TEXT,__text</td>
<td>Executable machine code. The compiler places only executable code in this section; no tables or data of any sort are stored here.</td>
</tr>
<tr>
<td>__TEXT,__cstring</td>
<td>Constant C strings. A C string is a sequence of non-null bytes that ends with a null byte (‘\0’). The static linker coalesces constant C string values, removing duplicates, when building the final product.</td>
</tr>
<tr>
<td>__TEXT,__picsymbol_stub</td>
<td>Position -independent indirect symbol stubs. See “Indirect Addressing” for more information.</td>
</tr>
<tr>
<td>__TEXT,__symbol_stub</td>
<td>Indirect symbol stubs. See “Indirect Addressing” for more information.</td>
</tr>
<tr>
<td>__TEXT,__const</td>
<td>Initialized constant variables. The compiler places all data declared const in this section.</td>
</tr>
<tr>
<td>__TEXT,__literal4</td>
<td>4-byte literal values. The compiler places single-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.</td>
</tr>
<tr>
<td>__TEXT,__literal8</td>
<td>8-byte literal values. The compiler places double-precision floating point constants in this section. The static linker coalesces these values, removing duplicates, when building the final product. With some CPU architectures, it is more efficient for the compiler to use immediate load instructions rather than adding to this section.</td>
</tr>
<tr>
<td>__DATA,__data</td>
<td>Initialized mutable variables, such as writable C strings and data arrays.</td>
</tr>
<tr>
<td>__DATA,__la_symbol_ptr</td>
<td>Lazy symbol pointers, which are indirect references to functions imported from a different file. See “Indirect Addressing” for more information.</td>
</tr>
<tr>
<td>__DATA,__nl_symbol_ptr</td>
<td>Non-lazy symbol pointers, which are indirect references to data items imported from a different file. See “Indirect Addressing” for more information.</td>
</tr>
<tr>
<td>__DATA,__dyld</td>
<td>Information used by the static linker.</td>
</tr>
<tr>
<td>__DATA,__const</td>
<td>Unintialized constant variables.</td>
</tr>
<tr>
<td>__DATA,__mod_init_func</td>
<td>Module initialization functions. The C++ compiler places static constructors here.</td>
</tr>
<tr>
<td>__DATA,__mod_term_func</td>
<td>Module termination functions.</td>
</tr>
<tr>
<td>__DATA,__bss</td>
<td>Data for uninitialized static variables (for example, static int i;).</td>
</tr>
<tr>
<td>__DATA,__common</td>
<td>Uninitialized imported symbol definitions (for example, int i;) located in the global scope (outside of a function declaration).</td>
</tr>
</tbody></table>
<p>从上面的表格可以看出：</p>
<ul>
<li>__TEXT,__text：可执行的机器码(代码段)</li>
<li>__TEXT,__const：已初始化的常量，编译器会将所有声明为const的数据放置在该section；</li>
<li>__DATA,__data：已初始化的可变全局变量；</li>
<li>__DATA,__bss：未初始化的全局静态变量和局部静态变量，例如 <code>static int i;</code></li>
<li>__DATA,__common：未初始化的全局变量；</li>
</ul>
<p>全局变量是放在全局内存中的，用static修饰的局部变量也是会放在放全局内存的，它的作用域是局部的，但生命期是全局的。</p>
<p>全局强调的是它的生命期，而不是它的作用域，所以有时可能把两者的概念互换。一般来说，在一起定义的两个全局变量，在内存的中位置是相邻的。这是一个简单的常识，但有时挺有用，如果一个全局变量被破坏了，不防先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>上一节只是讲到如何将数据存入特殊的section中，那么如何把存入的数据读取出来呢？</p>
<p>这里先介绍一下<code>__attribute__((constructor))</code>。</p>
<p><em>constructor</em>：顾名思义，构造器加上这个属性的函数会在可执行文件（或 shared library）load时被调用，可以理解为在 main() 函数调用前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforeMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;beforeMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">static void afterMain(void) &#123;</span><br><span class="line">    NSLog(@&quot;afterMain&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;main&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Console:</span><br><span class="line">// &quot;beforeMain&quot; -&gt; &quot;main&quot; -&gt; “afterMain&quot;</span><br></pre></td></tr></table></figure>

<p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机：</p>
<ol>
<li>所有Class都已经加载完成</li>
<li>main 函数还未执行</li>
<li>无需像 +load 还得挂载在一个Class中</li>
</ol>
<h1 id="读取section中的值"><a href="#读取section中的值" class="headerlink" title="读取section中的值"></a>读取section中的值</h1><p>现在来了解如何将存储在特殊section中的数据读出。</p>
<p>在BeeHive源码中有下面一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls = NSClassFromString(modName);</span><br><span class="line">            </span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>void initProphet()</code>使用了<code>__attribute__((constructor))</code>修饰，其执行时机已在上一节提到。该函数的实现体里使用了<code>_dyld_register_func_for_add_image</code>函数，现在看看该函数的作用。</p>
<p><code>_dyld_register_func_for_add_image</code>:这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数；当然，我们也可以使用下面的方法注册自定义的回调函数，同时也会为所有已经加载的镜像执行回调:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following functions allow you to install callbacks which will be called   </span><br><span class="line"> * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line"> * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line"> * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line"> * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line"> * and before the image is un-memory-mapped.</span><br><span class="line"> */</span><br><span class="line">extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) </span><br><span class="line">extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide))</span><br></pre></td></tr></table></figure>

<p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调<code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的mach_header以及一个虚拟内存地址 intptr_t。</p>
<p>mach_header是定义在<code>usr/include/mach-o/loader.h</code>中的数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">     uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">     cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">     cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">     uint32_t    filetype;    /* type of file */</span><br><span class="line">     uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">     uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">     uint32_t    flags;        /* flags */</span><br><span class="line">     uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过调用<em>BHReadConfiguration</em>函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">Attribute Syntax</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html#//apple_ref/doc/uid/20001860-BAJGJEJC">Overview of the Mach-O Executable Format</a></li>
<li><a target="_blank" rel="noopener" href="https://lowlevelbits.org/parsing-mach-o-files/">PARSING MACH-O FILES</a></li>
</ul>
<hr>
<p>如果觉得本文对你有帮助，就请用微信随意打赏我吧^_^</p>
<div class="figure " style="width:174px;"><img class="fig-img" src="/img/wechat_appreciate_qrcode.jpeg" style="width:174px;height:174px;"alt=""></div>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/09/18/design-pattern-strategy/"
                    data-tooltip="iOS策略设计模式实践"
                    aria-label="PREVIOUS: iOS策略设计模式实践"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2017/12/29/ios-uicollectionviewlayoutattributes/"
                    data-tooltip="UICollectionViewLayoutAttributes初探"
                    aria-label="NEXT: UICollectionViewLayoutAttributes初探"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 CaryaLiu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/09/18/design-pattern-strategy/"
                    data-tooltip="iOS策略设计模式实践"
                    aria-label="PREVIOUS: iOS策略设计模式实践"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2017/12/29/ios-uicollectionviewlayoutattributes/"
                    data-tooltip="UICollectionViewLayoutAttributes初探"
                    aria-label="NEXT: UICollectionViewLayoutAttributes初探"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://liumh.com/2018/08/18/ios-attribute-section/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="Table of Contents">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://liumh.com/2018/08/18/ios-attribute-section/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://liumh.com/2018/08/18/ios-attribute-section/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://liumh.com/2018/08/18/ios-attribute-section/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.png" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">CaryaLiu</h4>
        
            <div id="about-card-bio"><p>@Chengdu</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>iOS Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Chengdu
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-0cj71mixkkwdp0vs8wjjkzbxkqkvcb59caculu32e29euc2z9epm5lizux6e.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
